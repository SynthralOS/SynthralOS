var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc13) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc13 = __getOwnPropDesc(from, key)) || desc13.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// server/services/telemetry/posthog-wrapper.cjs
var require_posthog_wrapper = __commonJS({
  "server/services/telemetry/posthog-wrapper.cjs"(exports, module) {
    "use strict";
    var PostHogClient2;
    try {
      PostHogClient2 = __require("posthog-node");
      if (PostHogClient2.default) {
        PostHogClient2 = PostHogClient2.default;
      }
    } catch (e) {
      console.warn("Could not load PostHog client:", e);
      PostHogClient2 = class PostHogStub {
        constructor() {
        }
        capture() {
        }
        identify() {
        }
        groupIdentify() {
        }
        isFeatureEnabled() {
          return false;
        }
        getAllFlags() {
          return {};
        }
        shutdown() {
          return Promise.resolve();
        }
      };
    }
    module.exports = {
      PostHogClient: PostHogClient2,
      initPostHog: function(options2) {
        const { apiKey, host, flushAt, flushInterval } = options2;
        try {
          return new PostHogClient2(apiKey, {
            host: host || "https://app.posthog.com",
            flushAt: flushAt || 20,
            flushInterval: flushInterval || 1e4
          });
        } catch (e) {
          console.warn("Error initializing PostHog:", e);
          return new PostHogClient2();
        }
      }
    };
  }
});

// server/index.ts
import express7 from "express";

// server/routes.ts
import { createServer } from "http";

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  AirbyteConnectionStatus: () => AirbyteConnectionStatus,
  AirbyteSyncStatus: () => AirbyteSyncStatus,
  AlertStatus: () => AlertStatus,
  ComposioExecutionStatusType: () => ComposioExecutionStatusType,
  ComposioWorkflowStatusType: () => ComposioWorkflowStatusType,
  EntityType: () => EntityType,
  ExecutionStatus: () => ExecutionStatus,
  JobStatus: () => JobStatus,
  LogLevel: () => LogLevel,
  MemoryType: () => MemoryType,
  NodePosition: () => NodePosition,
  OAuthConnectionStatus: () => OAuthConnectionStatus,
  RagType: () => RagType,
  SlackConnectionStatus: () => SlackConnectionStatus,
  SlackWebhookEventType: () => SlackWebhookEventType,
  VectorDbType: () => VectorDbType,
  activityLogs: () => activityLogs,
  airbyteConfigs: () => airbyteConfigs,
  airbyteConnections: () => airbyteConnections,
  airbyteDestinations: () => airbyteDestinations,
  airbyteSources: () => airbyteSources,
  airbyteSyncJobs: () => airbyteSyncJobs,
  changeDetectionAlerts: () => changeDetectionAlerts,
  changeDetectionMonitors: () => changeDetectionMonitors,
  composioActions: () => composioActions,
  composioConfigs: () => composioConfigs,
  composioExecutions: () => composioExecutions,
  composioTriggers: () => composioTriggers,
  composioWorkflows: () => composioWorkflows,
  executionLogs: () => executionLogs,
  insertActivityLogSchema: () => insertActivityLogSchema,
  insertAirbyteConfigSchema: () => insertAirbyteConfigSchema,
  insertAirbyteConnectionSchema: () => insertAirbyteConnectionSchema,
  insertAirbyteDestinationSchema: () => insertAirbyteDestinationSchema,
  insertAirbyteSourceSchema: () => insertAirbyteSourceSchema,
  insertAirbyteSyncJobSchema: () => insertAirbyteSyncJobSchema,
  insertChangeDetectionAlertSchema: () => insertChangeDetectionAlertSchema,
  insertChangeDetectionMonitorSchema: () => insertChangeDetectionMonitorSchema,
  insertComposioActionSchema: () => insertComposioActionSchema,
  insertComposioConfigSchema: () => insertComposioConfigSchema,
  insertComposioExecutionSchema: () => insertComposioExecutionSchema,
  insertComposioTriggerSchema: () => insertComposioTriggerSchema,
  insertComposioWorkflowSchema: () => insertComposioWorkflowSchema,
  insertExecutionLogSchema: () => insertExecutionLogSchema,
  insertKnowledgeGraphEdgeSchema: () => insertKnowledgeGraphEdgeSchema,
  insertKnowledgeGraphNodeSchema: () => insertKnowledgeGraphNodeSchema,
  insertMemoryEntrySchema: () => insertMemoryEntrySchema,
  insertMemorySystemSchema: () => insertMemorySystemSchema,
  insertMonitorResultSchema: () => insertMonitorResultSchema,
  insertNodeExecutionSchema: () => insertNodeExecutionSchema,
  insertOAuthConnectionSchema: () => insertOAuthConnectionSchema,
  insertRagSystemSchema: () => insertRagSystemSchema,
  insertSavedSearchSchema: () => insertSavedSearchSchema,
  insertScrapingJobSchema: () => insertScrapingJobSchema,
  insertScrapingResultSchema: () => insertScrapingResultSchema,
  insertScrapingTemplateSchema: () => insertScrapingTemplateSchema,
  insertSlackChannelSchema: () => insertSlackChannelSchema,
  insertSlackConfigSchema: () => insertSlackConfigSchema,
  insertSlackMessageSchema: () => insertSlackMessageSchema,
  insertSlackWebhookSchema: () => insertSlackWebhookSchema,
  insertSocialAlertSchema: () => insertSocialAlertSchema,
  insertSocialConnectorSchema: () => insertSocialConnectorSchema,
  insertSocialMonitorSchema: () => insertSocialMonitorSchema,
  insertUserPreferenceSchema: () => insertUserPreferenceSchema,
  insertUserSchema: () => insertUserSchema,
  insertVectorCollectionSchema: () => insertVectorCollectionSchema,
  insertVectorDatabaseSchema: () => insertVectorDatabaseSchema,
  insertVectorItemSchema: () => insertVectorItemSchema,
  insertWorkflowExecutionSchema: () => insertWorkflowExecutionSchema,
  insertWorkflowSchema: () => insertWorkflowSchema2,
  knowledgeGraphEdges: () => knowledgeGraphEdges,
  knowledgeGraphNodes: () => knowledgeGraphNodes,
  memoryEntries: () => memoryEntries,
  memorySystems: () => memorySystems,
  monitorResults: () => monitorResults,
  nodeExecutions: () => nodeExecutions,
  oauthConnections: () => oauthConnections,
  ragSystems: () => ragSystems,
  savedSearches: () => savedSearches,
  scrapingJobs: () => scrapingJobs,
  scrapingResults: () => scrapingResults,
  scrapingTemplates: () => scrapingTemplates,
  slackChannels: () => slackChannels,
  slackConfigs: () => slackConfigs,
  slackMessages: () => slackMessages,
  slackWebhooks: () => slackWebhooks,
  socialAlerts: () => socialAlerts,
  socialConnectors: () => socialConnectors,
  socialMonitors: () => socialMonitors,
  userPreferences: () => userPreferences,
  users: () => users,
  vectorCollections: () => vectorCollections,
  vectorDatabases: () => vectorDatabases,
  vectorItems: () => vectorItems,
  workflowDataSchema: () => workflowDataSchema,
  workflowExecutions: () => workflowExecutions,
  workflows: () => workflows
});
import { pgTable, text, varchar, timestamp, serial, integer, jsonb, boolean, real, index } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
var AirbyteConnectionStatus = /* @__PURE__ */ ((AirbyteConnectionStatus3) => {
  AirbyteConnectionStatus3["Active"] = "active";
  AirbyteConnectionStatus3["Inactive"] = "inactive";
  AirbyteConnectionStatus3["Deprecated"] = "deprecated";
  return AirbyteConnectionStatus3;
})(AirbyteConnectionStatus || {});
var AirbyteSyncStatus = /* @__PURE__ */ ((AirbyteSyncStatus3) => {
  AirbyteSyncStatus3["Pending"] = "pending";
  AirbyteSyncStatus3["Running"] = "running";
  AirbyteSyncStatus3["Succeeded"] = "succeeded";
  AirbyteSyncStatus3["Failed"] = "failed";
  AirbyteSyncStatus3["Cancelled"] = "cancelled";
  return AirbyteSyncStatus3;
})(AirbyteSyncStatus || {});
var JobStatus = /* @__PURE__ */ ((JobStatus2) => {
  JobStatus2["Created"] = "created";
  JobStatus2["Running"] = "running";
  JobStatus2["Completed"] = "completed";
  JobStatus2["Failed"] = "failed";
  JobStatus2["Cancelled"] = "cancelled";
  return JobStatus2;
})(JobStatus || {});
var ExecutionStatus = /* @__PURE__ */ ((ExecutionStatus3) => {
  ExecutionStatus3["QUEUED"] = "queued";
  ExecutionStatus3["RUNNING"] = "running";
  ExecutionStatus3["COMPLETED"] = "completed";
  ExecutionStatus3["FAILED"] = "failed";
  ExecutionStatus3["CANCELLED"] = "cancelled";
  ExecutionStatus3["PAUSED"] = "paused";
  return ExecutionStatus3;
})(ExecutionStatus || {});
var AlertStatus = /* @__PURE__ */ ((AlertStatus2) => {
  AlertStatus2["Unread"] = "unread";
  AlertStatus2["Read"] = "read";
  AlertStatus2["Deleted"] = "deleted";
  return AlertStatus2;
})(AlertStatus || {});
var SlackConnectionStatus = /* @__PURE__ */ ((SlackConnectionStatus3) => {
  SlackConnectionStatus3["Connected"] = "connected";
  SlackConnectionStatus3["Error"] = "error";
  SlackConnectionStatus3["Disconnected"] = "disconnected";
  return SlackConnectionStatus3;
})(SlackConnectionStatus || {});
var users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: varchar("username").notNull().unique(),
  email: varchar("email").notNull().unique(),
  password: varchar("password").notNull(),
  name: varchar("name"),
  image: varchar("image"),
  provider: text("provider"),
  provider_id: text("provider_id"),
  stripe_customer_id: text("stripe_customer_id"),
  stripe_subscription_id: text("stripe_subscription_id"),
  subscription_status: text("subscription_status"),
  subscription_tier: text("subscription_tier"),
  isAdmin: boolean("is_admin").default(false).notNull(),
  isActive: boolean("is_active").default(true).notNull(),
  lastLoginAt: timestamp("last_login_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});
var insertUserSchema = createInsertSchema(users);
var scrapingJobs = pgTable("scraping_jobs", {
  id: varchar("id").primaryKey().default(serial("id_auto").toString()),
  userId: integer("user_id").references(() => users.id).notNull(),
  name: varchar("name").notNull(),
  description: text("description"),
  type: varchar("type").notNull().$type(),
  config: jsonb("config").notNull(),
  status: varchar("status").notNull().$type(),
  schedule: varchar("schedule"),
  lastRunAt: timestamp("last_run_at"),
  lastCompletedAt: timestamp("last_completed_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});
var insertScrapingJobSchema = createInsertSchema(scrapingJobs);
var scrapingResults = pgTable("scraping_results", {
  id: serial("id").primaryKey(),
  jobId: varchar("job_id").references(() => scrapingJobs.id).notNull(),
  success: boolean("success").notNull(),
  data: jsonb("data"),
  error: text("error"),
  metadata: jsonb("metadata"),
  createdAt: timestamp("created_at").defaultNow().notNull()
}, (table) => {
  return {
    jobIdx: index("job_idx").on(table.jobId),
    createdAtIdx: index("created_at_idx").on(table.createdAt)
  };
});
var insertScrapingResultSchema = createInsertSchema(scrapingResults);
var changeDetectionMonitors = pgTable("change_detection_monitors", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  name: varchar("name").notNull(),
  url: varchar("url").notNull(),
  selectors: jsonb("selectors").notNull(),
  frequency: varchar("frequency").notNull(),
  // 'hourly', 'daily', 'weekly', etc.
  diffThreshold: real("diff_threshold").default(0.05).notNull(),
  ignoredSelectors: jsonb("ignored_selectors"),
  baselineContent: jsonb("baseline_content"),
  lastCheckedAt: timestamp("last_checked_at"),
  lastChangedAt: timestamp("last_changed_at"),
  isActive: boolean("is_active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});
var insertChangeDetectionMonitorSchema = createInsertSchema(changeDetectionMonitors);
var changeDetectionAlerts = pgTable("change_detection_alerts", {
  id: serial("id").primaryKey(),
  monitorId: integer("monitor_id").references(() => changeDetectionMonitors.id).notNull(),
  previousContent: jsonb("previous_content"),
  currentContent: jsonb("current_content").notNull(),
  diffPct: real("diff_pct").notNull(),
  diffDetails: jsonb("diff_details"),
  status: varchar("status").notNull().$type().default("unread" /* Unread */),
  readAt: timestamp("read_at"),
  createdAt: timestamp("created_at").defaultNow().notNull()
}, (table) => {
  return {
    monitorIdx: index("monitor_idx").on(table.monitorId),
    statusIdx: index("status_idx").on(table.status),
    createdAtIdx: index("alert_created_at_idx").on(table.createdAt)
  };
});
var insertChangeDetectionAlertSchema = createInsertSchema(changeDetectionAlerts);
var scrapingTemplates = pgTable("scraping_templates", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  name: varchar("name").notNull(),
  description: text("description"),
  type: varchar("type").notNull().$type(),
  config: jsonb("config").notNull(),
  isPublic: boolean("is_public").default(false).notNull(),
  tags: jsonb("tags"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
});
var insertScrapingTemplateSchema = createInsertSchema(scrapingTemplates);
var socialConnectors = pgTable("social_connectors", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  name: varchar("name").notNull(),
  platform: varchar("platform").notNull(),
  credentials: jsonb("credentials").notNull(),
  isActive: boolean("is_active").default(true).notNull(),
  metadata: jsonb("metadata").default({}).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("social_user_id_idx").on(table.userId),
    platformIdx: index("social_platform_idx").on(table.platform),
    activeIdx: index("social_active_idx").on(table.isActive)
  };
});
var insertSocialConnectorSchema = createInsertSchema(socialConnectors);
var socialMonitors = pgTable("social_monitors", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  connectorId: integer("connector_id").references(() => socialConnectors.id).notNull(),
  name: varchar("name").notNull(),
  type: varchar("type").notNull(),
  // 'keyword', 'user', 'hashtag', etc.
  query: jsonb("query").notNull(),
  // Search parameters
  frequency: varchar("frequency").notNull(),
  // 'realtime', 'hourly', 'daily', etc.
  status: varchar("status").default("active").notNull(),
  lastRunAt: timestamp("last_run_at"),
  metadata: jsonb("metadata").default({}).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("social_monitor_user_id_idx").on(table.userId),
    connectorIdIdx: index("social_monitor_connector_id_idx").on(table.connectorId),
    statusIdx: index("social_monitor_status_idx").on(table.status)
  };
});
var insertSocialMonitorSchema = createInsertSchema(socialMonitors);
var monitorResults = pgTable("monitor_results", {
  id: serial("id").primaryKey(),
  monitorId: integer("monitor_id").references(() => socialMonitors.id).notNull(),
  postId: varchar("post_id").notNull(),
  platform: varchar("platform").notNull(),
  content: jsonb("content").notNull(),
  author: varchar("author").notNull(),
  publishedAt: timestamp("published_at"),
  sentiment: real("sentiment"),
  engagement: jsonb("engagement"),
  // likes, shares, comments, etc.
  metadata: jsonb("metadata").default({}).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull()
}, (table) => {
  return {
    monitorIdIdx: index("monitor_result_monitor_id_idx").on(table.monitorId),
    postIdIdx: index("monitor_result_post_id_idx").on(table.postId),
    authorIdx: index("monitor_result_author_idx").on(table.author),
    publishedAtIdx: index("monitor_result_published_at_idx").on(table.publishedAt)
  };
});
var insertMonitorResultSchema = createInsertSchema(monitorResults);
var socialAlerts = pgTable("social_alerts", {
  id: serial("id").primaryKey(),
  monitorId: integer("monitor_id").references(() => socialMonitors.id).notNull(),
  resultId: integer("result_id").references(() => monitorResults.id),
  type: varchar("type").notNull(),
  // 'keyword_match', 'sentiment_drop', 'engagement_spike', etc.
  title: varchar("title").notNull(),
  description: text("description"),
  severity: varchar("severity").notNull(),
  // 'low', 'medium', 'high', 'critical'
  status: varchar("status").default("unread").notNull(),
  readAt: timestamp("read_at"),
  metadata: jsonb("metadata").default({}).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull()
}, (table) => {
  return {
    monitorIdIdx: index("social_alert_monitor_id_idx").on(table.monitorId),
    resultIdIdx: index("social_alert_result_id_idx").on(table.resultId),
    statusIdx: index("social_alert_status_idx").on(table.status),
    severityIdx: index("social_alert_severity_idx").on(table.severity),
    createdAtIdx: index("social_alert_created_at_idx").on(table.createdAt)
  };
});
var insertSocialAlertSchema = createInsertSchema(socialAlerts);
var LogLevel = /* @__PURE__ */ ((LogLevel3) => {
  LogLevel3["Debug"] = "debug";
  LogLevel3["Info"] = "info";
  LogLevel3["Warning"] = "warning";
  LogLevel3["Error"] = "error";
  return LogLevel3;
})(LogLevel || {});
var EntityType = /* @__PURE__ */ ((EntityType2) => {
  EntityType2["User"] = "user";
  EntityType2["Workflow"] = "workflow";
  EntityType2["Agent"] = "agent";
  EntityType2["ScrapingJob"] = "scraping_job";
  EntityType2["Monitor"] = "monitor";
  EntityType2["System"] = "system";
  return EntityType2;
})(EntityType || {});
var workflows = pgTable("workflows", {
  id: serial("id").primaryKey(),
  ownerId: integer("owner_id").references(() => users.id).notNull(),
  name: varchar("name").notNull(),
  description: text("description"),
  data: jsonb("data").notNull(),
  // JSON representation of the workflow
  isPublic: boolean("is_public").default(false).notNull(),
  isTemplate: boolean("is_template").default(false).notNull(),
  tags: jsonb("tags"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    ownerIdIdx: index("workflow_owner_id_idx").on(table.ownerId),
    publicIdx: index("workflow_public_idx").on(table.isPublic),
    templateIdx: index("workflow_template_idx").on(table.isTemplate)
  };
});
var insertWorkflowSchema2 = createInsertSchema(workflows, {
  data: z.object({
    nodes: z.array(z.any()),
    edges: z.array(z.any())
  }).or(z.string()),
  tags: z.array(z.string()).optional().nullable()
});
var NodePosition = /* @__PURE__ */ ((NodePosition2) => {
  NodePosition2["Left"] = "left";
  NodePosition2["Right"] = "right";
  NodePosition2["Top"] = "top";
  NodePosition2["Bottom"] = "bottom";
  return NodePosition2;
})(NodePosition || {});
var workflowDataSchema = z.object({
  nodes: z.array(z.object({
    id: z.string(),
    type: z.string(),
    position: z.object({
      x: z.number(),
      y: z.number()
    }),
    data: z.any(),
    selected: z.boolean().optional(),
    dragging: z.boolean().optional(),
    sourcePosition: z.union([z.nativeEnum(NodePosition), z.string()]).optional(),
    targetPosition: z.union([z.nativeEnum(NodePosition), z.string()]).optional(),
    width: z.number().optional(),
    height: z.number().optional()
  })).default([]),
  edges: z.array(z.object({
    id: z.string(),
    source: z.string(),
    target: z.string(),
    sourceHandle: z.union([z.string(), z.null()]).optional(),
    targetHandle: z.union([z.string(), z.null()]).optional(),
    animated: z.boolean().optional(),
    label: z.string().optional(),
    selected: z.boolean().optional(),
    type: z.string().optional()
  })).default([])
});
var workflowExecutions = pgTable("workflow_executions", {
  id: serial("id").primaryKey(),
  workflowId: integer("workflow_id").references(() => workflows.id).notNull(),
  triggeredById: integer("triggered_by_id").references(() => users.id).notNull(),
  status: varchar("status").$type().notNull(),
  startedAt: timestamp("started_at").notNull(),
  completedAt: timestamp("completed_at"),
  progress: integer("progress").default(0).notNull(),
  result: jsonb("result"),
  error: text("error"),
  metadata: jsonb("metadata").default({}),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    workflowIdIdx: index("workflow_execution_workflow_id_idx").on(table.workflowId),
    triggeredByIdx: index("workflow_execution_triggered_by_idx").on(table.triggeredById),
    statusIdx: index("workflow_execution_status_idx").on(table.status),
    startedAtIdx: index("workflow_execution_started_at_idx").on(table.startedAt)
  };
});
var insertWorkflowExecutionSchema = createInsertSchema(workflowExecutions);
var executionLogs = pgTable("execution_logs", {
  id: serial("id").primaryKey(),
  executionId: integer("execution_id").references(() => workflowExecutions.id).notNull(),
  timestamp: timestamp("timestamp").notNull(),
  level: varchar("level").notNull(),
  // 'debug', 'info', 'warning', 'error'
  message: text("message").notNull(),
  source: varchar("source")
  // Node ID or component that generated the log
}, (table) => {
  return {
    executionIdIdx: index("execution_log_execution_id_idx").on(table.executionId),
    timestampIdx: index("execution_log_timestamp_idx").on(table.timestamp),
    levelIdx: index("execution_log_level_idx").on(table.level)
  };
});
var insertExecutionLogSchema = createInsertSchema(executionLogs);
var nodeExecutions = pgTable("node_executions", {
  id: serial("id").primaryKey(),
  executionId: integer("execution_id").references(() => workflowExecutions.id).notNull(),
  nodeId: varchar("node_id").notNull(),
  // ID of the node in the workflow definition
  status: varchar("status").$type().notNull(),
  startedAt: timestamp("started_at").notNull(),
  completedAt: timestamp("completed_at"),
  input: jsonb("input"),
  output: jsonb("output"),
  error: text("error")
}, (table) => {
  return {
    executionIdIdx: index("node_execution_execution_id_idx").on(table.executionId),
    nodeIdIdx: index("node_execution_node_id_idx").on(table.nodeId),
    statusIdx: index("node_execution_status_idx").on(table.status)
  };
});
var insertNodeExecutionSchema = createInsertSchema(nodeExecutions);
var activityLogs = pgTable("activity_logs", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id),
  level: varchar("level").notNull().$type(),
  action: varchar("action").notNull(),
  entityType: varchar("entity_type").$type(),
  entityId: varchar("entity_id"),
  details: jsonb("details"),
  ipAddress: varchar("ip_address"),
  userAgent: varchar("user_agent"),
  timestamp: timestamp("timestamp").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("activity_log_user_id_idx").on(table.userId),
    levelIdx: index("activity_log_level_idx").on(table.level),
    actionIdx: index("activity_log_action_idx").on(table.action),
    entityTypeIdx: index("activity_log_entity_type_idx").on(table.entityType),
    timestampIdx: index("activity_log_timestamp_idx").on(table.timestamp)
  };
});
var insertActivityLogSchema = createInsertSchema(activityLogs);
var userPreferences = pgTable("user_preferences", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  theme: varchar("theme").default("system"),
  uiDensity: varchar("ui_density").default("comfortable"),
  timezone: varchar("timezone"),
  dateFormat: varchar("date_format"),
  defaultLanguage: varchar("default_language").default("en"),
  aiSettings: jsonb("ai_settings").default({}),
  notificationSettings: jsonb("notification_settings").default({}),
  customization: jsonb("customization").default({}),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("user_preferences_user_id_idx").on(table.userId)
  };
});
var insertUserPreferenceSchema = createInsertSchema(userPreferences);
var MemoryType = /* @__PURE__ */ ((MemoryType2) => {
  MemoryType2["Context7"] = "context7";
  MemoryType2["Mem0"] = "mem0";
  MemoryType2["Graphiti"] = "graphiti";
  MemoryType2["Zep"] = "zep";
  MemoryType2["LlamaIndex"] = "llamaindex";
  MemoryType2["Custom"] = "custom";
  return MemoryType2;
})(MemoryType || {});
var memorySystems = pgTable("memory_systems", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  name: varchar("name").notNull(),
  type: varchar("type").$type().notNull(),
  description: text("description"),
  config: jsonb("config").notNull(),
  isActive: boolean("is_active").default(true).notNull(),
  isDefault: boolean("is_default").default(false),
  metrics: jsonb("metrics").default({}),
  // Performance metrics
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("memory_user_id_idx").on(table.userId),
    typeIdx: index("memory_type_idx").on(table.type),
    activeIdx: index("memory_active_idx").on(table.isActive),
    defaultIdx: index("memory_default_idx").on(table.isDefault)
  };
});
var insertMemorySystemSchema = createInsertSchema(memorySystems);
var memoryEntries = pgTable("memory_entries", {
  id: serial("id").primaryKey(),
  systemId: integer("system_id").references(() => memorySystems.id).notNull(),
  entryKey: varchar("entry_key").notNull(),
  // Unique identifier for the memory
  content: text("content").notNull(),
  metadata: jsonb("metadata").default({}),
  importance: real("importance").default(0.5),
  // How important this memory is
  lastAccessed: timestamp("last_accessed"),
  accessCount: integer("access_count").default(0),
  embeddingId: integer("embedding_id"),
  // Will be set up with a deferred constraint after vectorItems is defined
  expires: timestamp("expires"),
  // When this memory should expire
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    systemIdIdx: index("memory_entry_system_id_idx").on(table.systemId),
    entryKeyIdx: index("memory_entry_key_idx").on(table.entryKey),
    importanceIdx: index("memory_importance_idx").on(table.importance),
    lastAccessedIdx: index("memory_last_accessed_idx").on(table.lastAccessed)
  };
});
var insertMemoryEntrySchema = createInsertSchema(memoryEntries);
var knowledgeGraphNodes = pgTable("knowledge_graph_nodes", {
  id: serial("id").primaryKey(),
  systemId: integer("system_id").references(() => memorySystems.id).notNull(),
  nodeType: varchar("node_type").notNull(),
  // 'entity', 'concept', 'fact', etc.
  label: varchar("label").notNull(),
  properties: jsonb("properties").default({}),
  embedding: jsonb("embedding"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    systemIdIdx: index("graph_node_system_id_idx").on(table.systemId),
    nodeTypeIdx: index("graph_node_type_idx").on(table.nodeType),
    labelIdx: index("graph_node_label_idx").on(table.label)
  };
});
var insertKnowledgeGraphNodeSchema = createInsertSchema(knowledgeGraphNodes);
var knowledgeGraphEdges = pgTable("knowledge_graph_edges", {
  id: serial("id").primaryKey(),
  systemId: integer("system_id").references(() => memorySystems.id).notNull(),
  sourceId: integer("source_id").references(() => knowledgeGraphNodes.id).notNull(),
  targetId: integer("target_id").references(() => knowledgeGraphNodes.id).notNull(),
  relationship: varchar("relationship").notNull(),
  weight: real("weight").default(1),
  properties: jsonb("properties").default({}),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    systemIdIdx: index("graph_edge_system_id_idx").on(table.systemId),
    sourceIdIdx: index("graph_edge_source_id_idx").on(table.sourceId),
    targetIdIdx: index("graph_edge_target_id_idx").on(table.targetId),
    relationshipIdx: index("graph_edge_relationship_idx").on(table.relationship)
  };
});
var insertKnowledgeGraphEdgeSchema = createInsertSchema(knowledgeGraphEdges);
var RagType = /* @__PURE__ */ ((RagType2) => {
  RagType2["LightRAG"] = "light_rag";
  RagType2["PineconeRAG"] = "pinecone_rag";
  RagType2["QdrantRAG"] = "qdrant_rag";
  RagType2["ChromaRAG"] = "chroma_rag";
  RagType2["PgVectorRAG"] = "pgvector_rag";
  RagType2["SemanticRAG"] = "semantic_rag";
  RagType2["HybridRAG"] = "hybrid_rag";
  RagType2["CodeRAG"] = "code_rag";
  RagType2["LegalRAG"] = "legal_rag";
  RagType2["LlamaIndexRAG"] = "llamaindex_rag";
  RagType2["MultimodalRAG"] = "multimodal_rag";
  RagType2["Custom"] = "custom";
  return RagType2;
})(RagType || {});
var ragSystems = pgTable("rag_systems", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  name: varchar("name").notNull(),
  type: varchar("type").$type().notNull(),
  description: text("description"),
  config: jsonb("config").notNull(),
  vectorDbId: integer("vector_db_id").references(() => vectorDatabases.id),
  memorySystemId: integer("memory_system_id").references(() => memorySystems.id),
  isActive: boolean("is_active").default(true).notNull(),
  metrics: jsonb("metrics").default({}),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("rag_user_id_idx").on(table.userId),
    typeIdx: index("rag_type_idx").on(table.type),
    activeIdx: index("rag_active_idx").on(table.isActive)
  };
});
var insertRagSystemSchema = createInsertSchema(ragSystems);
var VectorDbType = /* @__PURE__ */ ((VectorDbType3) => {
  VectorDbType3["PgVector"] = "pgvector";
  VectorDbType3["Milvus"] = "milvus";
  VectorDbType3["Qdrant"] = "qdrant";
  VectorDbType3["Weaviate"] = "weaviate";
  VectorDbType3["External"] = "external";
  return VectorDbType3;
})(VectorDbType || {});
var vectorDatabases = pgTable("vector_databases", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  name: varchar("name").notNull(),
  type: varchar("type").$type().notNull(),
  description: text("description"),
  config: jsonb("config").notNull(),
  // connection details, etc.
  isActive: boolean("is_active").default(true).notNull(),
  isDefault: boolean("is_default").default(false),
  dimensions: integer("dimensions").default(1536),
  // embedding dimensions
  metrics: jsonb("metrics").default({}),
  // Performance metrics
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("vector_db_user_id_idx").on(table.userId),
    typeIdx: index("vector_db_type_idx").on(table.type),
    activeIdx: index("vector_db_active_idx").on(table.isActive),
    defaultIdx: index("vector_db_default_idx").on(table.isDefault)
  };
});
var insertVectorDatabaseSchema = createInsertSchema(vectorDatabases);
var vectorCollections = pgTable("vector_collections", {
  id: serial("id").primaryKey(),
  dbId: integer("db_id").references(() => vectorDatabases.id).notNull(),
  name: varchar("name").notNull(),
  description: text("description"),
  metadata: jsonb("metadata").default({}),
  itemCount: integer("item_count").default(0),
  dimensions: integer("dimensions"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    dbIdIdx: index("vector_collection_db_id_idx").on(table.dbId),
    nameIdx: index("vector_collection_name_idx").on(table.name)
  };
});
var insertVectorCollectionSchema = createInsertSchema(vectorCollections);
var vectorItems = pgTable("vector_items", {
  id: serial("id").primaryKey(),
  collectionId: integer("collection_id").references(() => vectorCollections.id).notNull(),
  objectId: varchar("object_id").notNull(),
  objectType: varchar("object_type").notNull(),
  embedding: jsonb("embedding").notNull(),
  // Will be replaced with pgvector column
  metadata: jsonb("metadata").default({}),
  content: text("content"),
  title: varchar("title"),
  chunkSize: integer("chunk_size"),
  chunkOverlap: integer("chunk_overlap"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    collectionIdIdx: index("vector_item_collection_id_idx").on(table.collectionId),
    objectIdIdx: index("vector_item_object_id_idx").on(table.objectId),
    objectTypeIdx: index("vector_item_object_type_idx").on(table.objectType),
    titleIdx: index("vector_item_title_idx").on(table.title),
    // Will be replaced with pgvector index
    embeddingIdx: index("vector_item_embedding_idx").on(table.embedding)
  };
});
var insertVectorItemSchema = createInsertSchema(vectorItems);
var savedSearches = pgTable("saved_searches", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  name: varchar("name").notNull(),
  query: text("query").notNull(),
  filters: jsonb("filters").default({}),
  entityType: varchar("entity_type").notNull(),
  // 'workflow', 'agent', 'job', etc.
  isFavorite: boolean("is_favorite").default(false),
  lastRun: timestamp("last_run"),
  resultCount: integer("result_count"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("saved_search_user_id_idx").on(table.userId),
    entityTypeIdx: index("saved_search_entity_type_idx").on(table.entityType)
  };
});
var insertSavedSearchSchema = createInsertSchema(savedSearches);
var slackConfigs = pgTable("slack_configs", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  botToken: varchar("bot_token").notNull(),
  channelId: varchar("channel_id"),
  defaultChannelId: varchar("default_channel_id"),
  // Add default channel ID
  teamId: varchar("team_id"),
  workspaceName: varchar("workspace_name"),
  connectionStatus: varchar("connection_status").$type().default("disconnected" /* Disconnected */),
  lastConnectionError: text("last_connection_error"),
  lastConnectedAt: timestamp("last_connected_at"),
  isActive: boolean("is_active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("slack_config_user_id_idx").on(table.userId),
    isActiveIdx: index("slack_config_is_active_idx").on(table.isActive),
    connectionStatusIdx: index("slack_config_conn_status_idx").on(table.connectionStatus)
  };
});
var insertSlackConfigSchema = createInsertSchema(slackConfigs, {
  botToken: z.string().min(1, "Bot token is required")
});
var slackChannels = pgTable("slack_channels", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  configId: integer("config_id").references(() => slackConfigs.id).notNull(),
  channelId: varchar("channel_id").notNull(),
  name: varchar("name").notNull(),
  isPrivate: boolean("is_private").default(false),
  lastSyncedAt: timestamp("last_synced_at"),
  createdAt: timestamp("created_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("slack_channel_user_id_idx").on(table.userId),
    configIdIdx: index("slack_channel_config_id_idx").on(table.configId),
    channelIdIdx: index("slack_channel_id_idx").on(table.channelId)
  };
});
var insertSlackChannelSchema = createInsertSchema(slackChannels);
var slackMessages = pgTable("slack_messages", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  channelId: integer("channel_id").references(() => slackChannels.id).notNull(),
  messageId: varchar("message_id").notNull(),
  // The Slack 'ts' identifier
  text: text("text"),
  sender: varchar("sender"),
  senderName: varchar("sender_name"),
  attachments: jsonb("attachments"),
  reactions: jsonb("reactions"),
  threadTs: varchar("thread_ts"),
  // Parent thread ts
  postedAt: timestamp("posted_at").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("slack_message_user_id_idx").on(table.userId),
    channelIdIdx: index("slack_message_channel_id_idx").on(table.channelId),
    messageIdIdx: index("slack_message_id_idx").on(table.messageId),
    postedAtIdx: index("slack_message_posted_at_idx").on(table.postedAt)
  };
});
var insertSlackMessageSchema = createInsertSchema(slackMessages);
var SlackWebhookEventType = /* @__PURE__ */ ((SlackWebhookEventType3) => {
  SlackWebhookEventType3["Message"] = "message";
  SlackWebhookEventType3["ChannelCreated"] = "channel_created";
  SlackWebhookEventType3["ChannelArchived"] = "channel_archived";
  SlackWebhookEventType3["ChannelUnarchived"] = "channel_unarchived";
  SlackWebhookEventType3["MemberJoined"] = "member_joined_channel";
  SlackWebhookEventType3["MemberLeft"] = "member_left_channel";
  SlackWebhookEventType3["AppMention"] = "app_mention";
  SlackWebhookEventType3["Other"] = "other";
  return SlackWebhookEventType3;
})(SlackWebhookEventType || {});
var slackWebhooks = pgTable("slack_webhooks", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  configId: integer("config_id").references(() => slackConfigs.id).notNull(),
  webhookUrl: varchar("webhook_url").notNull(),
  description: text("description"),
  events: jsonb("events").$type().notNull(),
  isActive: boolean("is_active").default(true).notNull(),
  lastTriggeredAt: timestamp("last_triggered_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("slack_webhook_user_id_idx").on(table.userId),
    configIdIdx: index("slack_webhook_config_id_idx").on(table.configId),
    isActiveIdx: index("slack_webhook_is_active_idx").on(table.isActive)
  };
});
var insertSlackWebhookSchema = createInsertSchema(slackWebhooks, {
  events: z.array(z.nativeEnum(SlackWebhookEventType))
});
var OAuthConnectionStatus = /* @__PURE__ */ ((OAuthConnectionStatus3) => {
  OAuthConnectionStatus3["Connected"] = "connected";
  OAuthConnectionStatus3["Error"] = "error";
  OAuthConnectionStatus3["Disconnected"] = "disconnected";
  OAuthConnectionStatus3["Expired"] = "expired";
  return OAuthConnectionStatus3;
})(OAuthConnectionStatus || {});
var oauthConnections = pgTable("oauth_connections", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  provider: varchar("provider").notNull(),
  connectionId: varchar("connection_id").notNull(),
  nangoConnectionId: varchar("nango_connection_id").notNull(),
  connectionStatus: varchar("connection_status").$type().default("disconnected" /* Disconnected */).notNull(),
  metadata: jsonb("metadata"),
  tokenData: jsonb("token_data"),
  lastError: text("last_error"),
  lastConnectedAt: timestamp("last_connected_at"),
  expiresAt: timestamp("expires_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("oauth_user_id_idx").on(table.userId),
    providerIdx: index("oauth_provider_idx").on(table.provider),
    connectionIdIdx: index("oauth_connection_id_idx").on(table.connectionId),
    statusIdx: index("oauth_status_idx").on(table.connectionStatus)
  };
});
var insertOAuthConnectionSchema = createInsertSchema(oauthConnections);
var airbyteSources = pgTable("airbyte_sources", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  sourceId: varchar("source_id").notNull(),
  // External Airbyte source ID
  sourceDefinitionId: varchar("source_definition_id").notNull(),
  // Reference to Airbyte source type
  name: varchar("name").notNull(),
  connectionConfiguration: jsonb("connection_configuration").notNull(),
  workspaceId: varchar("workspace_id").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("airbyte_source_user_id_idx").on(table.userId),
    sourceIdIdx: index("airbyte_source_id_idx").on(table.sourceId),
    nameIdx: index("airbyte_source_name_idx").on(table.name)
  };
});
var insertAirbyteSourceSchema = createInsertSchema(airbyteSources);
var airbyteDestinations = pgTable("airbyte_destinations", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  destinationId: varchar("destination_id").notNull(),
  // External Airbyte destination ID
  destinationDefinitionId: varchar("destination_definition_id").notNull(),
  // Reference to Airbyte destination type
  name: varchar("name").notNull(),
  connectionConfiguration: jsonb("connection_configuration").notNull(),
  workspaceId: varchar("workspace_id").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("airbyte_destination_user_id_idx").on(table.userId),
    destinationIdIdx: index("airbyte_destination_id_idx").on(table.destinationId),
    nameIdx: index("airbyte_destination_name_idx").on(table.name)
  };
});
var insertAirbyteDestinationSchema = createInsertSchema(airbyteDestinations);
var airbyteConnections = pgTable("airbyte_connections", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  connectionId: varchar("connection_id").notNull(),
  // External Airbyte connection ID
  sourceId: integer("source_id").references(() => airbyteSources.id).notNull(),
  destinationId: integer("destination_id").references(() => airbyteDestinations.id).notNull(),
  name: varchar("name").notNull(),
  namespaceDefinition: varchar("namespace_definition").default("source"),
  namespaceFormat: varchar("namespace_format").default("${SOURCE_NAMESPACE}"),
  prefix: varchar("prefix"),
  syncCatalog: jsonb("sync_catalog").notNull(),
  schedule: jsonb("schedule"),
  status: varchar("status").$type().default("active" /* Active */).notNull(),
  resourceRequirements: jsonb("resource_requirements"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("airbyte_connection_user_id_idx").on(table.userId),
    connectionIdIdx: index("airbyte_connection_id_idx").on(table.connectionId),
    sourceIdIdx: index("airbyte_connection_source_id_idx").on(table.sourceId),
    destinationIdIdx: index("airbyte_connection_destination_id_idx").on(table.destinationId),
    statusIdx: index("airbyte_connection_status_idx").on(table.status)
  };
});
var insertAirbyteConnectionSchema = createInsertSchema(airbyteConnections);
var airbyteSyncJobs = pgTable("airbyte_sync_jobs", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  connectionId: integer("connection_id").references(() => airbyteConnections.id).notNull(),
  jobId: varchar("job_id"),
  // External Airbyte job ID
  status: varchar("status").$type().default("pending" /* Pending */).notNull(),
  startTime: timestamp("start_time"),
  endTime: timestamp("end_time"),
  bytesSynced: integer("bytes_synced"),
  recordsSynced: integer("records_synced"),
  logUrl: varchar("log_url"),
  error: jsonb("error"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("airbyte_sync_job_user_id_idx").on(table.userId),
    connectionIdIdx: index("airbyte_sync_job_connection_id_idx").on(table.connectionId),
    jobIdIdx: index("airbyte_sync_job_id_idx").on(table.jobId),
    statusIdx: index("airbyte_sync_job_status_idx").on(table.status)
  };
});
var insertAirbyteSyncJobSchema = createInsertSchema(airbyteSyncJobs);
var airbyteConfigs = pgTable("airbyte_configs", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  configJson: text("config_json").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("airbyte_config_user_id_idx").on(table.userId)
  };
});
var insertAirbyteConfigSchema = createInsertSchema(airbyteConfigs);
var ComposioWorkflowStatusType = /* @__PURE__ */ ((ComposioWorkflowStatusType3) => {
  ComposioWorkflowStatusType3["ACTIVE"] = "active";
  ComposioWorkflowStatusType3["INACTIVE"] = "inactive";
  ComposioWorkflowStatusType3["DRAFT"] = "draft";
  return ComposioWorkflowStatusType3;
})(ComposioWorkflowStatusType || {});
var ComposioExecutionStatusType = /* @__PURE__ */ ((ComposioExecutionStatusType3) => {
  ComposioExecutionStatusType3["PENDING"] = "pending";
  ComposioExecutionStatusType3["RUNNING"] = "running";
  ComposioExecutionStatusType3["COMPLETED"] = "completed";
  ComposioExecutionStatusType3["FAILED"] = "failed";
  return ComposioExecutionStatusType3;
})(ComposioExecutionStatusType || {});
var composioConfigs = pgTable("composio_configs", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  configJson: text("config_json").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("composio_config_user_id_idx").on(table.userId)
  };
});
var insertComposioConfigSchema = createInsertSchema(composioConfigs);
var composioWorkflows = pgTable("composio_workflows", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  workflowId: varchar("workflow_id").notNull(),
  // External Composio workflow ID
  name: varchar("name").notNull(),
  description: text("description"),
  version: integer("version").default(1).notNull(),
  status: varchar("status").$type().default("draft" /* DRAFT */).notNull(),
  definition: jsonb("definition").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("composio_workflow_user_id_idx").on(table.userId),
    workflowIdIdx: index("composio_workflow_id_idx").on(table.workflowId),
    nameIdx: index("composio_workflow_name_idx").on(table.name),
    statusIdx: index("composio_workflow_status_idx").on(table.status)
  };
});
var insertComposioWorkflowSchema = createInsertSchema(composioWorkflows, {
  status: z.nativeEnum(ComposioWorkflowStatusType)
});
var composioTriggers = pgTable("composio_triggers", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  workflowId: integer("workflow_id").references(() => composioWorkflows.id).notNull(),
  triggerId: varchar("trigger_id").notNull(),
  // External Composio trigger ID
  name: varchar("name").notNull(),
  triggerType: varchar("trigger_type").notNull(),
  configuration: jsonb("configuration").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("composio_trigger_user_id_idx").on(table.userId),
    workflowIdIdx: index("composio_trigger_workflow_id_idx").on(table.workflowId),
    triggerIdIdx: index("composio_trigger_id_idx").on(table.triggerId),
    triggerTypeIdx: index("composio_trigger_type_idx").on(table.triggerType)
  };
});
var insertComposioTriggerSchema = createInsertSchema(composioTriggers);
var composioActions = pgTable("composio_actions", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  workflowId: integer("workflow_id").references(() => composioWorkflows.id).notNull(),
  actionId: varchar("action_id").notNull(),
  // External Composio action ID
  name: varchar("name").notNull(),
  actionType: varchar("action_type").notNull(),
  configuration: jsonb("configuration").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("composio_action_user_id_idx").on(table.userId),
    workflowIdIdx: index("composio_action_workflow_id_idx").on(table.workflowId),
    actionIdIdx: index("composio_action_id_idx").on(table.actionId),
    actionTypeIdx: index("composio_action_type_idx").on(table.actionType)
  };
});
var insertComposioActionSchema = createInsertSchema(composioActions);
var composioExecutions = pgTable("composio_executions", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  workflowId: integer("workflow_id").references(() => composioWorkflows.id).notNull(),
  triggerId: integer("trigger_id").references(() => composioTriggers.id),
  executionId: varchar("execution_id").notNull(),
  // External Composio execution ID
  status: varchar("status").$type().default("pending" /* PENDING */).notNull(),
  startTime: timestamp("start_time").notNull(),
  endTime: timestamp("end_time"),
  input: jsonb("input"),
  output: jsonb("output"),
  error: text("error"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull()
}, (table) => {
  return {
    userIdIdx: index("composio_execution_user_id_idx").on(table.userId),
    workflowIdIdx: index("composio_execution_workflow_id_idx").on(table.workflowId),
    triggerIdIdx: index("composio_execution_trigger_id_idx").on(table.triggerId),
    executionIdIdx: index("composio_execution_id_idx").on(table.executionId),
    statusIdx: index("composio_execution_status_idx").on(table.status)
  };
});
var insertComposioExecutionSchema = createInsertSchema(composioExecutions, {
  status: z.nativeEnum(ComposioExecutionStatusType)
});

// server/db.ts
import { Pool, neonConfig } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-serverless";
import ws from "ws";
neonConfig.webSocketConstructor = ws;
if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL must be set. Did you forget to provision a database?");
}
var pool = new Pool({ connectionString: process.env.DATABASE_URL });
var db = drizzle(pool, { schema: schema_exports });

// server/storage.ts
import { eq, and, desc, like, gte, lte, sql, lt, gt } from "drizzle-orm";
var DatabaseStorage = class {
  // User methods
  async getUser(id) {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }
  async getUserByUsername(username) {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user;
  }
  async getUserByEmail(email) {
    const [user] = await db.select().from(users).where(eq(users.email, email));
    return user;
  }
  async createUser(user) {
    const [newUser] = await db.insert(users).values(user).returning();
    return newUser;
  }
  async updateUser(id, userData) {
    const [user] = await db.update(users).set({
      ...userData,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq(users.id, id)).returning();
    return user;
  }
  // Social monitoring methods
  async getSocialMonitorsByUser(userId) {
    try {
      return await db.select().from(socialMonitors).where(eq(socialMonitors.userId, userId)).orderBy(desc(socialMonitors.createdAt));
    } catch (error) {
      console.error("Error fetching social monitors for user:", error);
      return [];
    }
  }
  async createSocialMonitor(monitorData) {
    try {
      const dbMonitor = {
        userId: monitorData.userId,
        name: monitorData.name,
        // Map from service format to schema format
        type: "keyword",
        // Default type
        connectorId: 1,
        // Default connector
        // Convert keywords or platforms to JSON query format
        query: monitorData.query || { keywords: [], platforms: [] },
        frequency: monitorData.frequency?.toString() || "hourly",
        status: "active",
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      };
      const [newMonitor] = await db.insert(socialMonitors).values(dbMonitor).returning();
      return newMonitor;
    } catch (error) {
      console.error("Error creating social monitor:", error);
      throw error;
    }
  }
  // Workflow methods
  async getWorkflow(id) {
    try {
      const [workflow] = await db.select().from(workflows).where(eq(workflows.id, id));
      return workflow;
    } catch (error) {
      console.error("Error fetching workflow:", error);
      return void 0;
    }
  }
  async getWorkflowsByUser(userId) {
    try {
      return await db.select().from(workflows).where(eq(workflows.ownerId, userId)).orderBy(desc(workflows.updatedAt));
    } catch (error) {
      console.error("Error fetching workflows for user:", error);
      return [];
    }
  }
  async createWorkflow(workflowData) {
    try {
      const [newWorkflow] = await db.insert(workflows).values({
        ...workflowData,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      return newWorkflow;
    } catch (error) {
      console.error("Error creating workflow:", error);
      throw error;
    }
  }
  async updateWorkflow(id, workflowData) {
    try {
      const [updatedWorkflow] = await db.update(workflows).set({
        ...workflowData,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq(workflows.id, id)).returning();
      return updatedWorkflow;
    } catch (error) {
      console.error("Error updating workflow:", error);
      return void 0;
    }
  }
  async deleteWorkflow(id) {
    try {
      const result2 = await db.delete(workflows).where(eq(workflows.id, id));
      return true;
    } catch (error) {
      console.error("Error deleting workflow:", error);
      return false;
    }
  }
  // Workflow Execution methods
  async getWorkflowExecution(id) {
    try {
      const [execution] = await db.select().from(workflowExecutions).where(eq(workflowExecutions.id, id));
      return execution;
    } catch (error) {
      console.error("Error fetching workflow execution:", error);
      return void 0;
    }
  }
  async getWorkflowExecutionsByWorkflow(workflowId) {
    try {
      return await db.select().from(workflowExecutions).where(eq(workflowExecutions.workflowId, workflowId)).orderBy(desc(workflowExecutions.startedAt));
    } catch (error) {
      console.error("Error fetching executions for workflow:", error);
      return [];
    }
  }
  async getWorkflowExecutionsByUser(userId, options2 = {}) {
    try {
      const { limit = 10, offset = 0, status, search, fromDate, toDate } = options2;
      let query2 = db.select({
        execution: workflowExecutions,
        workflowName: workflows.name
      }).from(workflowExecutions).innerJoin(workflows, eq(workflowExecutions.workflowId, workflows.id)).where(eq(workflows.ownerId, userId));
      if (status) {
        query2 = query2.where(eq(workflowExecutions.status, status));
      }
      if (search && search.trim() !== "") {
        query2 = query2.where(like(workflows.name, `%${search}%`));
      }
      if (fromDate) {
        query2 = query2.where(gte(workflowExecutions.startedAt, fromDate));
      }
      if (toDate) {
        query2 = query2.where(lte(workflowExecutions.startedAt, toDate));
      }
      const results = await query2.orderBy(desc(workflowExecutions.startedAt)).limit(limit).offset(offset);
      return results.map((result2) => result2.execution);
    } catch (error) {
      console.error("Error fetching executions by user:", error);
      return [];
    }
  }
  async countWorkflowExecutionsByUser(userId, options2 = {}) {
    try {
      const { status, search, fromDate, toDate } = options2;
      let query2 = db.select({ count: sql`count(*)` }).from(workflowExecutions).innerJoin(workflows, eq(workflowExecutions.workflowId, workflows.id)).where(eq(workflows.ownerId, userId));
      if (status) {
        query2 = query2.where(eq(workflowExecutions.status, status));
      }
      if (search && search.trim() !== "") {
        query2 = query2.where(like(workflows.name, `%${search}%`));
      }
      if (fromDate) {
        query2 = query2.where(gte(workflowExecutions.startedAt, fromDate));
      }
      if (toDate) {
        query2 = query2.where(lte(workflowExecutions.startedAt, toDate));
      }
      const result2 = await query2;
      return result2[0]?.count || 0;
    } catch (error) {
      console.error("Error counting executions by user:", error);
      return 0;
    }
  }
  async createWorkflowExecution(execution) {
    try {
      const [newExecution] = await db.insert(workflowExecutions).values({
        ...execution,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      return newExecution;
    } catch (error) {
      console.error("Error creating workflow execution:", error);
      throw error;
    }
  }
  async updateWorkflowExecution(id, executionData) {
    try {
      const [updatedExecution] = await db.update(workflowExecutions).set({
        ...executionData,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq(workflowExecutions.id, id)).returning();
      return updatedExecution;
    } catch (error) {
      console.error("Error updating workflow execution:", error);
      return void 0;
    }
  }
  // Node Execution methods
  async getNodeExecution(id) {
    try {
      const [nodeExecution] = await db.select().from(nodeExecutions).where(eq(nodeExecutions.id, id));
      return nodeExecution;
    } catch (error) {
      console.error("Error fetching node execution:", error);
      return void 0;
    }
  }
  async getNodeExecutions(executionId) {
    try {
      return await db.select().from(nodeExecutions).where(eq(nodeExecutions.executionId, executionId)).orderBy(nodeExecutions.startedAt);
    } catch (error) {
      console.error("Error fetching node executions:", error);
      return [];
    }
  }
  async createNodeExecution(nodeExecution) {
    try {
      const [newNodeExecution] = await db.insert(nodeExecutions).values(nodeExecution).returning();
      return newNodeExecution;
    } catch (error) {
      console.error("Error creating node execution:", error);
      throw error;
    }
  }
  async updateNodeExecution(id, nodeExecutionData) {
    try {
      const [updatedNodeExecution] = await db.update(nodeExecutions).set(nodeExecutionData).where(eq(nodeExecutions.id, id)).returning();
      return updatedNodeExecution;
    } catch (error) {
      console.error("Error updating node execution:", error);
      return void 0;
    }
  }
  // Execution Log methods
  async getExecutionLog(id) {
    try {
      const [log2] = await db.select().from(executionLogs).where(eq(executionLogs.id, id));
      return log2;
    } catch (error) {
      console.error("Error fetching execution log:", error);
      return void 0;
    }
  }
  async getExecutionLogs(executionId) {
    try {
      return await db.select().from(executionLogs).where(eq(executionLogs.executionId, executionId)).orderBy(executionLogs.timestamp);
    } catch (error) {
      console.error("Error fetching execution logs:", error);
      return [];
    }
  }
  async createExecutionLog(log2) {
    try {
      const [newLog] = await db.insert(executionLogs).values(log2).returning();
      return newLog;
    } catch (error) {
      console.error("Error creating execution log:", error);
      throw error;
    }
  }
  // Airbyte methods
  async getAirbyteConfig(userId) {
    try {
      const [config] = await db.select().from(airbyteConfigs).where(eq(airbyteConfigs.userId, userId));
      if (config) {
        return {
          userId: config.userId,
          configJson: config.configJson
        };
      }
      return void 0;
    } catch (error) {
      console.error("Error fetching Airbyte config:", error);
      return void 0;
    }
  }
  async saveAirbyteConfig(userId, config) {
    try {
      const existingConfig = await this.getAirbyteConfig(userId);
      if (existingConfig) {
        const [updatedConfig] = await db.update(airbyteConfigs).set({
          configJson: config.configJson,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(airbyteConfigs.userId, userId)).returning();
        return {
          userId: updatedConfig.userId,
          configJson: updatedConfig.configJson
        };
      } else {
        const [newConfig] = await db.insert(airbyteConfigs).values({
          userId,
          configJson: config.configJson
        }).returning();
        return {
          userId: newConfig.userId,
          configJson: newConfig.configJson
        };
      }
    } catch (error) {
      console.error("Error saving Airbyte config:", error);
      throw error;
    }
  }
  async getAirbyteSources(userId) {
    try {
      return await db.select().from(airbyteSources).where(eq(airbyteSources.userId, userId));
    } catch (error) {
      console.error("Error fetching Airbyte sources:", error);
      return [];
    }
  }
  async getAirbyteSource(id) {
    try {
      const [source] = await db.select().from(airbyteSources).where(eq(airbyteSources.id, id));
      return source;
    } catch (error) {
      console.error("Error fetching Airbyte source:", error);
      return void 0;
    }
  }
  async createAirbyteSource(source) {
    try {
      const [newSource] = await db.insert(airbyteSources).values(source).returning();
      return newSource;
    } catch (error) {
      console.error("Error creating Airbyte source:", error);
      throw error;
    }
  }
  async getAirbyteDestinations(userId) {
    try {
      return await db.select().from(airbyteDestinations).where(eq(airbyteDestinations.userId, userId));
    } catch (error) {
      console.error("Error fetching Airbyte destinations:", error);
      return [];
    }
  }
  async getAirbyteDestination(id) {
    try {
      const [destination] = await db.select().from(airbyteDestinations).where(eq(airbyteDestinations.id, id));
      return destination;
    } catch (error) {
      console.error("Error fetching Airbyte destination:", error);
      return void 0;
    }
  }
  async createAirbyteDestination(destination) {
    try {
      const [newDestination] = await db.insert(airbyteDestinations).values(destination).returning();
      return newDestination;
    } catch (error) {
      console.error("Error creating Airbyte destination:", error);
      throw error;
    }
  }
  async getAirbyteConnections(userId) {
    try {
      return await db.select().from(airbyteConnections).where(eq(airbyteConnections.userId, userId));
    } catch (error) {
      console.error("Error fetching Airbyte connections:", error);
      return [];
    }
  }
  async getAirbyteConnection(id) {
    try {
      const [connection] = await db.select().from(airbyteConnections).where(eq(airbyteConnections.id, id));
      return connection;
    } catch (error) {
      console.error("Error fetching Airbyte connection:", error);
      return void 0;
    }
  }
  async createAirbyteConnection(connection) {
    try {
      const [newConnection] = await db.insert(airbyteConnections).values(connection).returning();
      return newConnection;
    } catch (error) {
      console.error("Error creating Airbyte connection:", error);
      throw error;
    }
  }
  async getAirbyteSyncJobs(userId) {
    try {
      return await db.select().from(airbyteSyncJobs).where(eq(airbyteSyncJobs.userId, userId)).orderBy(desc(airbyteSyncJobs.createdAt));
    } catch (error) {
      console.error("Error fetching Airbyte sync jobs:", error);
      return [];
    }
  }
  async getAirbyteSyncJob(id) {
    try {
      const [job] = await db.select().from(airbyteSyncJobs).where(eq(airbyteSyncJobs.id, id));
      return job;
    } catch (error) {
      console.error("Error fetching Airbyte sync job:", error);
      return void 0;
    }
  }
  async createAirbyteSyncJob(job) {
    try {
      const [newJob] = await db.insert(airbyteSyncJobs).values(job).returning();
      return newJob;
    } catch (error) {
      console.error("Error creating Airbyte sync job:", error);
      throw error;
    }
  }
  async updateAirbyteSyncJob(id, job) {
    try {
      const [updatedJob] = await db.update(airbyteSyncJobs).set({
        ...job,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq(airbyteSyncJobs.id, id)).returning();
      return updatedJob;
    } catch (error) {
      console.error("Error updating Airbyte sync job:", error);
      return void 0;
    }
  }
  // Composio methods implementation
  async getComposioConfig(userId) {
    try {
      const [config] = await db.select().from(composioConfigs).where(eq(composioConfigs.userId, userId));
      return config;
    } catch (error) {
      console.error("Error getting Composio config:", error);
      return void 0;
    }
  }
  async saveComposioConfig(userId, config) {
    try {
      const existingConfig = await this.getComposioConfig(userId);
      if (existingConfig) {
        const [updatedConfig] = await db.update(composioConfigs).set({
          configJson: config.configJson,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(composioConfigs.userId, userId)).returning();
        return updatedConfig;
      } else {
        const [newConfig] = await db.insert(composioConfigs).values({
          userId,
          configJson: config.configJson,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).returning();
        return newConfig;
      }
    } catch (error) {
      console.error("Error saving Composio config:", error);
      throw error;
    }
  }
  async getComposioWorkflows(userId) {
    try {
      return await db.select().from(composioWorkflows).where(eq(composioWorkflows.userId, userId)).orderBy(desc(composioWorkflows.createdAt));
    } catch (error) {
      console.error("Error getting Composio workflows:", error);
      return [];
    }
  }
  async getComposioWorkflow(id) {
    try {
      const [workflow] = await db.select().from(composioWorkflows).where(eq(composioWorkflows.id, id));
      return workflow;
    } catch (error) {
      console.error("Error getting Composio workflow:", error);
      return void 0;
    }
  }
  async createComposioWorkflow(workflow) {
    try {
      const [newWorkflow] = await db.insert(composioWorkflows).values({
        ...workflow,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      return newWorkflow;
    } catch (error) {
      console.error("Error creating Composio workflow:", error);
      throw error;
    }
  }
  async updateComposioWorkflow(id, workflow) {
    try {
      const [updatedWorkflow] = await db.update(composioWorkflows).set({
        ...workflow,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq(composioWorkflows.id, id)).returning();
      return updatedWorkflow;
    } catch (error) {
      console.error("Error updating Composio workflow:", error);
      return void 0;
    }
  }
  async deleteComposioWorkflow(id) {
    try {
      await db.delete(composioWorkflows).where(eq(composioWorkflows.id, id));
      return true;
    } catch (error) {
      console.error("Error deleting Composio workflow:", error);
      return false;
    }
  }
  async getComposioTriggers(workflowId) {
    try {
      return await db.select().from(composioTriggers).where(eq(composioTriggers.workflowId, workflowId)).orderBy(desc(composioTriggers.createdAt));
    } catch (error) {
      console.error("Error getting Composio triggers:", error);
      return [];
    }
  }
  async getComposioTrigger(id) {
    try {
      const [trigger] = await db.select().from(composioTriggers).where(eq(composioTriggers.id, id));
      return trigger;
    } catch (error) {
      console.error("Error getting Composio trigger:", error);
      return void 0;
    }
  }
  async createComposioTrigger(trigger) {
    try {
      const [newTrigger] = await db.insert(composioTriggers).values({
        ...trigger,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      return newTrigger;
    } catch (error) {
      console.error("Error creating Composio trigger:", error);
      throw error;
    }
  }
  async getComposioActions(workflowId) {
    try {
      return await db.select().from(composioActions).where(eq(composioActions.workflowId, workflowId)).orderBy(desc(composioActions.createdAt));
    } catch (error) {
      console.error("Error getting Composio actions:", error);
      return [];
    }
  }
  async getComposioAction(id) {
    try {
      const [action] = await db.select().from(composioActions).where(eq(composioActions.id, id));
      return action;
    } catch (error) {
      console.error("Error getting Composio action:", error);
      return void 0;
    }
  }
  async createComposioAction(action) {
    try {
      const [newAction] = await db.insert(composioActions).values({
        ...action,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      return newAction;
    } catch (error) {
      console.error("Error creating Composio action:", error);
      throw error;
    }
  }
  async getComposioExecutions(userId, workflowId) {
    try {
      let query2 = db.select().from(composioExecutions).where(eq(composioExecutions.userId, userId));
      if (workflowId) {
        query2 = query2.where(eq(composioExecutions.workflowId, workflowId));
      }
      return await query2.orderBy(desc(composioExecutions.createdAt));
    } catch (error) {
      console.error("Error getting Composio executions:", error);
      return [];
    }
  }
  async getComposioExecution(id) {
    try {
      const [execution] = await db.select().from(composioExecutions).where(eq(composioExecutions.id, id));
      return execution;
    } catch (error) {
      console.error("Error getting Composio execution:", error);
      return void 0;
    }
  }
  async createComposioExecution(execution) {
    try {
      const [newExecution] = await db.insert(composioExecutions).values({
        ...execution,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      return newExecution;
    } catch (error) {
      console.error("Error creating Composio execution:", error);
      throw error;
    }
  }
  async updateComposioExecution(id, execution) {
    try {
      const [updatedExecution] = await db.update(composioExecutions).set({
        ...execution,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq(composioExecutions.id, id)).returning();
      return updatedExecution;
    } catch (error) {
      console.error("Error updating Composio execution:", error);
      return void 0;
    }
  }
  // Slack Integration methods
  async getSlackConfig(userId) {
    try {
      const [config] = await db.select().from(slackConfigs).where(
        and(
          eq(slackConfigs.userId, userId),
          eq(slackConfigs.isActive, true)
        )
      );
      return config;
    } catch (error) {
      console.error("Error getting Slack config:", error);
      return void 0;
    }
  }
  async getSlackConfigById(id) {
    try {
      const [config] = await db.select().from(slackConfigs).where(eq(slackConfigs.id, id));
      return config;
    } catch (error) {
      console.error("Error getting Slack config by ID:", error);
      return void 0;
    }
  }
  async createSlackConfig(config) {
    try {
      await db.update(slackConfigs).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(
        and(
          eq(slackConfigs.userId, config.userId),
          eq(slackConfigs.isActive, true)
        )
      );
      const [newConfig] = await db.insert(slackConfigs).values(config).returning();
      return newConfig;
    } catch (error) {
      console.error("Error creating Slack config:", error);
      throw error;
    }
  }
  async updateSlackConfig(id, configData) {
    try {
      const [updated] = await db.update(slackConfigs).set({
        ...configData,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq(slackConfigs.id, id)).returning();
      return updated;
    } catch (error) {
      console.error("Error updating Slack config:", error);
      return void 0;
    }
  }
  async deleteSlackConfig(id) {
    try {
      const result2 = await db.delete(slackConfigs).where(eq(slackConfigs.id, id));
      return result2.rowCount > 0;
    } catch (error) {
      console.error("Error deleting Slack config:", error);
      return false;
    }
  }
  async getSlackChannels(userId, configId) {
    try {
      let query2 = db.select().from(slackChannels).where(eq(slackChannels.userId, userId));
      if (configId) {
        query2 = query2.where(eq(slackChannels.configId, configId));
      }
      return await query2;
    } catch (error) {
      console.error("Error getting Slack channels:", error);
      return [];
    }
  }
  async getSlackChannel(id) {
    try {
      const [channel] = await db.select().from(slackChannels).where(eq(slackChannels.id, id));
      return channel;
    } catch (error) {
      console.error("Error getting Slack channel:", error);
      return void 0;
    }
  }
  async getSlackChannelBySlackId(userId, configId, channelId) {
    try {
      const [channel] = await db.select().from(slackChannels).where(
        and(
          eq(slackChannels.userId, userId),
          eq(slackChannels.configId, configId),
          eq(slackChannels.channelId, channelId)
        )
      );
      return channel;
    } catch (error) {
      console.error("Error getting Slack channel by Slack ID:", error);
      return void 0;
    }
  }
  async createSlackChannel(channel) {
    try {
      const [newChannel] = await db.insert(slackChannels).values(channel).returning();
      return newChannel;
    } catch (error) {
      console.error("Error creating Slack channel:", error);
      throw error;
    }
  }
  async updateSlackChannel(id, updateData) {
    try {
      const [updated] = await db.update(slackChannels).set(updateData).where(eq(slackChannels.id, id)).returning();
      return updated;
    } catch (error) {
      console.error("Error updating Slack channel:", error);
      return void 0;
    }
  }
  async createOrUpdateSlackChannels(userId, configId, channels) {
    try {
      const results = [];
      for (const channel of channels) {
        const existing = await this.getSlackChannelBySlackId(userId, configId, channel.channelId);
        if (existing) {
          const updated = await this.updateSlackChannel(existing.id, {
            name: channel.name,
            isPrivate: channel.isPrivate,
            lastSyncedAt: /* @__PURE__ */ new Date()
          });
          if (updated) results.push(updated);
        } else {
          const newChannel = await this.createSlackChannel({
            userId,
            configId,
            channelId: channel.channelId,
            name: channel.name,
            isPrivate: channel.isPrivate,
            lastSyncedAt: /* @__PURE__ */ new Date()
          });
          results.push(newChannel);
        }
      }
      return results;
    } catch (error) {
      console.error("Error creating/updating Slack channels:", error);
      return [];
    }
  }
  async getSlackMessages(channelId, options2) {
    try {
      let query2 = db.select().from(slackMessages).where(eq(slackMessages.channelId, channelId)).orderBy(desc(slackMessages.postedAt));
      if (options2?.limit) {
        query2 = query2.limit(options2.limit);
      }
      if (options2?.before) {
        query2 = query2.where(lt(slackMessages.postedAt, options2.before));
      }
      if (options2?.after) {
        query2 = query2.where(gt(slackMessages.postedAt, options2.after));
      }
      return await query2;
    } catch (error) {
      console.error("Error getting Slack messages:", error);
      return [];
    }
  }
  async getSlackMessageByMessageId(channelId, messageId) {
    try {
      const [message] = await db.select().from(slackMessages).where(
        and(
          eq(slackMessages.channelId, channelId),
          eq(slackMessages.messageId, messageId)
        )
      );
      return message;
    } catch (error) {
      console.error("Error getting Slack message by message ID:", error);
      return void 0;
    }
  }
  async createSlackMessage(message) {
    try {
      const [newMessage] = await db.insert(slackMessages).values(message).returning();
      return newMessage;
    } catch (error) {
      console.error("Error creating Slack message:", error);
      throw error;
    }
  }
  async batchCreateSlackMessages(messages) {
    try {
      if (messages.length === 0) return 0;
      const result2 = await db.insert(slackMessages).values(messages);
      return result2.rowCount;
    } catch (error) {
      console.error("Error batch creating Slack messages:", error);
      return 0;
    }
  }
  async getSlackWebhooks(userId, configId) {
    try {
      let query2 = db.select().from(slackWebhooks).where(eq(slackWebhooks.userId, userId));
      if (configId) {
        query2 = query2.where(eq(slackWebhooks.configId, configId));
      }
      return await query2;
    } catch (error) {
      console.error("Error getting Slack webhooks:", error);
      return [];
    }
  }
  async getSlackWebhook(id) {
    try {
      const [webhook] = await db.select().from(slackWebhooks).where(eq(slackWebhooks.id, id));
      return webhook;
    } catch (error) {
      console.error("Error getting Slack webhook:", error);
      return void 0;
    }
  }
  async createSlackWebhook(webhook) {
    try {
      const [newWebhook] = await db.insert(slackWebhooks).values(webhook).returning();
      return newWebhook;
    } catch (error) {
      console.error("Error creating Slack webhook:", error);
      throw error;
    }
  }
  async updateSlackWebhook(id, webhookData) {
    try {
      const [updated] = await db.update(slackWebhooks).set({
        ...webhookData,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq(slackWebhooks.id, id)).returning();
      return updated;
    } catch (error) {
      console.error("Error updating Slack webhook:", error);
      return void 0;
    }
  }
  async deleteSlackWebhook(id) {
    try {
      const result2 = await db.delete(slackWebhooks).where(eq(slackWebhooks.id, id));
      return result2.rowCount > 0;
    } catch (error) {
      console.error("Error deleting Slack webhook:", error);
      return false;
    }
  }
  // OAuth connection methods
  async getOAuthConnectionsByUser(userId) {
    try {
      return await db.select().from(oauthConnections).where(eq(oauthConnections.userId, userId)).orderBy(desc(oauthConnections.updatedAt));
    } catch (error) {
      console.error("Error getting OAuth connections by user:", error);
      return [];
    }
  }
  async getOAuthConnectionsByProvider(userId, provider) {
    try {
      return await db.select().from(oauthConnections).where(and(
        eq(oauthConnections.userId, userId),
        eq(oauthConnections.provider, provider)
      )).orderBy(desc(oauthConnections.updatedAt));
    } catch (error) {
      console.error("Error getting OAuth connections by provider:", error);
      return [];
    }
  }
  async getOAuthConnection(id) {
    try {
      const [connection] = await db.select().from(oauthConnections).where(eq(oauthConnections.id, id));
      return connection;
    } catch (error) {
      console.error("Error getting OAuth connection:", error);
      return void 0;
    }
  }
  async getOAuthConnectionByNangoId(userId, provider, connectionId) {
    try {
      const [connection] = await db.select().from(oauthConnections).where(and(
        eq(oauthConnections.userId, userId),
        eq(oauthConnections.provider, provider),
        eq(oauthConnections.connectionId, connectionId)
      ));
      return connection;
    } catch (error) {
      console.error("Error getting OAuth connection by Nango ID:", error);
      return void 0;
    }
  }
  async createOAuthConnection(connection) {
    try {
      const [newConnection] = await db.insert(oauthConnections).values({
        ...connection,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      return newConnection;
    } catch (error) {
      console.error("Error creating OAuth connection:", error);
      throw error;
    }
  }
  async updateOAuthConnection(id, connectionData) {
    try {
      const [updatedConnection] = await db.update(oauthConnections).set({
        ...connectionData,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq(oauthConnections.id, id)).returning();
      return updatedConnection;
    } catch (error) {
      console.error("Error updating OAuth connection:", error);
      return void 0;
    }
  }
  async deleteOAuthConnection(id) {
    try {
      const result2 = await db.delete(oauthConnections).where(eq(oauthConnections.id, id));
      return result2.rowCount > 0;
    } catch (error) {
      console.error("Error deleting OAuth connection:", error);
      return false;
    }
  }
};
var storage = new DatabaseStorage();

// server/routes.ts
import { z as z14 } from "zod";
import bcrypt from "bcryptjs";
import passport from "passport";
import { Strategy as LocalStrategy } from "passport-local";
import session from "express-session";
import { v4 as uuidv49 } from "uuid";
import Stripe2 from "stripe";
import multer2 from "multer";

// server/services/ocr.ts
import { createWorker } from "tesseract.js";

// server/vite.ts
import express from "express";
import fs from "fs";
import path2 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets")
    }
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options2) => {
        viteLogger.error(msg, options2);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req2, res2, next) => {
    const url = req2.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res2.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path2.resolve(import.meta.dirname, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res2) => {
    res2.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/services/ocr.ts
var DocumentType = /* @__PURE__ */ ((DocumentType2) => {
  DocumentType2["GENERIC"] = "generic";
  DocumentType2["INVOICE"] = "invoice";
  DocumentType2["RECEIPT"] = "receipt";
  DocumentType2["ID_CARD"] = "id_card";
  DocumentType2["BUSINESS_CARD"] = "business_card";
  DocumentType2["FORM"] = "form";
  DocumentType2["TABLE"] = "table";
  return DocumentType2;
})(DocumentType || {});
var OCRService = class {
  /**
   * Main method to process an image with OCR
   */
  static async processImage(imageData, options2 = {}) {
    const startTime2 = Date.now();
    const language = options2.language || "eng";
    const documentType = options2.documentType || "generic" /* GENERIC */;
    const minConfidence = options2.confidence || 0.7;
    let engineToUse = options2.engine || this.selectOCREngine(options2);
    try {
      let result2;
      let processingError = false;
      try {
        if (engineToUse === "tesseract" /* TESSERACT */) {
          result2 = await this.processTesseract(imageData, language, minConfidence);
        } else if (engineToUse === "paddleocr" /* PADDLE_OCR */) {
          log(`Using Tesseract as fallback for PaddleOCR (${documentType})`, "ocr");
          result2 = await this.processTesseract(imageData, language, minConfidence);
          result2.engineUsed = "paddleocr" /* PADDLE_OCR */;
        } else if (engineToUse === "easyocr" /* EASY_OCR */) {
          log(`Using Tesseract as fallback for EasyOCR (handwriting detection)`, "ocr");
          result2 = await this.processTesseract(imageData, language, minConfidence);
          result2.engineUsed = "easyocr" /* EASY_OCR */;
        } else if (engineToUse === "google_vision" /* GOOGLE_VISION */) {
          log(`Using Tesseract as fallback for Google Vision (heavy PDF processing)`, "ocr");
          result2 = await this.processTesseract(imageData, language, minConfidence);
          result2.engineUsed = "google_vision" /* GOOGLE_VISION */;
        } else if (engineToUse === "omniparser" /* OMNIPARSER */) {
          log(`Using Tesseract as fallback for Omniparser (structured JSON required)`, "ocr");
          result2 = await this.processTesseract(imageData, language, minConfidence);
          result2.engineUsed = "omniparser" /* OMNIPARSER */;
        } else {
          throw new Error(`Unknown OCR engine: ${engineToUse}`);
        }
      } catch (initialError) {
        log(`Initial OCR processing error with ${engineToUse}: ${initialError}`, "ocr");
        processingError = true;
        result2 = {
          text: "",
          confidence: 0,
          engineUsed: engineToUse
        };
      }
      if (processingError || !result2.text.trim()) {
        log(`Empty result or error detected, falling back to Tesseract as last resort`, "ocr");
        result2 = await this.processTesseract(imageData, language, minConfidence);
      }
      result2.executionTime = Date.now() - startTime2;
      return result2;
    } catch (error) {
      log(`OCR processing failed completely: ${error}`, "ocr");
      throw new Error(`OCR processing failed: ${error}`);
    }
  }
  /**
   * Process image with Tesseract
   */
  static async processTesseract(imageData, language = "eng", minConfidence = 0.7) {
    const worker = await createWorker(language);
    try {
      const imageSource = Buffer.isBuffer(imageData) ? Buffer.from(imageData).toString("base64") : imageData;
      const { data } = await worker.recognize(imageSource);
      const words = data.text.split(/\s+/).map((word) => ({
        text: word,
        confidence: data.confidence
      }));
      const validWords = words.filter((word) => word.confidence >= minConfidence).map((word) => ({
        text: word.text,
        confidence: word.confidence
      }));
      const result2 = {
        text: data.text,
        confidence: data.confidence,
        words: validWords,
        engineUsed: "tesseract" /* TESSERACT */
      };
      return result2;
    } finally {
      await worker.terminate();
    }
  }
  /**
   * Select the appropriate OCR engine based on all criteria
   */
  static selectOCREngine(options2) {
    const documentType = options2.documentType || "generic" /* GENERIC */;
    if (options2.hasHandwriting) {
      log("Routing to EasyOCR due to handwriting detection", "ocr");
      return "easyocr" /* EASY_OCR */;
    }
    if (documentType === "table" /* TABLE */) {
      log("Routing to DocTR for table structure extraction", "ocr");
      return "paddleocr" /* PADDLE_OCR */;
    }
    if (options2.isPdf || options2.fileSize && options2.fileSize > 5 * 1024 * 1024) {
      log("Routing to Google Vision due to heavy PDF or large file size", "ocr");
      return "google_vision" /* GOOGLE_VISION */;
    }
    if (options2.structuredJsonRequired) {
      log("Routing to Omniparser for structured JSON output", "ocr");
      return "omniparser" /* OMNIPARSER */;
    }
    if (options2.region === "EU" || options2.latency && options2.latency > 1e3) {
      log("Routing to PaddleOCR due to EU region or high latency", "ocr");
      return "paddleocr" /* PADDLE_OCR */;
    }
    switch (documentType) {
      case "invoice" /* INVOICE */:
      case "receipt" /* RECEIPT */:
      case "id_card" /* ID_CARD */:
      case "business_card" /* BUSINESS_CARD */:
        return "paddleocr" /* PADDLE_OCR */;
      case "form" /* FORM */:
      case "generic" /* GENERIC */:
      default:
        return "tesseract" /* TESSERACT */;
    }
  }
  /**
   * Legacy method for backward compatibility
   */
  static selectEngineForDocumentType(documentType) {
    return this.selectOCREngine({ documentType });
  }
};

// server/services/scraper.ts
import axios from "axios";
import * as cheerio from "cheerio";
import puppeteer from "puppeteer";
import { JSDOM } from "jsdom";
var ScraperEngine = /* @__PURE__ */ ((ScraperEngine2) => {
  ScraperEngine2["CHEERIO"] = "cheerio";
  ScraperEngine2["JSDOM"] = "jsdom";
  ScraperEngine2["PUPPETEER"] = "puppeteer";
  ScraperEngine2["CRAWL4AI"] = "crawl4ai";
  ScraperEngine2["SCRAPEGRAPH"] = "scrapegraph";
  ScraperEngine2["CLOUDSCRAPER"] = "cloudscraper";
  return ScraperEngine2;
})(ScraperEngine || {});
var SiteType = /* @__PURE__ */ ((SiteType2) => {
  SiteType2["GENERIC"] = "generic";
  SiteType2["E_COMMERCE"] = "e_commerce";
  SiteType2["NEWS"] = "news";
  SiteType2["SOCIAL_MEDIA"] = "social_media";
  SiteType2["FORUM"] = "forum";
  SiteType2["JOB_BOARD"] = "job_board";
  SiteType2["SPA"] = "single_page_app";
  SiteType2["VISUAL"] = "visual";
  SiteType2["PROTECTED"] = "protected";
  return SiteType2;
})(SiteType || {});
var ScraperService = class {
  /**
   * Scrape a webpage
   */
  static async scrape(url, options2 = {}) {
    const startTime2 = Date.now();
    const siteType = options2.siteType || "generic" /* GENERIC */;
    const timeout = options2.timeout || 3e4;
    const headers = options2.headers || {
      "User-Agent": "Mozilla/5.0 (compatible; SynthralOS/1.0; +https://synthral.com/bot)"
    };
    const engineToUse = options2.engine || this.selectEngineForSiteType(siteType, options2);
    try {
      let result2;
      log(`Starting scraping with engine: ${engineToUse} for site type: ${siteType}`, "scraper");
      switch (engineToUse) {
        case "cheerio" /* CHEERIO */:
          result2 = await this.scrapeWithCheerio(url, options2);
          break;
        case "jsdom" /* JSDOM */:
          result2 = await this.scrapeWithJSDOM(url, options2);
          break;
        case "puppeteer" /* PUPPETEER */:
          result2 = await this.scrapeWithPuppeteer(url, options2);
          break;
        case "crawl4ai" /* CRAWL4AI */:
          result2 = await this.scrapeWithCrawl4AI(url, options2);
          break;
        default:
          log(`Unknown engine ${engineToUse}, falling back to Cheerio`, "scraper");
          result2 = await this.scrapeWithCheerio(url, options2);
          break;
      }
      result2.metadata.executionTime = Date.now() - startTime2;
      return result2;
    } catch (error) {
      log(`Scraping error: ${error}`, "scraper");
      throw new Error(`Scraping failed: ${error}`);
    }
  }
  /**
   * Scrape with Cheerio (static HTML parsing)
   */
  static async scrapeWithCheerio(url, options2 = {}) {
    const headers = options2.headers || {
      "User-Agent": "Mozilla/5.0 (compatible; SynthralOS/1.0; +https://synthral.com/bot)"
    };
    const response = await axios.get(url, {
      headers,
      timeout: options2.timeout || 3e4,
      ...options2.proxy ? { proxy: { host: options2.proxy.split(":")[0], port: parseInt(options2.proxy.split(":")[1]) } } : {}
    });
    const html = response.data;
    const $ = cheerio.load(html);
    const title = $("title").text().trim();
    const text2 = $("body").text().trim();
    const data = {};
    if (options2.selectors) {
      for (const [key, selector] of Object.entries(options2.selectors)) {
        const elements = $(selector);
        if (elements.length === 1) {
          data[key] = elements.text().trim();
        } else if (elements.length > 1) {
          data[key] = elements.map((i, el) => $(el).text().trim()).get();
        }
      }
    }
    const links = $("a").map((i, el) => $(el).attr("href")).get().filter((href) => href && !href.startsWith("#") && !href.startsWith("javascript:"));
    const images = $("img").map((i, el) => $(el).attr("src")).get().filter((src) => src);
    const result2 = {
      url,
      title,
      html,
      text: text2,
      data,
      metadata: {
        links,
        images,
        statusCode: response.status,
        contentType: response.headers["content-type"] || "",
        engineUsed: "cheerio" /* CHEERIO */,
        executionTime: 0
        // Will be updated later
      }
    };
    return result2;
  }
  /**
   * Scrape with JSDOM - DOM-based parsing
   */
  static async scrapeWithJSDOM(url, options2 = {}) {
    const headers = options2.headers || {
      "User-Agent": "Mozilla/5.0 (compatible; SynthralOS/1.0; +https://synthral.com/bot)"
    };
    const response = await axios.get(url, {
      headers,
      timeout: options2.timeout || 3e4,
      ...options2.proxy ? { proxy: { host: options2.proxy.split(":")[0], port: parseInt(options2.proxy.split(":")[1]) } } : {}
    });
    const html = response.data;
    const dom = new JSDOM(html, { url });
    const { document: document2 } = dom.window;
    const title = document2.title || "";
    const text2 = document2.body?.textContent?.trim() || "";
    const data = {};
    if (options2.selectors) {
      for (const [key, selector] of Object.entries(options2.selectors)) {
        try {
          const elements = document2.querySelectorAll(selector);
          if (elements.length === 1) {
            data[key] = elements[0].textContent?.trim() || "";
          } else if (elements.length > 1) {
            data[key] = Array.from(elements).map((el) => el.textContent?.trim() || "");
          }
        } catch (error) {
          log(`Error with selector ${selector}: ${error}`, "scraper");
        }
      }
    }
    const links = Array.from(document2.querySelectorAll("a")).map((a) => a.getAttribute("href")).filter((href) => href && !href.startsWith("#") && !href.startsWith("javascript:"));
    const images = Array.from(document2.querySelectorAll("img")).map((img) => img.getAttribute("src")).filter((src) => src);
    const result2 = {
      url,
      title,
      html,
      text: text2,
      data,
      metadata: {
        links,
        images,
        statusCode: response.status,
        contentType: response.headers["content-type"] || "",
        engineUsed: "jsdom" /* JSDOM */,
        executionTime: 0
        // Will be updated later
      }
    };
    return result2;
  }
  /**
   * Scrape with Puppeteer - headless browser rendering
   */
  static async scrapeWithPuppeteer(url, options2 = {}) {
    let browser;
    try {
      const launchOptions = {
        headless: "new",
        args: [
          "--no-sandbox",
          "--disable-setuid-sandbox",
          "--disable-dev-shm-usage",
          "--disable-accelerated-2d-canvas",
          "--disable-gpu"
        ]
      };
      browser = await puppeteer.launch(launchOptions);
      const page = await browser.newPage();
      await page.setUserAgent("Mozilla/5.0 (compatible; SynthralOS/1.0; +https://synthral.com/bot)");
      if (options2.headers) {
        await page.setExtraHTTPHeaders(options2.headers);
      }
      if (options2.cookies) {
        const cookies = Object.entries(options2.cookies).map(([name, value]) => ({
          name,
          value,
          domain: new URL(url).hostname
        }));
        await page.setCookie(...cookies);
      }
      await page.setDefaultNavigationTimeout(options2.timeout || 3e4);
      const response = await page.goto(url, {
        waitUntil: "networkidle2"
        // Wait until network is idle
      });
      if (!response) {
        throw new Error("Failed to get response from page");
      }
      await new Promise((resolve) => setTimeout(resolve, 2e3));
      const html = await page.content();
      const title = await page.title();
      const text2 = await page.evaluate(() => document.body.innerText);
      const data = {};
      if (options2.selectors) {
        for (const [key, selector] of Object.entries(options2.selectors)) {
          try {
            const selectorExistsOnPage = await page.$(selector) !== null;
            if (selectorExistsOnPage) {
              const extractedTexts = await page.$$eval(
                selector,
                (els) => els.map((el) => el.textContent?.trim() || "")
              );
              if (extractedTexts.length === 1) {
                data[key] = extractedTexts[0];
              } else if (extractedTexts.length > 1) {
                data[key] = extractedTexts;
              }
            }
          } catch (error) {
            log(`Error with selector ${selector}: ${error}`, "scraper");
          }
        }
      }
      const links = await page.$$eval("a", (as) => as.map((a) => a.href).filter((href) => href && !href.startsWith("#") && !href.startsWith("javascript:")));
      const images = await page.$$eval("img", (imgs) => imgs.map((img) => img.src).filter((src) => src));
      if (options2.pagination?.enabled && options2.pagination.selector) {
        const maxPages = options2.pagination.maxPages || 1;
        const paginationSelector = options2.pagination.selector;
        let currentPage = 1;
        while (currentPage < maxPages) {
          const nextPageExists = await page.$(paginationSelector) !== null;
          if (!nextPageExists) break;
          try {
            await Promise.all([
              page.waitForNavigation({ waitUntil: "networkidle2" }),
              page.click(paginationSelector)
            ]);
            if (options2.selectors) {
              for (const [key, selector] of Object.entries(options2.selectors)) {
                try {
                  const additionalTexts = await page.$$eval(
                    selector,
                    (els) => els.map((el) => el.textContent?.trim() || "")
                  );
                  if (additionalTexts.length > 0) {
                    if (!data[key]) {
                      data[key] = additionalTexts;
                    } else if (Array.isArray(data[key])) {
                      data[key] = [...data[key], ...additionalTexts];
                    } else {
                      data[key] = [data[key], ...additionalTexts];
                    }
                  }
                } catch (error) {
                }
              }
            }
            currentPage++;
          } catch (error) {
            log(`Error during pagination: ${error}`, "scraper");
            break;
          }
        }
      }
      const result2 = {
        url,
        title,
        html,
        text: text2,
        data,
        metadata: {
          links,
          images,
          statusCode: response.status(),
          contentType: response.headers()["content-type"] || "",
          engineUsed: "puppeteer" /* PUPPETEER */,
          executionTime: 0
          // Will be updated later
        }
      };
      return result2;
    } finally {
      if (browser) {
        await browser.close();
      }
    }
  }
  /**
   * Scrape with Crawl4AI - advanced scraping with ML capabilities
   * This is a more advanced implementation that combines the strengths of various 
   * scraping approaches with additional intelligence
   */
  static async scrapeWithCrawl4AI(url, options2 = {}) {
    const cheerioResult = await this.scrapeWithCheerio(url, options2);
    let html = cheerioResult.html;
    let dynamicData = {};
    if (options2.siteType === "e_commerce" /* E_COMMERCE */ || options2.siteType === "job_board" /* JOB_BOARD */) {
      try {
        const puppeteerResult = await this.scrapeWithPuppeteer(url, options2);
        html = puppeteerResult.html;
        const structuredData = await this.extractStructuredData(puppeteerResult.html);
        if (structuredData) {
          dynamicData.structuredData = structuredData;
        }
        const openGraphData = this.extractOpenGraphData(puppeteerResult.html);
        if (openGraphData && Object.keys(openGraphData).length > 0) {
          dynamicData.openGraph = openGraphData;
        }
      } catch (error) {
        log(`Error in advanced crawling: ${error}`, "scraper");
      }
    }
    const mergedData = {
      ...cheerioResult.data,
      ...dynamicData
    };
    const result2 = {
      url,
      title: cheerioResult.title,
      html,
      text: cheerioResult.text,
      data: mergedData,
      metadata: {
        links: cheerioResult.metadata.links,
        images: cheerioResult.metadata.images,
        statusCode: cheerioResult.metadata.statusCode,
        contentType: cheerioResult.metadata.contentType,
        engineUsed: "crawl4ai" /* CRAWL4AI */,
        executionTime: 0
        // Will be updated later
      }
    };
    return result2;
  }
  /**
   * Extract structured data (JSON-LD, microdata) from HTML
   */
  static async extractStructuredData(html) {
    try {
      const $ = cheerio.load(html);
      const structuredData = {};
      const jsonLdScripts = $('script[type="application/ld+json"]');
      if (jsonLdScripts.length > 0) {
        const jsonLdData = [];
        jsonLdScripts.each((_, element) => {
          try {
            const content2 = $(element).html();
            if (content2) {
              const parsed = JSON.parse(content2);
              jsonLdData.push(parsed);
            }
          } catch (e) {
          }
        });
        if (jsonLdData.length > 0) {
          structuredData.jsonLd = jsonLdData;
        }
      }
      const itemScopes = $("[itemscope]");
      if (itemScopes.length > 0) {
        const microdata = [];
        itemScopes.each((_, element) => {
          const itemType = $(element).attr("itemtype");
          const properties = {};
          $(element).find("[itemprop]").each((_2, propElement) => {
            const propName = $(propElement).attr("itemprop");
            if (propName) {
              properties[propName] = $(propElement).text().trim();
            }
          });
          if (Object.keys(properties).length > 0) {
            microdata.push({
              type: itemType,
              properties
            });
          }
        });
        if (microdata.length > 0) {
          structuredData.microdata = microdata;
        }
      }
      return Object.keys(structuredData).length > 0 ? structuredData : null;
    } catch (error) {
      log(`Error extracting structured data: ${error}`, "scraper");
      return null;
    }
  }
  /**
   * Extract OpenGraph data from HTML
   */
  static extractOpenGraphData(html) {
    try {
      const $ = cheerio.load(html);
      const ogData = {};
      $('meta[property^="og:"]').each((_, element) => {
        const property = $(element).attr("property");
        const content2 = $(element).attr("content");
        if (property && content2) {
          const key = property.replace("og:", "");
          ogData[key] = content2;
        }
      });
      return ogData;
    } catch (error) {
      log(`Error extracting OpenGraph data: ${error}`, "scraper");
      return {};
    }
  }
  /**
   * Select the appropriate scraper engine based on site type and options
   */
  static selectEngineForSiteType(siteType, options2) {
    if (options2.detectedProtection && options2.detectedProtection !== "none" /* NONE */) {
      log(`Bot protection detected: ${options2.detectedProtection}, using CloudScraper`, "scraper");
      return "cloudscraper" /* CLOUDSCRAPER */;
    }
    if (options2.isVisualSite || siteType === "visual" /* VISUAL */) {
      log(`Visual site detected, using ScrapeGraph for visual analysis`, "scraper");
      return "scrapegraph" /* SCRAPEGRAPH */;
    }
    if (options2.javascriptRendering) {
      return "puppeteer" /* PUPPETEER */;
    }
    switch (siteType) {
      case "single_page_app" /* SPA */:
      case "social_media" /* SOCIAL_MEDIA */:
        return "puppeteer" /* PUPPETEER */;
      case "e_commerce" /* E_COMMERCE */:
      case "job_board" /* JOB_BOARD */:
        return "crawl4ai" /* CRAWL4AI */;
      case "news" /* NEWS */:
        return "jsdom" /* JSDOM */;
      case "forum" /* FORUM */:
        return "jsdom" /* JSDOM */;
      case "protected" /* PROTECTED */:
        return "cloudscraper" /* CLOUDSCRAPER */;
      case "generic" /* GENERIC */:
      default:
        return "cheerio" /* CHEERIO */;
    }
  }
  /**
   * Detect bot protection on a website
   * This should be run before scraping to determine the best engine
   */
  static async detectBotProtection(url) {
    try {
      const headResponse = await axios.head(url, {
        timeout: 5e3,
        headers: {
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
        }
      });
      const server = headResponse.headers["server"] || "";
      if (server.toLowerCase().includes("cloudflare")) {
        log(`Cloudflare detected on ${url}`, "scraper");
        return "cloudflare" /* CLOUDFLARE */;
      }
      const response = await axios.get(url, {
        timeout: 5e3,
        headers: {
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
        }
      });
      const html = response.data;
      if (html.includes("captcha") || html.includes("CAPTCHA") || html.includes("recaptcha") || html.includes("hcaptcha")) {
        log(`CAPTCHA detected on ${url}`, "scraper");
        return "captcha" /* CAPTCHA */;
      }
      if (html.includes("challenge") || html.includes("security check") || html.includes("DDoS protection") || html.includes("please wait") || html.includes("checking your browser")) {
        log(`JavaScript challenge detected on ${url}`, "scraper");
        return "js_challenge" /* JS_CHALLENGE */;
      }
      return "none" /* NONE */;
    } catch (error) {
      if (error.response) {
        const status = error.response.status;
        if (status === 403 || status === 429) {
          log(`Rate limiting detected on ${url} (status: ${status})`, "scraper");
          return "rate_limiting" /* RATE_LIMITING */;
        }
        if (status === 503) {
          log(`Service unavailable, possibly Cloudflare on ${url}`, "scraper");
          return "cloudflare" /* CLOUDFLARE */;
        }
      }
      log(`Error checking bot protection: ${error}`, "scraper");
      return "none" /* NONE */;
    }
  }
  /**
   * Detect if a site is highly visual and requires visual scraping
   */
  static async detectVisualSite(url) {
    try {
      const response = await axios.get(url, {
        timeout: 5e3,
        headers: {
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
        }
      });
      const html = response.data;
      const $ = cheerio.load(html);
      const imageCount = $("img").length;
      const textLength = $("body").text().trim().length;
      const hasGallery = html.toLowerCase().includes("gallery") || html.toLowerCase().includes("carousel") || $('[class*="gallery"]').length > 0 || $('[class*="carousel"]').length > 0;
      const isKnownVisualSite = url.includes("instagram.com") || url.includes("pinterest.com") || url.includes("flickr.com") || url.includes("unsplash.com") || url.includes("shutterstock.com") || url.includes("behance.net");
      const isVisualSite = isKnownVisualSite || hasGallery || imageCount > 10 && imageCount * 100 > textLength;
      if (isVisualSite) {
        log(`Visual site detected: ${url}`, "scraper");
      }
      return isVisualSite;
    } catch (error) {
      log(`Error detecting visual site: ${error}`, "scraper");
      return false;
    }
  }
};

// server/services/agent.ts
import Anthropic from "@anthropic-ai/sdk";
var anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY
});
var CLAUDE_MODEL = "claude-3-7-sonnet-20250219";
var AgentType = /* @__PURE__ */ ((AgentType2) => {
  AgentType2["ASSISTANT"] = "assistant";
  AgentType2["RESEARCHER"] = "researcher";
  AgentType2["ANALYZER"] = "analyzer";
  AgentType2["EXECUTOR"] = "executor";
  AgentType2["COORDINATOR"] = "coordinator";
  AgentType2["SPECIALIST"] = "specialist";
  AgentType2["AUTONOMOUS"] = "autonomous";
  return AgentType2;
})(AgentType || {});
var Agent = class {
  type;
  capabilities;
  systemPrompt;
  maxTokens;
  temperature;
  tools;
  memory;
  /**
   * Create a new agent
   */
  constructor(options2) {
    this.type = options2.agentType;
    this.capabilities = options2.capabilities || {};
    this.systemPrompt = this.buildSystemPrompt(options2);
    this.maxTokens = options2.maxTokens || 1024;
    this.temperature = options2.temperature || 0.7;
    this.tools = options2.tools || [];
    this.memory = options2.memory || this.createDefaultMemory();
  }
  /**
   * Process a query with the agent
   */
  async process(query2, contextData) {
    const startTime2 = Date.now();
    try {
      this.memory.addEntry("user", query2);
      if (contextData) {
        Object.entries(contextData).forEach(([key, value]) => {
          this.memory.updateContext(key, value);
        });
      }
      const messages = this.prepareMessages();
      const result2 = await this.processWithLLM(messages);
      const toolResults = await this.handleToolCalls(result2.content);
      this.memory.addEntry("assistant", result2.content);
      const response = {
        response: result2.content,
        usedTools: toolResults,
        tokensUsed: {
          input: 0,
          // Anthropic doesn't provide token counts directly
          output: 0,
          total: 0
        },
        executionTime: Date.now() - startTime2
      };
      return response;
    } catch (error) {
      log(`Agent error: ${error}`, "agent");
      throw new Error(`Agent processing failed: ${error}`);
    }
  }
  /**
   * Process with the LLM
   */
  async processWithLLM(messages) {
    try {
      const response = await anthropic.messages.create({
        model: CLAUDE_MODEL,
        max_tokens: this.maxTokens,
        temperature: this.temperature,
        system: this.systemPrompt,
        messages
      });
      return { content: response.content[0].text };
    } catch (error) {
      log(`LLM error: ${error}`, "agent");
      throw new Error(`LLM processing failed: ${error}`);
    }
  }
  /**
   * Prepare messages from memory for the LLM
   */
  prepareMessages() {
    return this.memory.getRecentConversation(10);
  }
  /**
   * Handle tool calls that might be in the model's response
   */
  async handleToolCalls(content2) {
    if (!this.capabilities.useTools || this.tools.length === 0) {
      return void 0;
    }
    const toolResults = [];
    const toolCallPattern = /\[TOOL_CALL:(\w+)\](.*?)\[\/TOOL_CALL\]/gs;
    let match;
    while ((match = toolCallPattern.exec(content2)) !== null) {
      const toolName = match[1];
      const toolInput = match[2];
      const tool = this.tools.find((t) => t.name === toolName);
      if (tool) {
        try {
          const params2 = JSON.parse(toolInput);
          const result2 = await tool.execute(params2);
          toolResults.push({
            tool: toolName,
            input: params2,
            output: result2
          });
        } catch (error) {
          log(`Tool execution error: ${error}`, "agent");
        }
      }
    }
    return toolResults.length > 0 ? toolResults : void 0;
  }
  /**
   * Build system prompt based on agent type and capabilities
   */
  buildSystemPrompt(options2) {
    let basePrompt = `You are an AI assistant in the SynthralOS platform, functioning as a ${options2.agentType} agent.`;
    switch (options2.agentType) {
      case "assistant" /* ASSISTANT */:
        basePrompt += ` Your goal is to assist users with their questions and tasks in a helpful, harmless, and honest manner.`;
        break;
      case "researcher" /* RESEARCHER */:
        basePrompt += ` Your goal is to gather, summarize, and present information on any given topic. Provide comprehensive and accurate information, citing sources where possible.`;
        break;
      case "analyzer" /* ANALYZER */:
        basePrompt += ` Your goal is to analyze data, identify patterns, and provide insights. Be thorough, accurate, and data-driven in your analysis.`;
        break;
      case "executor" /* EXECUTOR */:
        basePrompt += ` Your goal is to execute tasks accurately and efficiently based on given instructions. Provide clear step-by-step explanations of your process.`;
        break;
      case "coordinator" /* COORDINATOR */:
        basePrompt += ` Your goal is to coordinate and orchestrate tasks among multiple agents or components. Ensure efficient workflow, proper task allocation, and effective collaboration.`;
        break;
      case "specialist" /* SPECIALIST */:
        const specialization = options2.capabilities?.specialization || "general domain";
        basePrompt += ` Your goal is to provide expert-level assistance in the ${specialization}. Leverage your specialized knowledge to solve complex problems in this domain.`;
        break;
      case "autonomous" /* AUTONOMOUS */:
        basePrompt += ` Your goal is to autonomously plan, reason, and execute tasks with minimal human input. Break down complex tasks, make decisions, and adapt to new information as needed.`;
        break;
    }
    if (options2.capabilities?.useTools) {
      basePrompt += `

You have access to the following tools:
`;
      this.tools.forEach((tool) => {
        basePrompt += `- ${tool.name}: ${tool.description}
`;
      });
      basePrompt += `
To use a tool, format your message as:
[TOOL_CALL:tool_name]{"param1": "value1", ...}[/TOOL_CALL]`;
    }
    if (options2.capabilities?.multiStep) {
      basePrompt += `

For complex queries, break down your thinking into steps and show your reasoning process before providing the final answer.`;
    }
    if (options2.capabilities?.memory) {
      basePrompt += `

You have access to memory from previous interactions. Use this context to provide consistent and relevant responses.`;
    }
    if (options2.capabilities?.autonomous) {
      basePrompt += `

You can operate autonomously to achieve goals. When given a task, develop a plan, execute it step by step, and adapt as needed based on results and feedback.`;
    }
    if (options2.capabilities?.multiAgent) {
      basePrompt += `

You can coordinate with other agents to complete complex tasks. Consider which types of agents would be most suitable for different subtasks.`;
    }
    if (options2.capabilities?.supervisionRequired) {
      basePrompt += `

Your actions require human supervision. For critical decisions or when uncertain, explain your options and request user confirmation before proceeding.`;
    }
    if (options2.systemPrompt) {
      basePrompt += `

${options2.systemPrompt}`;
    }
    return basePrompt;
  }
  /**
   * Create default memory storage
   */
  createDefaultMemory() {
    return {
      conversations: [],
      context: {},
      addEntry(role, content2) {
        this.conversations.push({
          role,
          content: content2,
          timestamp: /* @__PURE__ */ new Date()
        });
      },
      getRecentConversation(limit = 10) {
        return this.conversations.slice(-limit).map((entry) => ({
          role: entry.role,
          content: entry.content
        }));
      },
      updateContext(key, value) {
        if (!this.context) {
          this.context = {};
        }
        this.context[key] = value;
      },
      getContext() {
        return this.context || {};
      }
    };
  }
};
var AgentFactory = class {
  /**
   * Create an agent by type
   */
  static createAgent(agentType, options2 = {}) {
    const type = typeof agentType === "string" ? agentType : agentType;
    switch (type) {
      case "assistant" /* ASSISTANT */:
        return this.createAssistant(options2);
      case "researcher" /* RESEARCHER */:
        return this.createResearcher(options2);
      case "analyzer" /* ANALYZER */:
        return this.createAnalyzer(options2);
      case "executor" /* EXECUTOR */:
        return this.createExecutor(options2);
      case "coordinator" /* COORDINATOR */:
        return this.createCoordinator(options2);
      case "specialist" /* SPECIALIST */:
        return this.createSpecialist(options2.specialization || "general", options2);
      case "autonomous" /* AUTONOMOUS */:
        return this.createAutonomous(options2);
      default:
        return this.createAssistant(options2);
    }
  }
  /**
   * Create a basic assistant agent
   */
  static createAssistant(options2 = {}) {
    return new Agent({
      agentType: "assistant" /* ASSISTANT */,
      capabilities: {
        multiStep: true,
        memory: true,
        ...options2.capabilities
      },
      systemPrompt: options2.systemPrompt,
      maxTokens: options2.maxTokens || 1024,
      temperature: options2.temperature || 0.7,
      tools: options2.tools,
      memory: options2.memory
    });
  }
  /**
   * Create a researcher agent
   */
  static createResearcher(options2 = {}) {
    return new Agent({
      agentType: "researcher" /* RESEARCHER */,
      capabilities: {
        multiStep: true,
        useTools: true,
        memory: true,
        ...options2.capabilities
      },
      systemPrompt: options2.systemPrompt,
      maxTokens: options2.maxTokens || 2048,
      temperature: options2.temperature || 0.3,
      tools: options2.tools,
      memory: options2.memory
    });
  }
  /**
   * Create an analyzer agent
   */
  static createAnalyzer(options2 = {}) {
    return new Agent({
      agentType: "analyzer" /* ANALYZER */,
      capabilities: {
        multiStep: true,
        useTools: true,
        memory: true,
        ...options2.capabilities
      },
      systemPrompt: options2.systemPrompt,
      maxTokens: options2.maxTokens || 2048,
      temperature: options2.temperature || 0.2,
      tools: options2.tools,
      memory: options2.memory
    });
  }
  /**
   * Create an executor agent
   */
  static createExecutor(options2 = {}) {
    return new Agent({
      agentType: "executor" /* EXECUTOR */,
      capabilities: {
        useTools: true,
        memory: true,
        ...options2.capabilities
      },
      systemPrompt: options2.systemPrompt,
      maxTokens: options2.maxTokens || 1024,
      temperature: options2.temperature || 0.2,
      tools: options2.tools,
      memory: options2.memory
    });
  }
  /**
   * Create a coordinator agent
   */
  static createCoordinator(options2 = {}) {
    return new Agent({
      agentType: "coordinator" /* COORDINATOR */,
      capabilities: {
        multiStep: true,
        useTools: true,
        memory: true,
        multiAgent: true,
        ...options2.capabilities
      },
      systemPrompt: options2.systemPrompt,
      maxTokens: options2.maxTokens || 2048,
      temperature: options2.temperature || 0.5,
      tools: options2.tools,
      memory: options2.memory
    });
  }
  /**
   * Create a specialist agent
   */
  static createSpecialist(specialization, options2 = {}) {
    return new Agent({
      agentType: "specialist" /* SPECIALIST */,
      capabilities: {
        multiStep: true,
        useTools: true,
        memory: true,
        specialization,
        ...options2.capabilities
      },
      systemPrompt: options2.systemPrompt,
      maxTokens: options2.maxTokens || 2048,
      temperature: options2.temperature || 0.4,
      tools: options2.tools,
      memory: options2.memory
    });
  }
  /**
   * Create an autonomous agent
   */
  static createAutonomous(options2 = {}) {
    return new Agent({
      agentType: "autonomous" /* AUTONOMOUS */,
      capabilities: {
        multiStep: true,
        useTools: true,
        memory: true,
        autonomous: true,
        ...options2.capabilities
      },
      systemPrompt: options2.systemPrompt,
      maxTokens: options2.maxTokens || 4096,
      temperature: options2.temperature || 0.6,
      tools: options2.tools,
      memory: options2.memory
    });
  }
};

// server/services/agent-toolkit.ts
import axios2 from "axios";
var AgentToolkit = class {
  /**
   * Get all available tools
   */
  static getAllTools() {
    return [
      this.getWebSearchTool(),
      this.getWebScraperTool(),
      this.getImageOCRTool(),
      this.getCalculatorTool(),
      this.getDateTimeTool(),
      this.getWeatherTool(),
      this.getNewsSearchTool()
    ];
  }
  /**
   * Get specific tools by name
   */
  static getTools(toolNames) {
    const allTools = this.getAllTools();
    return allTools.filter((tool) => toolNames.includes(tool.name));
  }
  /**
   * Web search tool
   */
  static getWebSearchTool() {
    return {
      name: "web_search",
      description: "Search the web for information on a given query",
      parameters: {
        query: {
          type: "string",
          description: "The search query",
          required: true
        },
        num_results: {
          type: "number",
          description: "Number of results to return (default: 5)",
          required: false
        }
      },
      execute: async (params2) => {
        const query2 = params2.query;
        const numResults = params2.num_results || 5;
        try {
          const dummyResults = [
            {
              title: `Result for ${query2} - 1`,
              url: `https://example.com/result1?q=${encodeURIComponent(query2)}`,
              snippet: `This is a sample result for the query "${query2}". It provides some information about the topic.`
            },
            {
              title: `Result for ${query2} - 2`,
              url: `https://example.com/result2?q=${encodeURIComponent(query2)}`,
              snippet: `Another result for "${query2}". This one has different information about the same topic.`
            },
            {
              title: `About ${query2} - Wikipedia`,
              url: `https://en.wikipedia.org/wiki/${encodeURIComponent(query2.replace(/\s+/g, "_"))}`,
              snippet: `${query2} refers to a concept or entity that has various aspects and characteristics.`
            }
          ];
          while (dummyResults.length < numResults) {
            const index2 = dummyResults.length + 1;
            dummyResults.push({
              title: `Result for ${query2} - ${index2}`,
              url: `https://example.com/result${index2}?q=${encodeURIComponent(query2)}`,
              snippet: `Additional information about "${query2}" covering different aspects of the topic.`
            });
          }
          return dummyResults.slice(0, numResults);
        } catch (error) {
          throw new Error(`Web search failed: ${error}`);
        }
      }
    };
  }
  /**
   * Web scraper tool
   */
  static getWebScraperTool() {
    return {
      name: "web_scraper",
      description: "Scrape content from a webpage",
      parameters: {
        url: {
          type: "string",
          description: "The URL to scrape",
          required: true
        },
        selectors: {
          type: "object",
          description: "CSS selectors to extract specific elements",
          required: false
        },
        site_type: {
          type: "string",
          description: "Type of site (generic, e_commerce, news, etc.)",
          required: false
        }
      },
      execute: async (params2) => {
        try {
          const url = params2.url;
          const selectors = params2.selectors || {};
          const siteType = params2.site_type || "generic" /* GENERIC */;
          const result2 = await ScraperService.scrape(url, {
            selectors,
            siteType
          });
          const resultWithText = {
            ...result2,
            text: result2.text || "",
            html: result2.text ? result2.text.substring(0, 1e3) + "... (truncated)" : "No text content extracted"
          };
          return resultWithText;
        } catch (error) {
          throw new Error(`Web scraping failed: ${error}`);
        }
      }
    };
  }
  /**
   * Image OCR tool
   */
  static getImageOCRTool() {
    return {
      name: "image_ocr",
      description: "Extract text from images using OCR",
      parameters: {
        image_url: {
          type: "string",
          description: "URL of the image to process",
          required: true
        },
        document_type: {
          type: "string",
          description: "Type of document (generic, invoice, receipt, etc.)",
          required: false
        },
        language: {
          type: "string",
          description: "Language code (e.g., eng, fra, deu)",
          required: false
        }
      },
      execute: async (params2) => {
        try {
          const imageUrl = params2.image_url;
          const documentType = params2.document_type || "generic" /* GENERIC */;
          const language = params2.language || "eng";
          const response = await axios2.get(imageUrl, { responseType: "arraybuffer" });
          const imageBuffer = Buffer.from(response.data);
          const result2 = await OCRService.processImage(imageBuffer, {
            documentType,
            language
          });
          return result2;
        } catch (error) {
          throw new Error(`OCR processing failed: ${error}`);
        }
      }
    };
  }
  /**
   * Calculator tool
   */
  static getCalculatorTool() {
    return {
      name: "calculator",
      description: "Perform mathematical calculations",
      parameters: {
        expression: {
          type: "string",
          description: "Mathematical expression to evaluate",
          required: true
        }
      },
      execute: async (params) => {
        try {
          const expression = params.expression;
          const result = eval(expression);
          return {
            expression,
            result
          };
        } catch (error) {
          throw new Error(`Calculator error: ${error}`);
        }
      }
    };
  }
  /**
   * Date and time tool
   */
  static getDateTimeTool() {
    return {
      name: "date_time",
      description: "Get current date and time information",
      parameters: {
        timezone: {
          type: "string",
          description: "Timezone (default: UTC)",
          required: false
        },
        format: {
          type: "string",
          description: "Date format",
          required: false
        }
      },
      execute: async (params2) => {
        try {
          const now = /* @__PURE__ */ new Date();
          return {
            iso: now.toISOString(),
            unix_timestamp: Math.floor(now.getTime() / 1e3),
            utc: now.toUTCString(),
            local: now.toString()
          };
        } catch (error) {
          throw new Error(`Date time error: ${error}`);
        }
      }
    };
  }
  /**
   * Weather tool
   */
  static getWeatherTool() {
    return {
      name: "weather",
      description: "Get weather information for a location",
      parameters: {
        location: {
          type: "string",
          description: "Location (city name or coordinates)",
          required: true
        },
        units: {
          type: "string",
          description: "Units (metric or imperial)",
          required: false
        }
      },
      execute: async (params2) => {
        try {
          const location = params2.location;
          const units = params2.units || "metric";
          const weatherConditions = [
            "Sunny",
            "Partly Cloudy",
            "Cloudy",
            "Rainy",
            "Thunderstorm",
            "Snowy",
            "Foggy",
            "Windy",
            "Clear"
          ];
          const randomCondition = weatherConditions[Math.floor(Math.random() * weatherConditions.length)];
          const temperature = units === "metric" ? Math.floor(Math.random() * 35) : Math.floor(Math.random() * 60 + 30);
          return {
            location,
            temperature: {
              value: temperature,
              unit: units === "metric" ? "C" : "F"
            },
            condition: randomCondition,
            humidity: Math.floor(Math.random() * 100),
            wind_speed: Math.floor(Math.random() * 30),
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          };
        } catch (error) {
          throw new Error(`Weather information error: ${error}`);
        }
      }
    };
  }
  /**
   * News search tool
   */
  static getNewsSearchTool() {
    return {
      name: "news_search",
      description: "Search for news articles on a topic",
      parameters: {
        query: {
          type: "string",
          description: "The search query",
          required: true
        },
        num_results: {
          type: "number",
          description: "Number of results to return (default: 5)",
          required: false
        },
        days_back: {
          type: "number",
          description: "How many days back to search (default: 7)",
          required: false
        }
      },
      execute: async (params2) => {
        try {
          const query2 = params2.query;
          const numResults = params2.num_results || 5;
          const daysBack = params2.days_back || 7;
          const currentDate = /* @__PURE__ */ new Date();
          const results = [];
          for (let i = 0; i < numResults; i++) {
            const daysAgo = Math.floor(Math.random() * daysBack);
            const date = new Date(currentDate);
            date.setDate(date.getDate() - daysAgo);
            results.push({
              title: `News about ${query2} - ${i + 1}`,
              url: `https://news-example.com/article${i + 1}?topic=${encodeURIComponent(query2)}`,
              source: `News Source ${i + 1}`,
              published_date: date.toISOString(),
              snippet: `This is a news article about "${query2}" published ${daysAgo} days ago.`
            });
          }
          return results;
        } catch (error) {
          throw new Error(`News search failed: ${error}`);
        }
      }
    };
  }
};

// server/services/integration.ts
import axios3 from "axios";
import * as querystring from "querystring";
var IntegrationType = /* @__PURE__ */ ((IntegrationType2) => {
  IntegrationType2["REST"] = "rest";
  IntegrationType2["GRAPHQL"] = "graphql";
  IntegrationType2["SOAP"] = "soap";
  IntegrationType2["WEBHOOK"] = "webhook";
  IntegrationType2["OAUTH"] = "oauth";
  return IntegrationType2;
})(IntegrationType || {});
var AuthType = /* @__PURE__ */ ((AuthType2) => {
  AuthType2["NONE"] = "none";
  AuthType2["API_KEY"] = "api_key";
  AuthType2["BASIC"] = "basic";
  AuthType2["BEARER"] = "bearer";
  AuthType2["OAUTH1"] = "oauth1";
  AuthType2["OAUTH2"] = "oauth2";
  AuthType2["CUSTOM"] = "custom";
  return AuthType2;
})(AuthType || {});
var IntegrationService = class {
  /**
   * Execute an API request
   */
  static async executeRequest(config, options2) {
    const startTime2 = Date.now();
    try {
      const requestConfig = {
        url: this.buildUrl(config.baseUrl, options2.endpoint),
        method: options2.method || "GET" /* GET */,
        headers: {
          ...this.getDefaultHeaders(options2.contentType || "application/json" /* JSON */),
          ...config.headers,
          ...options2.headers
        },
        timeout: options2.timeout || config.timeout || 3e4,
        params: {
          ...config.defaultParams,
          ...options2.params
        }
      };
      this.applyAuthentication(requestConfig, config.auth);
      if (options2.method !== "GET" /* GET */ && options2.data) {
        if (options2.contentType === "application/x-www-form-urlencoded" /* FORM */) {
          requestConfig.data = querystring.stringify(options2.data);
        } else {
          requestConfig.data = options2.data;
        }
      }
      const response = await axios3(requestConfig);
      const endTime = Date.now();
      const apiResponse = {
        status: response.status,
        statusText: response.statusText,
        data: response.data,
        headers: response.headers,
        timing: {
          start: startTime2,
          end: endTime,
          duration: endTime - startTime2
        }
      };
      return apiResponse;
    } catch (error) {
      if (error.response) {
        const endTime = Date.now();
        return {
          status: error.response.status,
          statusText: error.response.statusText,
          data: error.response.data,
          headers: error.response.headers,
          timing: {
            start: startTime2,
            end: endTime,
            duration: endTime - startTime2
          }
        };
      } else if (error.request) {
        log(`API request error: ${error.message}`, "integration");
        throw new Error(`API request failed: ${error.message}`);
      } else {
        log(`API configuration error: ${error.message}`, "integration");
        throw new Error(`API configuration error: ${error.message}`);
      }
    }
  }
  /**
   * Execute a GraphQL request
   */
  static async executeGraphQLRequest(config, query2, variables, operationName) {
    if (config.type !== "graphql" /* GRAPHQL */) {
      throw new Error("Integration type must be GraphQL");
    }
    const options2 = {
      endpoint: "",
      method: "POST" /* POST */,
      data: {
        query: query2,
        variables,
        operationName
      },
      contentType: "application/json" /* JSON */
    };
    return this.executeRequest(config, options2);
  }
  /**
   * Register a webhook endpoint
   */
  static async registerWebhook(config, endpoint, events, secret) {
    if (config.type !== "webhook" /* WEBHOOK */) {
      throw new Error("Integration type must be Webhook");
    }
    log(`Registering webhook for ${config.name} at ${endpoint}`, "integration");
    return {
      success: true,
      message: "Webhook registered successfully",
      webhookId: `wh_${Math.random().toString(36).substr(2, 9)}`
    };
  }
  /**
   * Validate a webhook request
   */
  static validateWebhookRequest(config, payload, headers) {
    if (!config.webhookConfig || !config.webhookConfig.secret) {
      return true;
    }
    log(`Validating webhook for ${config.name}`, "integration");
    return true;
  }
  /**
   * Build the full URL for a request
   */
  static buildUrl(baseUrl, endpoint) {
    if (baseUrl.endsWith("/")) {
      baseUrl = baseUrl.slice(0, -1);
    }
    if (endpoint.startsWith("/")) {
      endpoint = endpoint.slice(1);
    }
    return `${baseUrl}/${endpoint}`;
  }
  /**
   * Get default headers based on content type
   */
  static getDefaultHeaders(contentType) {
    const headers = {
      "Accept": "application/json",
      "Content-Type": contentType
    };
    return headers;
  }
  /**
   * Apply authentication to the request config
   */
  static applyAuthentication(requestConfig, auth) {
    switch (auth.type) {
      case "none" /* NONE */:
        break;
      case "api_key" /* API_KEY */:
        if (auth.credentials?.apiKey && auth.credentials?.apiKeyName) {
          if (auth.credentials.in === "header") {
            requestConfig.headers = requestConfig.headers || {};
            requestConfig.headers[auth.credentials.apiKeyName] = auth.credentials.apiKey;
          } else {
            requestConfig.params = requestConfig.params || {};
            requestConfig.params[auth.credentials.apiKeyName] = auth.credentials.apiKey;
          }
        }
        break;
      case "basic" /* BASIC */:
        if (auth.credentials?.username && auth.credentials?.password) {
          requestConfig.auth = {
            username: auth.credentials.username,
            password: auth.credentials.password
          };
        }
        break;
      case "bearer" /* BEARER */:
        if (auth.credentials?.token) {
          requestConfig.headers = requestConfig.headers || {};
          requestConfig.headers["Authorization"] = `Bearer ${auth.credentials.token}`;
        }
        break;
      case "oauth2" /* OAUTH2 */:
        if (auth.oauth?.accessToken) {
          requestConfig.headers = requestConfig.headers || {};
          requestConfig.headers["Authorization"] = `Bearer ${auth.oauth.accessToken}`;
        }
        break;
      case "custom" /* CUSTOM */:
        if (auth.credentials) {
          Object.entries(auth.credentials).forEach(([key, value]) => {
            if (key.startsWith("header:")) {
              const headerName = key.substring(7);
              requestConfig.headers = requestConfig.headers || {};
              requestConfig.headers[headerName] = value;
            } else if (key.startsWith("param:")) {
              const paramName = key.substring(6);
              requestConfig.params = requestConfig.params || {};
              requestConfig.params[paramName] = value;
            }
          });
        }
        break;
      default:
        log(`Unsupported auth type: ${auth.type}`, "integration");
    }
  }
  /**
   * Refresh OAuth2 token
   */
  static async refreshOAuth2Token(config) {
    if (config.auth.type !== "oauth2" /* OAUTH2 */ || !config.auth.oauth?.refreshToken || !config.auth.oauth?.clientId || !config.auth.oauth?.clientSecret || !config.auth.oauth?.tokenUrl) {
      return null;
    }
    try {
      const response = await axios3({
        method: "POST",
        url: config.auth.oauth.tokenUrl,
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          "Accept": "application/json"
        },
        data: querystring.stringify({
          grant_type: "refresh_token",
          refresh_token: config.auth.oauth.refreshToken,
          client_id: config.auth.oauth.clientId,
          client_secret: config.auth.oauth.clientSecret
        })
      });
      const data = response.data;
      const expiresIn = data.expires_in || 3600;
      const expiresAt = Date.now() + expiresIn * 1e3;
      return {
        accessToken: data.access_token,
        refreshToken: data.refresh_token || config.auth.oauth.refreshToken,
        expiresAt
      };
    } catch (error) {
      log(`Failed to refresh OAuth2 token: ${error}`, "integration");
      return null;
    }
  }
};
var OAuth2Service = class {
  /**
   * Generate OAuth2 authorization URL
   */
  static getAuthorizationUrl(config, redirectUri, state, scope) {
    if (config.auth.type !== "oauth2" /* OAUTH2 */ || !config.auth.oauth?.clientId || !config.auth.oauth?.authorizationUrl) {
      return null;
    }
    const params2 = new URLSearchParams({
      response_type: "code",
      client_id: config.auth.oauth.clientId,
      redirect_uri: redirectUri,
      state
    });
    if (scope || config.auth.oauth.scope) {
      params2.append("scope", scope || config.auth.oauth.scope);
    }
    return `${config.auth.oauth.authorizationUrl}?${params2.toString()}`;
  }
  /**
   * Exchange authorization code for tokens
   */
  static async exchangeCodeForTokens(config, code, redirectUri) {
    if (config.auth.type !== "oauth2" /* OAUTH2 */ || !config.auth.oauth?.clientId || !config.auth.oauth?.clientSecret || !config.auth.oauth?.tokenUrl) {
      return null;
    }
    try {
      const response = await axios3({
        method: "POST",
        url: config.auth.oauth.tokenUrl,
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          "Accept": "application/json"
        },
        data: querystring.stringify({
          grant_type: "authorization_code",
          code,
          client_id: config.auth.oauth.clientId,
          client_secret: config.auth.oauth.clientSecret,
          redirect_uri: redirectUri
        })
      });
      const data = response.data;
      const expiresIn = data.expires_in || 3600;
      const expiresAt = Date.now() + expiresIn * 1e3;
      return {
        accessToken: data.access_token,
        refreshToken: data.refresh_token,
        expiresAt
      };
    } catch (error) {
      log(`Failed to exchange code for token: ${error}`, "integration");
      return null;
    }
  }
};

// server/services/social/SocialMonitoringService.ts
import { eq as eq3, and as and2, desc as desc2 } from "drizzle-orm";

// server/services/social/BaseSocialConnector.ts
import { eq as eq2 } from "drizzle-orm";
var BaseSocialConnector = class {
  userId;
  config;
  id;
  name;
  platform;
  constructor(userId, config, id) {
    this.userId = userId;
    this.config = config;
    this.id = id;
    this.name = config.name || "";
    this.platform = this.getPlatform();
  }
  /**
   * Get connector name
   */
  getName() {
    return this.name;
  }
  /**
   * Save connector to database
   */
  async save() {
    const storableConfig = this.getSanitizedConfig();
    if (this.id) {
      const [updated] = await db.update(socialConnectors).set({
        name: this.name,
        platform: this.platform,
        credentials: storableConfig,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq2(socialConnectors.id, this.id)).returning();
      return updated;
    } else {
      const [created] = await db.insert(socialConnectors).values({
        userId: this.userId,
        name: this.name,
        platform: this.platform,
        credentials: storableConfig,
        isActive: true,
        metadata: {}
      }).returning();
      this.id = created.id;
      return created;
    }
  }
  /**
   * Create a sanitized copy of config for storage
   * Removes sensitive fields that shouldn't be stored directly
   */
  getSanitizedConfig() {
    const { apiSecret, clientSecret, password, ...safeConfig } = this.config;
    return safeConfig;
  }
  /**
   * Get config value safely
   */
  getConfigValue(key, defaultValue) {
    return this.config[key] || defaultValue;
  }
};

// server/services/social/TwitterConnector.ts
var TwitterConnector = class _TwitterConnector extends BaseSocialConnector {
  static PLATFORM = "twitter";
  bearerToken;
  /**
   * Authenticate with Twitter/X API
   */
  async authenticate() {
    try {
      this.bearerToken = this.getConfigValue("bearerToken");
      if (!this.bearerToken) {
        console.warn("No Twitter/X bearerToken provided, authentication will likely fail");
      }
      return !!this.bearerToken;
    } catch (error) {
      console.error("Error authenticating with Twitter/X:", error);
      return false;
    }
  }
  /**
   * Check if the connector is authenticated
   */
  async isAuthenticated() {
    return !!this.bearerToken;
  }
  /**
   * Refresh authentication if needed
   */
  async refreshAuth() {
    try {
      return await this.authenticate();
    } catch (error) {
      console.error("Error refreshing Twitter/X authentication:", error);
      return false;
    }
  }
  /**
   * Search for tweets based on keywords
   */
  async search(options2) {
    try {
      if (!await this.isAuthenticated()) {
        if (!await this.refreshAuth()) {
          throw new Error("Twitter/X authentication failed");
        }
      }
      console.log(`[DEMO] Searching Twitter/X for keywords: ${options2.keywords.join(", ")}`);
      return [];
    } catch (error) {
      console.error("Error searching Twitter/X:", error);
      return [];
    }
  }
  /**
   * Get user profile from Twitter/X
   */
  async getUserProfile(username) {
    try {
      if (!await this.isAuthenticated()) {
        if (!await this.refreshAuth()) {
          throw new Error("Twitter/X authentication failed");
        }
      }
      console.log(`[DEMO] Getting Twitter/X profile for: ${username}`);
      return {};
    } catch (error) {
      console.error(`Error getting Twitter/X profile for ${username}:`, error);
      return {};
    }
  }
  /**
   * Get followers of a user
   */
  async getFollowers(username, limit = 100) {
    try {
      if (!await this.isAuthenticated()) {
        if (!await this.refreshAuth()) {
          throw new Error("Twitter/X authentication failed");
        }
      }
      console.log(`[DEMO] Getting Twitter/X followers for: ${username}, limit: ${limit}`);
      return [];
    } catch (error) {
      console.error(`Error getting Twitter/X followers for ${username}:`, error);
      return [];
    }
  }
  /**
   * Start monitoring based on options
   */
  async startMonitoring(options2) {
    try {
      if (!await this.isAuthenticated()) {
        if (!await this.refreshAuth()) {
          throw new Error("Twitter/X authentication failed");
        }
      }
      console.log(`[DEMO] Starting Twitter/X monitoring for keywords: ${options2.keywords.join(", ")}`);
      return { monitorId: `twitter-monitor-${Date.now()}` };
    } catch (error) {
      console.error("Error starting Twitter/X monitoring:", error);
      throw error;
    }
  }
  /**
   * Stop an active monitoring process
   */
  async stopMonitoring(monitorId) {
    try {
      console.log(`[DEMO] Stopping Twitter/X monitoring: ${monitorId}`);
      return true;
    } catch (error) {
      console.error(`Error stopping Twitter/X monitoring ${monitorId}:`, error);
      return false;
    }
  }
  /**
   * Get results from a monitoring process
   */
  async getMonitorResults(monitorId) {
    try {
      console.log(`[DEMO] Getting Twitter/X monitoring results: ${monitorId}`);
      return [];
    } catch (error) {
      console.error(`Error getting Twitter/X monitoring results ${monitorId}:`, error);
      return [];
    }
  }
  /**
   * Get platform name
   */
  getPlatform() {
    return _TwitterConnector.PLATFORM;
  }
};

// server/services/social/LinkedInConnector.ts
var LinkedInConnector = class _LinkedInConnector extends BaseSocialConnector {
  static PLATFORM = "linkedin";
  accessToken;
  /**
   * Authenticate with LinkedIn API
   */
  async authenticate() {
    try {
      this.accessToken = this.getConfigValue("accessToken");
      if (!this.accessToken) {
        console.warn("No LinkedIn accessToken provided, authentication will likely fail");
      }
      return !!this.accessToken;
    } catch (error) {
      console.error("Error authenticating with LinkedIn:", error);
      return false;
    }
  }
  /**
   * Check if the connector is authenticated
   */
  async isAuthenticated() {
    return !!this.accessToken;
  }
  /**
   * Refresh authentication if needed
   */
  async refreshAuth() {
    try {
      return await this.authenticate();
    } catch (error) {
      console.error("Error refreshing LinkedIn authentication:", error);
      return false;
    }
  }
  /**
   * Search for posts based on keywords
   */
  async search(options2) {
    try {
      if (!await this.isAuthenticated()) {
        if (!await this.refreshAuth()) {
          throw new Error("LinkedIn authentication failed");
        }
      }
      console.log(`[DEMO] Searching LinkedIn for keywords: ${options2.keywords.join(", ")}`);
      return [];
    } catch (error) {
      console.error("Error searching LinkedIn:", error);
      return [];
    }
  }
  /**
   * Get user profile from LinkedIn
   */
  async getUserProfile(username) {
    try {
      if (!await this.isAuthenticated()) {
        if (!await this.refreshAuth()) {
          throw new Error("LinkedIn authentication failed");
        }
      }
      console.log(`[DEMO] Getting LinkedIn profile for: ${username}`);
      return {};
    } catch (error) {
      console.error(`Error getting LinkedIn profile for ${username}:`, error);
      return {};
    }
  }
  /**
   * Get followers/connections of a user
   */
  async getFollowers(username, limit = 100) {
    try {
      if (!await this.isAuthenticated()) {
        if (!await this.refreshAuth()) {
          throw new Error("LinkedIn authentication failed");
        }
      }
      console.log(`[DEMO] Getting LinkedIn connections for: ${username}, limit: ${limit}`);
      return [];
    } catch (error) {
      console.error(`Error getting LinkedIn connections for ${username}:`, error);
      return [];
    }
  }
  /**
   * Start monitoring based on options
   */
  async startMonitoring(options2) {
    try {
      if (!await this.isAuthenticated()) {
        if (!await this.refreshAuth()) {
          throw new Error("LinkedIn authentication failed");
        }
      }
      console.log(`[DEMO] Starting LinkedIn monitoring for keywords: ${options2.keywords.join(", ")}`);
      return { monitorId: `linkedin-monitor-${Date.now()}` };
    } catch (error) {
      console.error("Error starting LinkedIn monitoring:", error);
      throw error;
    }
  }
  /**
   * Stop an active monitoring process
   */
  async stopMonitoring(monitorId) {
    try {
      console.log(`[DEMO] Stopping LinkedIn monitoring: ${monitorId}`);
      return true;
    } catch (error) {
      console.error(`Error stopping LinkedIn monitoring ${monitorId}:`, error);
      return false;
    }
  }
  /**
   * Get results from a monitoring process
   */
  async getMonitorResults(monitorId) {
    try {
      console.log(`[DEMO] Getting LinkedIn monitoring results: ${monitorId}`);
      return [];
    } catch (error) {
      console.error(`Error getting LinkedIn monitoring results ${monitorId}:`, error);
      return [];
    }
  }
  /**
   * Get platform name
   */
  getPlatform() {
    return _LinkedInConnector.PLATFORM;
  }
};

// server/services/social/FacebookConnector.ts
var FacebookConnector = class _FacebookConnector extends BaseSocialConnector {
  static PLATFORM = "facebook";
  accessToken;
  /**
   * Authenticate with Facebook API
   */
  async authenticate() {
    try {
      this.accessToken = this.getConfigValue("accessToken");
      if (!this.accessToken) {
        console.warn("No Facebook accessToken provided, authentication will likely fail");
      }
      return !!this.accessToken;
    } catch (error) {
      console.error("Error authenticating with Facebook:", error);
      return false;
    }
  }
  /**
   * Check if the connector is authenticated
   */
  async isAuthenticated() {
    return !!this.accessToken;
  }
  /**
   * Refresh authentication if needed
   */
  async refreshAuth() {
    try {
      return await this.authenticate();
    } catch (error) {
      console.error("Error refreshing Facebook authentication:", error);
      return false;
    }
  }
  /**
   * Search for posts based on keywords
   */
  async search(options2) {
    try {
      if (!await this.isAuthenticated()) {
        if (!await this.refreshAuth()) {
          throw new Error("Facebook authentication failed");
        }
      }
      console.log(`[DEMO] Searching Facebook for keywords: ${options2.keywords.join(", ")}`);
      return [];
    } catch (error) {
      console.error("Error searching Facebook:", error);
      return [];
    }
  }
  /**
   * Get user profile from Facebook
   */
  async getUserProfile(username) {
    try {
      if (!await this.isAuthenticated()) {
        if (!await this.refreshAuth()) {
          throw new Error("Facebook authentication failed");
        }
      }
      console.log(`[DEMO] Getting Facebook profile for: ${username}`);
      return {};
    } catch (error) {
      console.error(`Error getting Facebook profile for ${username}:`, error);
      return {};
    }
  }
  /**
   * Get followers/friends of a user
   */
  async getFollowers(username, limit = 100) {
    try {
      if (!await this.isAuthenticated()) {
        if (!await this.refreshAuth()) {
          throw new Error("Facebook authentication failed");
        }
      }
      console.log(`[DEMO] Getting Facebook friends for: ${username}, limit: ${limit}`);
      return [];
    } catch (error) {
      console.error(`Error getting Facebook friends for ${username}:`, error);
      return [];
    }
  }
  /**
   * Start monitoring based on options
   */
  async startMonitoring(options2) {
    try {
      if (!await this.isAuthenticated()) {
        if (!await this.refreshAuth()) {
          throw new Error("Facebook authentication failed");
        }
      }
      console.log(`[DEMO] Starting Facebook monitoring for keywords: ${options2.keywords.join(", ")}`);
      return { monitorId: `facebook-monitor-${Date.now()}` };
    } catch (error) {
      console.error("Error starting Facebook monitoring:", error);
      throw error;
    }
  }
  /**
   * Stop an active monitoring process
   */
  async stopMonitoring(monitorId) {
    try {
      console.log(`[DEMO] Stopping Facebook monitoring: ${monitorId}`);
      return true;
    } catch (error) {
      console.error(`Error stopping Facebook monitoring ${monitorId}:`, error);
      return false;
    }
  }
  /**
   * Get results from a monitoring process
   */
  async getMonitorResults(monitorId) {
    try {
      console.log(`[DEMO] Getting Facebook monitoring results: ${monitorId}`);
      return [];
    } catch (error) {
      console.error(`Error getting Facebook monitoring results ${monitorId}:`, error);
      return [];
    }
  }
  /**
   * Get platform name
   */
  getPlatform() {
    return _FacebookConnector.PLATFORM;
  }
};

// server/services/social/SocialMonitoringService.ts
import { v4 as uuidv4 } from "uuid";
var SocialMonitoringService = class {
  userId;
  connectors = /* @__PURE__ */ new Map();
  constructor(userId) {
    this.userId = userId || 0;
  }
  /**
   * Set the user ID for the service
   */
  setUserId(userId) {
    this.userId = userId;
  }
  /**
   * Initialize the service by loading all user connectors
   */
  async initialize() {
    try {
      const connectorModels = await db.select().from(socialConnectors).where(eq3(socialConnectors.userId, this.userId));
      for (const connectorModel of connectorModels) {
        const connector = await this.loadConnector(connectorModel);
        if (connector) {
          this.connectors.set(connectorModel.id, connector);
        }
      }
    } catch (error) {
      console.error("Error initializing SocialMonitoringService:", error);
      throw error;
    }
  }
  /**
   * Create a new social media connector
   */
  async createConnector(platform, name, config) {
    try {
      let connector;
      switch (platform) {
        case "twitter":
        case "x":
          connector = new TwitterConnector(this.userId, { ...config, name });
          break;
        case "linkedin":
          connector = new LinkedInConnector(this.userId, { ...config, name });
          break;
        case "facebook":
          connector = new FacebookConnector(this.userId, { ...config, name });
          break;
        default:
          throw new Error(`Unsupported platform: ${platform}`);
      }
      const isAuth = await connector.authenticate();
      if (!isAuth) {
        throw new Error(`Authentication failed for ${platform} connector`);
      }
      const savedConnector = await connector.save();
      this.connectors.set(savedConnector.id, connector);
      return connector;
    } catch (error) {
      console.error(`Error creating ${platform} connector:`, error);
      throw error;
    }
  }
  /**
   * Get all social connectors for the user
   */
  async getConnectors() {
    try {
      return await db.select().from(socialConnectors).where(eq3(socialConnectors.userId, this.userId));
    } catch (error) {
      console.error("Error getting social connectors:", error);
      throw error;
    }
  }
  /**
   * Get a specific connector by ID
   */
  async getConnector(connectorId) {
    if (this.connectors.has(connectorId)) {
      return this.connectors.get(connectorId);
    }
    const connectorModel = await db.select().from(socialConnectors).where(and2(
      eq3(socialConnectors.id, connectorId),
      eq3(socialConnectors.userId, this.userId)
    )).then((rows) => rows[0]);
    if (!connectorModel) {
      throw new Error(`Connector with ID ${connectorId} not found or access denied`);
    }
    const connector = await this.loadConnector(connectorModel);
    if (!connector) {
      throw new Error(`Failed to instantiate connector with ID ${connectorId}`);
    }
    this.connectors.set(connectorId, connector);
    return connector;
  }
  /**
   * Delete a connector
   */
  async deleteConnector(connectorId) {
    try {
      const connector = await db.select().from(socialConnectors).where(and2(
        eq3(socialConnectors.id, connectorId),
        eq3(socialConnectors.userId, this.userId)
      )).then((rows) => rows[0]);
      if (!connector) {
        throw new Error(`Connector with ID ${connectorId} not found or access denied`);
      }
      await db.delete(socialConnectors).where(eq3(socialConnectors.id, connectorId));
      this.connectors.delete(connectorId);
      return true;
    } catch (error) {
      console.error(`Error deleting connector ${connectorId}:`, error);
      throw error;
    }
  }
  /**
   * Create a new social media monitor
   */
  async createMonitor(name, description, platforms, keywords, accounts, frequency, alertThreshold) {
    try {
      const monitor = {
        name,
        description,
        userId: this.userId,
        platforms,
        keywords,
        accounts,
        frequency,
        alertThreshold,
        isActive: true
      };
      const [createdMonitor] = await db.insert(socialMonitors).values(monitor).returning();
      return createdMonitor;
    } catch (error) {
      console.error("Error creating social monitor:", error);
      throw error;
    }
  }
  /**
   * Get all monitors for the user
   */
  async getMonitors() {
    try {
      return await db.select().from(socialMonitors).where(eq3(socialMonitors.userId, this.userId));
    } catch (error) {
      console.error("Error getting social monitors:", error);
      throw error;
    }
  }
  /**
   * Get a specific monitor
   */
  async getMonitor(monitorId) {
    try {
      const [monitor] = await db.select().from(socialMonitors).where(and2(
        eq3(socialMonitors.id, monitorId),
        eq3(socialMonitors.userId, this.userId)
      ));
      if (!monitor) {
        throw new Error(`Monitor with ID ${monitorId} not found or access denied`);
      }
      return monitor;
    } catch (error) {
      console.error(`Error getting monitor ${monitorId}:`, error);
      throw error;
    }
  }
  /**
   * Update a monitor
   */
  async updateMonitor(monitorId, updates) {
    try {
      const monitor = await this.getMonitor(monitorId);
      const [updatedMonitor] = await db.update(socialMonitors).set({
        ...updates,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq3(socialMonitors.id, monitorId)).returning();
      return updatedMonitor;
    } catch (error) {
      console.error(`Error updating monitor ${monitorId}:`, error);
      throw error;
    }
  }
  /**
   * Delete a monitor
   */
  async deleteMonitor(monitorId) {
    try {
      const monitor = await this.getMonitor(monitorId);
      await db.delete(socialMonitors).where(eq3(socialMonitors.id, monitorId));
      return true;
    } catch (error) {
      console.error(`Error deleting monitor ${monitorId}:`, error);
      throw error;
    }
  }
  /**
   * Get monitor results
   */
  async getMonitorResults(monitorId, limit = 100) {
    try {
      const monitor = await this.getMonitor(monitorId);
      return await db.select().from(monitorResults).where(eq3(monitorResults.monitorId, monitorId)).orderBy(desc2(monitorResults.timestamp)).limit(limit);
    } catch (error) {
      console.error(`Error getting results for monitor ${monitorId}:`, error);
      throw error;
    }
  }
  /**
   * Get monitor alerts
   */
  async getMonitorAlerts(monitorId, limit = 100) {
    try {
      const monitor = await this.getMonitor(monitorId);
      return await db.select().from(socialAlerts).where(eq3(socialAlerts.monitorId, monitorId)).orderBy(desc2(socialAlerts.timestamp)).limit(limit);
    } catch (error) {
      console.error(`Error getting alerts for monitor ${monitorId}:`, error);
      throw error;
    }
  }
  /**
   * Mark an alert as read
   */
  async markAlertRead(alertId) {
    try {
      const [alert] = await db.select({
        alert: socialAlerts,
        monitor: socialMonitors
      }).from(socialAlerts).innerJoin(
        socialMonitors,
        eq3(socialAlerts.monitorId, socialMonitors.id)
      ).where(and2(
        eq3(socialAlerts.id, alertId),
        eq3(socialMonitors.userId, this.userId)
      ));
      if (!alert) {
        throw new Error(`Alert with ID ${alertId} not found or access denied`);
      }
      await db.update(socialAlerts).set({ isRead: true }).where(eq3(socialAlerts.id, alertId));
      return true;
    } catch (error) {
      console.error(`Error marking alert ${alertId} as read:`, error);
      throw error;
    }
  }
  /**
   * Search across all platforms
   */
  async search(options2) {
    try {
      const connectors = await this.getConnectors();
      const allResults = [];
      for (const connector of connectors) {
        try {
          const connectorInstance = await this.getConnector(connector.id);
          const results = await connectorInstance.search(options2);
          allResults.push(...results);
        } catch (error) {
          console.error(`Error searching with connector ${connector.id}:`, error);
        }
      }
      return allResults;
    } catch (error) {
      console.error("Error searching across platforms:", error);
      throw error;
    }
  }
  /**
   * Analyze sentiment on text
   */
  async analyzeSentiment(text2) {
    try {
      return {
        positive: Math.random(),
        neutral: Math.random(),
        negative: Math.random(),
        compound: Math.random() * 2 - 1
        // Between -1 and 1
      };
    } catch (error) {
      console.error("Error analyzing sentiment:", error);
      throw error;
    }
  }
  async loadConnector(connectorModel) {
    let connector;
    try {
      const config = {
        ...connectorModel.credentials,
        name: connectorModel.name
      };
      switch (connectorModel.platform) {
        case "twitter":
        case "x":
          connector = new TwitterConnector(this.userId, config, connectorModel.id);
          break;
        case "linkedin":
          connector = new LinkedInConnector(this.userId, config, connectorModel.id);
          break;
        case "facebook":
          connector = new FacebookConnector(this.userId, config, connectorModel.id);
          break;
        default:
          throw new Error(`Unsupported platform: ${connectorModel.platform}`);
      }
      return connector;
    } catch (error) {
      console.error(`Error loading connector ${connectorModel.id}:`, error);
      throw error;
    }
  }
  /**
   * Start monitoring on all platforms for a monitor
   */
  async startMonitoringPlatforms(monitorId, options2) {
    const runId = uuidv4();
    let posts = [];
    let postCount = 0;
    let mentionCount = 0;
    try {
      const monitor = await this.getMonitor(monitorId);
      const connectors = await db.select().from(socialConnectors).where(and2(
        eq3(socialConnectors.userId, this.userId),
        eq3(socialConnectors.isActive, true)
      ));
      const relevantConnectors = connectors.filter(
        (c) => monitor.platforms.includes(c.platform)
      );
      for (const connector of relevantConnectors) {
        try {
          const connectorInstance = await this.getConnector(connector.id);
          const results = await connectorInstance.search({
            keywords: monitor.keywords,
            limit: 100
            // Add other search options as needed
          });
          posts = [...posts, ...results];
          postCount += results.length;
          if (monitor.accounts) {
            const accountMentions = results.filter(
              (post) => monitor.accounts.some(
                (account) => post.content.toLowerCase().includes(account.toLowerCase())
              )
            );
            mentionCount += accountMentions.length;
          }
        } catch (error) {
          console.error(`Error monitoring with connector ${connector.id}:`, error);
        }
      }
      const analyzedPosts = await this.analyzePosts(posts, monitor.keywords);
      await this.saveMonitorResults(monitorId, runId, analyzedPosts, postCount, mentionCount);
      if (monitor.alertThreshold) {
        await this.generateAlerts(monitorId, analyzedPosts, monitor.alertThreshold);
      }
      await db.update(socialMonitors).set({
        lastRunAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq3(socialMonitors.id, monitorId));
    } catch (error) {
      console.error(`Error in monitoring platforms for monitor ${monitorId}:`, error);
      throw error;
    }
  }
  /**
   * Analyze posts for keyword matches and sentiment
   */
  async analyzePosts(posts, keywords) {
    return await Promise.all(posts.map(async (post) => {
      const keywordMatches = keywords.filter(
        (keyword) => post.content.toLowerCase().includes(keyword.toLowerCase())
      );
      const relevanceScore = Math.min(100, keywordMatches.length / keywords.length * 100);
      const sentiment = await this.analyzeSentiment(post.content);
      return {
        ...post,
        keywordMatches,
        relevanceScore,
        sentiment
      };
    }));
  }
  /**
   * Save monitor results to database
   */
  async saveMonitorResults(monitorId, runId, analyzedPosts, postCount, mentionCount) {
    try {
      const keywordMatchCounts = analyzedPosts.reduce((acc, post) => {
        post.keywordMatches.forEach((keyword) => {
          acc[keyword] = (acc[keyword] || 0) + 1;
        });
        return acc;
      }, {});
      const totalSentiment = analyzedPosts.reduce(
        (acc, post) => {
          acc.positive += post.sentiment.positive;
          acc.neutral += post.sentiment.neutral;
          acc.negative += post.sentiment.negative;
          acc.compound += post.sentiment.compound;
          return acc;
        },
        { positive: 0, neutral: 0, negative: 0, compound: 0 }
      );
      const avgSentiment = {
        positive: analyzedPosts.length ? totalSentiment.positive / analyzedPosts.length : 0,
        neutral: analyzedPosts.length ? totalSentiment.neutral / analyzedPosts.length : 0,
        negative: analyzedPosts.length ? totalSentiment.negative / analyzedPosts.length : 0,
        compound: analyzedPosts.length ? totalSentiment.compound / analyzedPosts.length : 0
      };
      const result2 = {
        monitorId,
        runId,
        postCount,
        mentionCount,
        keywordMatches: keywordMatchCounts,
        sentimentAnalysis: avgSentiment,
        data: analyzedPosts
      };
      const [savedResult] = await db.insert(monitorResults).values(result2).returning();
      return savedResult;
    } catch (error) {
      console.error(`Error saving monitor results for monitor ${monitorId}:`, error);
      throw error;
    }
  }
  /**
   * Generate alerts for high-relevance posts
   */
  async generateAlerts(monitorId, analyzedPosts, threshold) {
    try {
      const highRelevancePosts = analyzedPosts.filter(
        (post) => post.relevanceScore >= threshold
      );
      for (const post of highRelevancePosts) {
        const alert = {
          monitorId,
          platform: post.platform,
          content: post.content,
          url: post.url,
          keywords: post.keywordMatches,
          score: Math.round(post.relevanceScore),
          metadata: post.metadata,
          isRead: false
        };
        await db.insert(socialAlerts).values(alert);
      }
    } catch (error) {
      console.error(`Error generating alerts for monitor ${monitorId}:`, error);
      throw error;
    }
  }
};

// server/services/recommendation-engine.ts
import Anthropic2 from "@anthropic-ai/sdk";
var anthropic2 = new Anthropic2({
  apiKey: process.env.ANTHROPIC_API_KEY
});
var RecommendationEngine = class {
  /**
   * Generate personalized workflow recommendations for a user
   */
  async generatePersonalRecommendations(input2) {
    try {
      const { userId, orgId, templates, userProfile } = input2;
      const recentActivitiesStr = JSON.stringify(userProfile.recentActivities, null, 2);
      const frequentCategoriesStr = userProfile.frequentCategories ? JSON.stringify(userProfile.frequentCategories) : "[]";
      const frequentTemplatesStr = userProfile.frequentTemplates ? JSON.stringify(userProfile.frequentTemplates) : "[]";
      const templatesStr = JSON.stringify(templates.map((t) => ({
        id: t.id,
        name: t.name,
        category: t.category,
        description: t.description || ""
      })), null, 2);
      const systemPrompt = `You are a workflow recommendation engine for SynthralOS, an AI workflow automation platform. 
Based on a user's activity and preferences, you'll suggest workflow templates that would be valuable to them.
Analyze the user's activity patterns and generate personalized recommendations.`;
      const userPrompt = `
I need personalized workflow recommendations for a user based on their activity profile:

# User Profile
- Recent activities: ${recentActivitiesStr}
- Frequent workflow categories: ${frequentCategoriesStr}
- Frequent templates used: ${frequentTemplatesStr}
- Total workflows created: ${userProfile.totalWorkflows || 0}
- Total executions run: ${userProfile.totalExecutions || 0}

# Available Templates
${templatesStr}

Generate 3-5 personalized workflow recommendations for this user. Each recommendation should include:
1. A title (short and descriptive)
2. A detailed reason why this would be valuable to the user based on their activity
3. A brief description of what the workflow will help them accomplish
4. A list of template IDs that would be useful for this workflow
5. A list of categories this workflow falls under
6. A recommendation score (0-100) based on how strongly you think this matches their needs

Format your response as a JSON array where each recommendation has these properties:
\`\`\`json
[
  {
    "title": "string",
    "reason": "string",
    "description": "string",
    "templates": [number],
    "categories": [string],
    "score": number
  }
]
\`\`\``;
      const response = await anthropic2.messages.create({
        model: "claude-3-7-sonnet-20250219",
        max_tokens: 2e3,
        temperature: 0.3,
        system: systemPrompt,
        messages: [{ role: "user", content: userPrompt }]
      });
      const contentBlock = response.content[0];
      const content2 = typeof contentBlock === "object" && "text" in contentBlock ? contentBlock.text : JSON.stringify(contentBlock);
      const jsonMatch = content2.match(/```json\n([\s\S]*?)\n```/) || content2.match(/```\n([\s\S]*?)\n```/);
      if (!jsonMatch) {
        throw new Error("Failed to extract JSON recommendations from AI response");
      }
      const recommendationsJson = jsonMatch[1];
      const recommendationsData = JSON.parse(recommendationsJson);
      const recommendations = recommendationsData.map((rec) => ({
        userId,
        orgId: orgId || null,
        recommendationType: "personal",
        title: rec.title,
        description: rec.description,
        reason: rec.reason,
        score: rec.score,
        templates: rec.templates,
        workflowIds: [],
        categories: rec.categories,
        generated: true,
        read: false,
        clicked: false
      }));
      return { recommendations };
    } catch (error) {
      console.error("Error generating recommendations:", error);
      throw error;
    }
  }
  /**
   * Generate organization-level workflow recommendations
   */
  async generateOrganizationRecommendations(input2) {
    const { recommendations } = await this.generatePersonalRecommendations(input2);
    const orgRecommendations = recommendations.map((rec) => ({
      ...rec,
      recommendationType: "organization"
    }));
    return { recommendations: orgRecommendations };
  }
  /**
   * Save generated recommendations to the database
   */
  async saveRecommendations(recommendations) {
    for (const recommendation of recommendations) {
      await storage.createWorkflowRecommendation(recommendation);
    }
  }
  /**
   * Build a user profile from their activity data
   */
  async buildUserProfile(userId) {
    const recentActivities = await storage.getUserWorkflowActivities(userId);
    const categoryCount = {};
    const templateCount = {};
    const workflowCount = {};
    recentActivities.forEach((activity) => {
      if (activity.workflowId) {
        workflowCount[activity.workflowId] = (workflowCount[activity.workflowId] || 0) + 1;
      }
      if (activity.templateId) {
        templateCount[activity.templateId] = (templateCount[activity.templateId] || 0) + 1;
      }
      const metadata = activity.metadata;
      if (metadata && metadata.categories && Array.isArray(metadata.categories)) {
        metadata.categories.forEach((category) => {
          categoryCount[category] = (categoryCount[category] || 0) + 1;
        });
      }
    });
    const frequentCategories = Object.entries(categoryCount).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([category]) => category);
    const frequentTemplates = Object.entries(templateCount).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([template]) => parseInt(template));
    const frequentWorkflows = Object.entries(workflowCount).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([workflow]) => parseInt(workflow));
    const totalWorkflows = await storage.getWorkflowsByUser(userId).then((workflows2) => workflows2.length);
    return {
      recentActivities,
      frequentCategories,
      frequentTemplates,
      frequentWorkflows,
      totalWorkflows,
      totalExecutions: recentActivities.filter((a) => a.activityType === "execute").length
    };
  }
  /**
   * Main method to generate and save recommendations for a user
   */
  async generateAndSaveRecommendationsForUser(userId, orgId) {
    try {
      const userProfile = await this.buildUserProfile(userId);
      const templates = await storage.getAllWorkflowTemplates();
      const { recommendations } = await this.generatePersonalRecommendations({
        userId,
        orgId,
        templates,
        userProfile
      });
      await this.saveRecommendations(recommendations);
      return recommendations;
    } catch (error) {
      console.error("Error in recommendation generation process:", error);
      throw error;
    }
  }
};
var recommendationEngine = new RecommendationEngine();

// server/services/openid-connect.ts
import axios4 from "axios";

// server/services/error-handler.ts
var ApiError = class extends Error {
  statusCode;
  errorCode;
  details;
  constructor(message, statusCode = 500, errorCode = "INTERNAL_SERVER_ERROR", details) {
    super(message);
    this.name = this.constructor.name;
    this.statusCode = statusCode;
    this.errorCode = errorCode;
    this.details = details;
  }
  toJSON() {
    return {
      error: {
        message: this.message,
        code: this.errorCode,
        details: this.details
      }
    };
  }
};
var OidcError = class extends ApiError {
  constructor(message, errorCode = "OIDC_ERROR", details) {
    super(message, 400, errorCode, details);
  }
};
var OidcProviderError = class extends OidcError {
  constructor(message = "Invalid OIDC provider", details) {
    super(message, "OIDC_PROVIDER_ERROR", details);
  }
};
var OidcDiscoveryError = class extends OidcError {
  constructor(message = "OIDC discovery failed", details) {
    super(message, "OIDC_DISCOVERY_ERROR", details);
  }
};
var OidcStateError = class extends OidcError {
  constructor(message = "Invalid OIDC state", details) {
    super(message, "OIDC_STATE_ERROR", details);
  }
};
var OidcTokenError = class extends OidcError {
  constructor(message = "Error obtaining OIDC tokens", details) {
    super(message, "OIDC_TOKEN_ERROR", details);
  }
};
var OidcUserInfoError = class extends OidcError {
  constructor(message = "Error obtaining user info", details) {
    super(message, "OIDC_USERINFO_ERROR", details);
  }
};

// server/services/openid-connect.ts
import crypto from "crypto";
import querystring2 from "querystring";
var OpenIDConnectService = class {
  static async getDiscoveryDocument(issuerUrl) {
    try {
      const wellKnownUrl = issuerUrl.endsWith("/") ? `${issuerUrl}.well-known/openid-configuration` : `${issuerUrl}/.well-known/openid-configuration`;
      const response = await axios4.get(wellKnownUrl);
      return response.data;
    } catch (error) {
      try {
        const alternativeUrl = issuerUrl.endsWith("/") ? `${issuerUrl}oauth-authorization-server/.well-known/openid-configuration` : `${issuerUrl}/oauth-authorization-server/.well-known/openid-configuration`;
        const response = await axios4.get(alternativeUrl);
        return response.data;
      } catch (alternativeError) {
        console.error("OIDC discovery error:", error);
        throw new OidcDiscoveryError("Failed to retrieve OIDC discovery document", {
          issuerUrl,
          originalError: error instanceof Error ? error.message : String(error)
        });
      }
    }
  }
  /**
   * Generate state and nonce parameters for OIDC authorization request
   */
  static generateAuthParams() {
    const state = crypto.randomBytes(32).toString("hex");
    const nonce = crypto.randomBytes(32).toString("hex");
    const codeVerifier = crypto.randomBytes(64).toString("hex");
    const codeChallenge = crypto.createHash("sha256").update(codeVerifier).digest("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
    return { state, nonce, codeVerifier, codeChallenge };
  }
  /**
   * Get the authorization URL for an OIDC provider
   */
  static async getAuthorizationUrl(provider, state, nonce, codeChallenge) {
    if (!provider || !provider.issuerUrl) {
      throw new OidcProviderError("Invalid OIDC provider", { provider });
    }
    try {
      const discovery = await this.getDiscoveryDocument(provider.issuerUrl);
      if (!discovery.authorization_endpoint) {
        throw new OidcDiscoveryError("Authorization endpoint not found in discovery document");
      }
      const params2 = {
        client_id: provider.clientId,
        redirect_uri: provider.redirectUri,
        response_type: "code",
        scope: Array.isArray(provider.scopes) ? provider.scopes.join(" ") : "openid profile email",
        state,
        nonce
      };
      if (codeChallenge) {
        params2.code_challenge = codeChallenge;
        params2.code_challenge_method = "S256";
      }
      const queryParams = querystring2.stringify(params2);
      return `${discovery.authorization_endpoint}?${queryParams}`;
    } catch (error) {
      if (error instanceof OidcDiscoveryError || error instanceof OidcProviderError) {
        throw error;
      }
      throw new OidcProviderError("Failed to generate authorization URL", {
        provider: provider.name,
        originalError: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * Handle the callback from the OIDC provider
   */
  static async handleCallback(provider, params2, expectedState, expectedNonce, codeVerifier) {
    if (params2.error) {
      throw new OidcStateError(`Error during authorization: ${params2.error}`, {
        error: params2.error,
        error_description: params2.error_description
      });
    }
    if (!params2.state || params2.state !== expectedState) {
      throw new OidcStateError("Invalid state parameter", {
        expected: expectedState,
        received: params2.state
      });
    }
    if (!params2.code) {
      throw new OidcStateError("Authorization code missing from callback");
    }
    try {
      const discovery = await this.getDiscoveryDocument(provider.issuerUrl);
      if (!discovery.token_endpoint) {
        throw new OidcDiscoveryError("Token endpoint not found in discovery document");
      }
      const tokenParams = {
        grant_type: "authorization_code",
        code: Array.isArray(params2.code) ? params2.code[0] : params2.code,
        redirect_uri: provider.redirectUri,
        client_id: provider.clientId,
        client_secret: provider.clientSecret
      };
      if (codeVerifier) {
        tokenParams.code_verifier = codeVerifier;
      }
      const response = await axios4.post(
        discovery.token_endpoint,
        querystring2.stringify(tokenParams),
        {
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          }
        }
      );
      const tokenResponse = response.data;
      if (tokenResponse.id_token) {
      }
      return tokenResponse;
    } catch (error) {
      if (error instanceof OidcDiscoveryError || error instanceof OidcStateError) {
        throw error;
      }
      const details = error.response?.data || {
        originalError: error instanceof Error ? error.message : String(error)
      };
      throw new OidcTokenError("Failed to exchange code for tokens", details);
    }
  }
  /**
   * Get user information from the OIDC provider
   */
  static async getUserInfo(provider, accessToken) {
    try {
      const discovery = await this.getDiscoveryDocument(provider.issuerUrl);
      if (!discovery.userinfo_endpoint) {
        throw new OidcDiscoveryError("Userinfo endpoint not found in discovery document");
      }
      const response = await axios4.get(discovery.userinfo_endpoint, {
        headers: {
          Authorization: `Bearer ${accessToken}`
        }
      });
      return response.data;
    } catch (error) {
      if (error instanceof OidcDiscoveryError) {
        throw error;
      }
      throw new OidcUserInfoError("Failed to get user info", {
        provider: provider.name,
        originalError: error instanceof Error ? error.message : String(error),
        responseData: error.response?.data
      });
    }
  }
  /**
   * Convert OIDC provider and tokens to integration config
   */
  static toIntegrationConfig(provider, tokenSet) {
    const expiryTimestamp = tokenSet.expires_in ? Math.floor(Date.now() / 1e3) + tokenSet.expires_in : void 0;
    return {
      name: provider.name,
      type: "oauth2",
      authType: "oauth2",
      tokenType: tokenSet.token_type || "Bearer",
      accessToken: tokenSet.access_token,
      refreshToken: tokenSet.refresh_token,
      expiresAt: expiryTimestamp,
      scopes: provider.scopes,
      providerType: "oidc",
      providerConfig: {
        issuerUrl: provider.issuerUrl,
        clientId: provider.clientId,
        tokenEndpoint: "",
        // Will be populated from discovery
        authEndpoint: ""
        // Will be populated from discovery
      }
    };
  }
  /**
   * Refresh an access token using a refresh token
   */
  static async refreshAccessToken(provider, refreshToken) {
    try {
      const discovery = await this.getDiscoveryDocument(provider.issuerUrl);
      if (!discovery.token_endpoint) {
        throw new OidcDiscoveryError("Token endpoint not found in discovery document");
      }
      const response = await axios4.post(
        discovery.token_endpoint,
        querystring2.stringify({
          grant_type: "refresh_token",
          refresh_token: refreshToken,
          client_id: provider.clientId,
          client_secret: provider.clientSecret
        }),
        {
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          }
        }
      );
      return response.data;
    } catch (error) {
      throw new OidcTokenError("Failed to refresh token", {
        provider: provider.name,
        originalError: error instanceof Error ? error.message : String(error)
      });
    }
  }
};

// server/routes.ts
import axios11 from "axios";
import * as cheerio3 from "cheerio";

// server/services/osint.ts
var OsintSourceType = /* @__PURE__ */ ((OsintSourceType3) => {
  OsintSourceType3["SOCIAL_MEDIA"] = "social_media";
  OsintSourceType3["NEWS"] = "news";
  OsintSourceType3["FORUMS"] = "forums";
  OsintSourceType3["BLOGS"] = "blogs";
  OsintSourceType3["COMPANY_INFO"] = "company_info";
  OsintSourceType3["PERSON_INFO"] = "person_info";
  OsintSourceType3["DOMAIN_INFO"] = "domain_info";
  OsintSourceType3["WHOIS"] = "whois";
  OsintSourceType3["DNS"] = "dns";
  OsintSourceType3["OTHER"] = "other";
  return OsintSourceType3;
})(OsintSourceType || {});
var OsintService = class _OsintService {
  /**
   * Search for information across multiple sources
   */
  async search(query2) {
    const { term, sources = Object.values(OsintSourceType), timeframe = "all", limit = 10 } = query2;
    const results = [];
    try {
      for (const source of sources) {
        const sourceResults = await this.querySource(source, term, timeframe, limit);
        results.push(...sourceResults);
      }
      return results.sort((a, b) => b.relevance - a.relevance).slice(0, limit);
    } catch (error) {
      console.error("OSINT search error:", error);
      throw new Error(`OSINT search failed: ${error.message}`);
    }
  }
  /**
   * Set up social media monitoring with alerts
   */
  setupMonitoring(options2) {
    const { platforms, keywords, accounts = [], frequency = 60 } = options2;
    console.log(`Setting up monitoring for platforms: ${platforms.join(", ")}`);
    console.log(`Monitoring keywords: ${keywords.join(", ")}`);
    if (accounts.length > 0) {
      console.log(`Monitoring accounts: ${accounts.join(", ")}`);
    }
    console.log(`Checking frequency: ${frequency} minutes`);
    return {
      id: `monitor_${Date.now()}`,
      platforms,
      keywords,
      accounts,
      frequency,
      status: "active"
    };
  }
  /**
   * Get social media monitoring alerts
   */
  async getAlerts(monitorId, since) {
    return [
      {
        id: `alert_${Date.now()}_1`,
        platform: "twitter",
        content: "Important announcement about our new product release!",
        url: "https://twitter.com/example/status/123456789",
        timestamp: /* @__PURE__ */ new Date(),
        keywords: ["announcement", "product", "release"],
        score: 0.85,
        metadata: {
          engagement: {
            likes: 120,
            retweets: 45,
            replies: 23
          }
        }
      },
      {
        id: `alert_${Date.now()}_2`,
        platform: "linkedin",
        content: "Our company is excited to share our latest innovation in AI technology.",
        url: "https://linkedin.com/company/example/posts/123456789",
        timestamp: new Date(Date.now() - 36e5),
        // 1 hour ago
        keywords: ["innovation", "AI", "technology"],
        score: 0.78,
        metadata: {
          engagement: {
            likes: 87,
            comments: 14,
            shares: 32
          }
        }
      }
    ];
  }
  /**
   * Perform person lookup using OSINT techniques
   */
  async personLookup(name) {
    return {
      name,
      possibleProfiles: [
        {
          platform: "linkedin",
          url: `https://linkedin.com/in/${name.toLowerCase().replace(/\s+/g, "")}`,
          confidence: 0.92
        },
        {
          platform: "twitter",
          url: `https://twitter.com/${name.toLowerCase().replace(/\s+/g, "")}`,
          confidence: 0.78
        }
      ],
      emailPatterns: [
        `${name.split(" ")[0].toLowerCase()}@company.com`,
        `${name.split(" ")[0].toLowerCase()}.${name.split(" ")[1].toLowerCase()}@company.com`
      ],
      possibleImages: [
        `https://example.com/profile_images/${name.toLowerCase().replace(/\s+/g, "")}.jpg`
      ]
    };
  }
  /**
   * Perform company lookup using OSINT techniques
   */
  async companyLookup(companyName) {
    return {
      name: companyName,
      website: `https://${companyName.toLowerCase().replace(/\s+/g, "")}.com`,
      socialProfiles: [
        {
          platform: "linkedin",
          url: `https://linkedin.com/company/${companyName.toLowerCase().replace(/\s+/g, "")}`
        },
        {
          platform: "twitter",
          url: `https://twitter.com/${companyName.toLowerCase().replace(/\s+/g, "")}`
        }
      ],
      contactInfo: {
        email: `info@${companyName.toLowerCase().replace(/\s+/g, "")}.com`,
        phone: "+1-555-123-4567"
      },
      employees: [
        {
          title: "CEO",
          count: 1
        },
        {
          title: "Software Engineer",
          count: 23
        },
        {
          title: "Marketing",
          count: 12
        }
      ]
    };
  }
  /**
   * Analyze sentiment across social media mentions
   */
  async analyzeSentiment(term, platforms = ["twitter", "reddit", "facebook"]) {
    return {
      term,
      overallSentiment: {
        positive: 0.65,
        neutral: 0.25,
        negative: 0.1
      },
      platformSentiment: platforms.map((platform) => ({
        platform,
        positive: Math.random() * 0.7 + 0.3,
        // Random value between 0.3 and 1.0
        neutral: Math.random() * 0.4,
        // Random value between 0 and 0.4
        negative: Math.random() * 0.3,
        // Random value between 0 and 0.3
        sampleSize: Math.floor(Math.random() * 1e3 + 100)
        // Random value between 100 and 1100
      })),
      topPositivePhrases: [
        "excellent product",
        "great service",
        "highly recommend"
      ],
      topNegativePhrases: [
        "disappointed with",
        "poor quality",
        "wouldn't recommend"
      ],
      timeSeries: {
        days: 7,
        data: Array(7).fill(0).map((_, i) => ({
          date: new Date(Date.now() - (6 - i) * 24 * 3600 * 1e3).toISOString().split("T")[0],
          positive: Math.random() * 0.7 + 0.3,
          neutral: Math.random() * 0.4,
          negative: Math.random() * 0.3
        }))
      }
    };
  }
  /**
   * Private method to query specific sources based on type
   */
  async querySource(sourceType, term, timeframe, limit) {
    await new Promise((resolve) => setTimeout(resolve, 300));
    switch (sourceType) {
      case "social_media" /* SOCIAL_MEDIA */:
        return [{
          source: "social_media" /* SOCIAL_MEDIA */,
          sourceName: "Twitter",
          sourceUrl: "https://twitter.com/search",
          data: {
            posts: [
              {
                id: "12345678",
                content: `Interesting discussion about ${term}`,
                user: "user123",
                timestamp: new Date(Date.now() - 36e5)
              },
              {
                id: "12345679",
                content: `Just learned about ${term} today!`,
                user: "tech_enthusiast",
                timestamp: new Date(Date.now() - 72e5)
              }
            ]
          },
          timestamp: /* @__PURE__ */ new Date(),
          confidence: 0.9,
          relevance: 0.85,
          metadata: {
            platform: "twitter",
            resultCount: 2
          }
        }];
      case "news" /* NEWS */:
        return [{
          source: "news" /* NEWS */,
          sourceName: "News API",
          sourceUrl: "https://newsapi.org",
          data: {
            articles: [
              {
                title: `Latest developments in ${term}`,
                source: "Tech News",
                url: "https://technews.example.com/article123",
                publishedAt: new Date(Date.now() - 12 * 36e5)
              },
              {
                title: `${term} innovations changing the industry`,
                source: "Industry Today",
                url: "https://industrytoday.example.com/article456",
                publishedAt: new Date(Date.now() - 24 * 36e5)
              }
            ]
          },
          timestamp: /* @__PURE__ */ new Date(),
          confidence: 0.95,
          relevance: 0.9,
          metadata: {
            apiSource: "newsapi",
            resultCount: 2
          }
        }];
      // Add more source types as needed
      default:
        return [];
    }
  }
  /**
   * Get OSINT tools for agent use
   */
  static getOsintTools() {
    const osintService2 = new _OsintService();
    return [
      {
        name: "osint_search",
        description: "Search for information across multiple public sources",
        parameters: {
          term: {
            type: "string",
            description: "The search term to look for",
            required: true
          },
          sources: {
            type: "array",
            description: "List of source types to search (default: all)",
            required: false
          },
          timeframe: {
            type: "string",
            description: "Time range for results (day, week, month, year, all)",
            required: false
          },
          limit: {
            type: "number",
            description: "Maximum number of results to return",
            required: false
          }
        },
        execute: async (params2) => {
          return await osintService2.search(params2);
        }
      },
      {
        name: "person_lookup",
        description: "Look up information about a person from public sources",
        parameters: {
          name: {
            type: "string",
            description: "The person's name to search for",
            required: true
          }
        },
        execute: async (params2) => {
          return await osintService2.personLookup(params2.name);
        }
      },
      {
        name: "company_lookup",
        description: "Look up information about a company from public sources",
        parameters: {
          name: {
            type: "string",
            description: "The company name to search for",
            required: true
          }
        },
        execute: async (params2) => {
          return await osintService2.companyLookup(params2.name);
        }
      },
      {
        name: "social_sentiment",
        description: "Analyze sentiment for a topic across social media platforms",
        parameters: {
          term: {
            type: "string",
            description: "The term or topic to analyze sentiment for",
            required: true
          },
          platforms: {
            type: "array",
            description: "List of social media platforms to analyze",
            required: false
          }
        },
        execute: async (params2) => {
          return await osintService2.analyzeSentiment(
            params2.term,
            params2.platforms || ["twitter", "reddit", "facebook"]
          );
        }
      }
    ];
  }
};

// server/services/langgraph-executor.ts
var LangGraphExecutor = class {
  workflowExecution;
  workflow;
  sendWebSocketEvent;
  abortController;
  isPaused = false;
  executionId;
  constructor(workflowExecution, workflow, sendWebSocketEvent) {
    this.workflowExecution = workflowExecution;
    this.workflow = workflow;
    this.sendWebSocketEvent = sendWebSocketEvent;
    this.abortController = new AbortController();
    this.executionId = workflowExecution.id;
  }
  /**
   * Execute the LangGraph workflow
   */
  async execute() {
    try {
      this.sendWebSocketEvent({
        type: "langgraph_state_update",
        data: {
          executionId: this.executionId,
          state: "starting",
          message: "Starting LangGraph workflow execution"
        }
      });
      await new Promise((resolve) => setTimeout(resolve, 2e3));
      await this.complete({
        message: "LangGraph workflow executed successfully",
        result: { status: "success" }
      });
    } catch (error) {
      await this.fail(error);
    }
  }
  /**
   * Pause the LangGraph execution
   */
  async pause() {
    this.isPaused = true;
    this.sendWebSocketEvent({
      type: "langgraph_state_update",
      data: {
        executionId: this.executionId,
        state: "paused",
        message: "LangGraph workflow execution paused"
      }
    });
  }
  /**
   * Resume the LangGraph execution
   */
  async resume() {
    this.isPaused = false;
    this.sendWebSocketEvent({
      type: "langgraph_state_update",
      data: {
        executionId: this.executionId,
        state: "resumed",
        message: "LangGraph workflow execution resumed"
      }
    });
  }
  /**
   * Cancel the LangGraph execution
   */
  async cancel() {
    this.abortController.abort();
    this.sendWebSocketEvent({
      type: "langgraph_state_update",
      data: {
        executionId: this.executionId,
        state: "cancelled",
        message: "LangGraph workflow execution cancelled"
      }
    });
  }
  /**
   * Complete the LangGraph execution successfully
   */
  async complete(result2) {
    this.sendWebSocketEvent({
      type: "langgraph_state_update",
      data: {
        executionId: this.executionId,
        state: "completed",
        message: "LangGraph workflow execution completed",
        result: result2
      }
    });
  }
  /**
   * Fail the LangGraph execution
   */
  async fail(error) {
    console.error("LangGraph execution failed:", error);
    this.sendWebSocketEvent({
      type: "langgraph_state_update",
      data: {
        executionId: this.executionId,
        state: "failed",
        message: "LangGraph workflow execution failed",
        error: error.message
      }
    });
  }
};

// server/services/workflow-executor.ts
var WorkflowExecutor = class {
  workflowExecution;
  workflow;
  sendWebSocketEvent;
  abortController;
  executionId;
  langGraphExecutor = null;
  isPaused = false;
  isCancelled = false;
  // Additional properties for tracking execution state
  currentNodes = [];
  completedNodes = [];
  nodeResults = /* @__PURE__ */ new Map();
  status = "queued" /* QUEUED */;
  startTime = /* @__PURE__ */ new Date();
  endTime = null;
  logs = [];
  constructor(workflowExecution, workflow, sendWebSocketEvent) {
    this.workflowExecution = workflowExecution;
    this.workflow = workflow;
    this.sendWebSocketEvent = sendWebSocketEvent;
    this.abortController = new AbortController();
    this.executionId = workflowExecution.id;
  }
  /**
   * Execute the workflow
   */
  async execute() {
    try {
      await this.initializeExecution();
      if (this.isLangGraphWorkflow()) {
        await this.executeLangGraphWorkflow();
      } else {
        await this.executeStandardWorkflow();
      }
    } catch (error) {
      await this.failExecution(error);
    }
  }
  /**
   * Pause the workflow execution
   */
  async pause() {
    this.isPaused = true;
    if (this.langGraphExecutor) {
      await this.langGraphExecutor.pause();
    }
    await storage.updateWorkflowExecution(this.executionId, {
      status: "paused"
    });
    this.sendWebSocketEvent({
      type: "execution_paused",
      data: {
        executionId: this.executionId
      }
    });
  }
  /**
   * Resume the workflow execution
   */
  async resume() {
    this.isPaused = false;
    if (this.langGraphExecutor) {
      await this.langGraphExecutor.resume();
    }
    await storage.updateWorkflowExecution(this.executionId, {
      status: "running" /* RUNNING */
    });
    this.sendWebSocketEvent({
      type: "execution_resumed",
      data: {
        executionId: this.executionId
      }
    });
  }
  /**
   * Cancel the workflow execution
   */
  async cancel() {
    this.isCancelled = true;
    this.abortController.abort();
    if (this.langGraphExecutor) {
      await this.langGraphExecutor.cancel();
    }
    await storage.updateWorkflowExecution(this.executionId, {
      status: "cancelled" /* CANCELLED */,
      completedAt: /* @__PURE__ */ new Date()
    });
    this.sendWebSocketEvent({
      type: "execution_cancelled",
      data: {
        executionId: this.executionId
      }
    });
  }
  /**
   * Initialize execution
   */
  async initializeExecution() {
    await storage.updateWorkflowExecution(this.executionId, {
      status: "running" /* RUNNING */
    });
    this.sendWebSocketEvent({
      type: "execution_started",
      data: {
        executionId: this.executionId
      }
    });
  }
  /**
   * Complete execution
   */
  async completeExecution(result2) {
    await storage.updateWorkflowExecution(this.executionId, {
      status: "completed" /* COMPLETED */,
      completedAt: /* @__PURE__ */ new Date(),
      result: result2
    });
    this.sendWebSocketEvent({
      type: "execution_completed",
      data: {
        executionId: this.executionId,
        result: result2
      }
    });
  }
  /**
   * Fail execution
   */
  async failExecution(error) {
    console.error("Workflow execution failed:", error);
    await storage.updateWorkflowExecution(this.executionId, {
      status: "failed" /* FAILED */,
      completedAt: /* @__PURE__ */ new Date(),
      result: { error: error.message }
    });
    this.sendWebSocketEvent({
      type: "execution_failed",
      data: {
        executionId: this.executionId,
        error: error.message
      }
    });
  }
  /**
   * Check if the workflow is a LangGraph workflow
   */
  isLangGraphWorkflow() {
    const workflowData = this.workflow.data;
    const nodes = workflowData?.nodes || [];
    return nodes.some(
      (node) => node.type === "langgraph-state" /* LANGGRAPH_STATE */ || node.type === "langgraph-node" /* LANGGRAPH_NODE */ || node.type === "langgraph-edge" /* LANGGRAPH_EDGE */ || node.type === "langgraph-conditional" /* LANGGRAPH_CONDITIONAL */ || node.type === "agent-node" /* AGENT_NODE */ || node.type === "agent-supervisor" /* AGENT_SUPERVISOR */ || node.type === "memory-store" /* MEMORY_STORE */ || node.type === "context-retriever" /* CONTEXT_RETRIEVER */ || node.type === "tool-node" /* TOOL_NODE */ || node.type === "tool-executor" /* TOOL_EXECUTOR */ || node.type === "conversation-chain" /* CONVERSATION_CHAIN */ || node.type === "conversation-router" /* CONVERSATION_ROUTER */ || node.type === "output-parser" /* OUTPUT_PARSER */ || node.type === "output-formatter" /* OUTPUT_FORMATTER */
    );
  }
  /**
   * Execute a LangGraph workflow
   */
  async executeLangGraphWorkflow() {
    this.langGraphExecutor = new LangGraphExecutor(
      this.workflowExecution,
      this.workflow,
      this.sendWebSocketEvent
    );
    await this.langGraphExecutor.execute();
  }
  /**
   * Execute a standard workflow
   */
  async executeStandardWorkflow() {
    await this.completeExecution({
      message: "Standard workflow execution not yet implemented"
    });
  }
};
var WorkflowExecutionRegistry = class {
  executors = /* @__PURE__ */ new Map();
  /**
   * Register a new executor
   */
  register(executionId, executor) {
    this.executors.set(executionId, executor);
  }
  /**
   * Get an executor by execution ID
   */
  get(executionId) {
    return this.executors.get(executionId);
  }
  /**
   * Unregister an executor
   */
  unregister(executionId) {
    this.executors.delete(executionId);
  }
  /**
   * Get the count of active executors
   */
  getActiveCount() {
    return this.executors.size;
  }
};
var executionRegistry = new WorkflowExecutionRegistry();
async function startWorkflowExecution(workflowId, userId, sendWebSocketEvent) {
  const workflow = await storage.getWorkflow(workflowId);
  if (!workflow) {
    throw new Error(`Workflow with ID ${workflowId} not found`);
  }
  const workflowExecution = await storage.createWorkflowExecution({
    workflowId,
    status: "queued" /* QUEUED */,
    triggeredById: userId,
    startedAt: /* @__PURE__ */ new Date()
  });
  const executor = new WorkflowExecutor(
    workflowExecution,
    workflow,
    sendWebSocketEvent
  );
  executionRegistry.register(workflowExecution.id, executor);
  executor.execute().finally(() => {
    executionRegistry.unregister(workflowExecution.id);
  });
  return workflowExecution.id;
}
async function pauseWorkflowExecution(executionId) {
  const executor = executionRegistry.get(executionId);
  if (!executor) {
    throw new Error(`No active execution found for ID ${executionId}`);
  }
  await executor.pause();
}
async function resumeWorkflowExecution(executionId) {
  const executor = executionRegistry.get(executionId);
  if (!executor) {
    throw new Error(`No active execution found for ID ${executionId}`);
  }
  await executor.resume();
}
async function cancelWorkflowExecution(executionId) {
  const executor = executionRegistry.get(executionId);
  if (!executor) {
    throw new Error(`No active execution found for ID ${executionId}`);
  }
  await executor.cancel();
}
var eventListeners = {};
function onEvent(eventName, callback) {
  if (!eventListeners[eventName]) {
    eventListeners[eventName] = [];
  }
  eventListeners[eventName].push(callback);
}

// server/services/workflow/WebSocketHandler.ts
import { WebSocketServer, WebSocket } from "ws";
import { v4 as uuidv42 } from "uuid";
var WebSocketHandler = class {
  wss = null;
  clients = /* @__PURE__ */ new Map();
  executionSubscribers = /* @__PURE__ */ new Map();
  /**
   * Initialize the WebSocket server
   * @param server - HTTP server instance
   */
  initialize(server) {
    try {
      this.wss = new WebSocketServer({
        server,
        path: "/ws",
        perMessageDeflate: false,
        clientTracking: true,
        // Explicitly handle CORS for WebSockets
        // @ts-ignore - The WebSocketServer type definition doesn't match runtime behavior
        handleProtocols: (protocols, request) => {
          if (!protocols) return true;
          if (Array.isArray(protocols)) {
            return protocols.length > 0 ? protocols[0] : true;
          }
          if (protocols instanceof Set && protocols.size > 0) {
            return Array.from(protocols)[0];
          }
          return true;
        },
        // More permissive client verification
        verifyClient: ({ origin, req: req2, secure }, callback) => {
          console.log(`[websocket] New client attempting to connect from origin: ${origin || "unknown"}`);
          callback(true);
        }
      });
      console.log("[websocket] WebSocket server initialized for workflow executions");
      this.wss.on("error", (error) => {
        console.error("[websocket] Server error:", error);
      });
      this.wss.on("connection", (ws2, req2) => {
        const clientId = uuidv42();
        console.log(`[websocket] Client connected: ${clientId} from ${req2.headers.origin || "unknown"}`);
        try {
          ws2.send(JSON.stringify({
            type: "connection_established",
            message: "WebSocket connection established",
            clientId
          }));
        } catch (err) {
          console.error(`[websocket] Error sending welcome message:`, err);
        }
        this.clients.set(clientId, {
          ws: ws2,
          subscriptions: /* @__PURE__ */ new Set()
        });
        ws2.on("message", (message) => {
          console.log(`[websocket] Received message from client ${clientId}:`, message.toString());
          try {
            const messageStr = message.toString();
            const data = JSON.parse(messageStr);
            if (data.type === "subscribe" && data.executionId) {
              this.subscribeClient(clientId, data.executionId);
            } else if (data.type === "unsubscribe" && data.executionId) {
              this.unsubscribeClient(clientId, data.executionId);
            } else {
              console.log(`[websocket] Unhandled message type: ${data.type}`);
            }
          } catch (error) {
            console.error("[websocket] Error processing message:", error);
            try {
              ws2.send(JSON.stringify({
                type: "error",
                message: "Error processing message",
                error: error instanceof Error ? error.message : "Unknown error"
              }));
            } catch (sendError) {
              console.error("[websocket] Error sending error response:", sendError);
            }
          }
        });
        ws2.on("close", (code, reason) => {
          this.removeClient(clientId);
          console.log(`[websocket] Client disconnected: ${clientId}, code: ${code}, reason: ${reason || "no reason"}`);
        });
        ws2.on("error", (error) => {
          console.error(`[websocket] WebSocket error for client ${clientId}:`, error);
        });
      });
    } catch (error) {
      console.error("[websocket] Failed to initialize WebSocket server:", error);
    }
  }
  /**
   * Subscribe a client to execution updates
   * @param clientId - Client ID
   * @param executionId - Execution ID to subscribe to
   */
  subscribeClient(clientId, executionId) {
    const client = this.clients.get(clientId);
    if (!client) {
      console.warn(`[websocket] Cannot subscribe non-existent client: ${clientId}`);
      return;
    }
    client.subscriptions.add(executionId);
    let subscribers = this.executionSubscribers.get(executionId);
    if (!subscribers) {
      subscribers = /* @__PURE__ */ new Set();
      this.executionSubscribers.set(executionId, subscribers);
    }
    subscribers.add(clientId);
    console.log(`[websocket] Client ${clientId} subscribed to execution ${executionId}`);
  }
  /**
   * Unsubscribe a client from execution updates
   * @param clientId - Client ID
   * @param executionId - Execution ID to unsubscribe from
   */
  unsubscribeClient(clientId, executionId) {
    const client = this.clients.get(clientId);
    if (!client) {
      return;
    }
    client.subscriptions.delete(executionId);
    const subscribers = this.executionSubscribers.get(executionId);
    if (subscribers) {
      subscribers.delete(clientId);
      if (subscribers.size === 0) {
        this.executionSubscribers.delete(executionId);
      }
    }
    console.log(`[websocket] Client ${clientId} unsubscribed from execution ${executionId}`);
  }
  /**
   * Remove a client and clean up all subscriptions
   * @param clientId - Client ID to remove
   */
  removeClient(clientId) {
    const client = this.clients.get(clientId);
    if (!client) {
      return;
    }
    Array.from(client.subscriptions).forEach((executionId) => {
      const subscribers = this.executionSubscribers.get(executionId);
      if (subscribers) {
        subscribers.delete(clientId);
        if (subscribers.size === 0) {
          this.executionSubscribers.delete(executionId);
        }
      }
    });
    this.clients.delete(clientId);
  }
  /**
   * Send an event to all clients subscribed to an execution
   * @param executionId - Execution ID
   * @param event - Event data to send
   */
  sendExecutionEvent(executionId, event) {
    const subscribers = this.executionSubscribers.get(executionId);
    if (!subscribers || subscribers.size === 0) {
      return;
    }
    const fullEvent = {
      type: "execution_update",
      executionId,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      ...event
    };
    const message = JSON.stringify(fullEvent);
    Array.from(subscribers).forEach((clientId) => {
      const client = this.clients.get(clientId);
      if (client && client.ws.readyState === WebSocket.OPEN) {
        try {
          client.ws.send(message);
        } catch (error) {
          console.error(`[websocket] Error sending message to client ${clientId}:`, error);
        }
      }
    });
  }
  /**
   * Check if the WebSocket server is initialized
   */
  isInitialized() {
    return this.wss !== null;
  }
  /**
   * Shutdown the WebSocket server
   */
  shutdown() {
    if (this.wss) {
      this.wss.close();
      this.wss = null;
    }
    this.clients.clear();
    this.executionSubscribers.clear();
  }
};
var webSocketHandler = new WebSocketHandler();
var WebSocketHandler_default = webSocketHandler;

// server/routes/workflow.ts
import { Router } from "express";

// server/services/workflow/WorkflowService.ts
import { v4 as uuidv43 } from "uuid";
var WorkflowService = class {
  // Store active executions in memory
  activeExecutions = /* @__PURE__ */ new Map();
  // Store execution history for each workflow
  executionHistory = /* @__PURE__ */ new Map();
  /**
   * Execute a workflow
   * @param workflowId - ID of the workflow to execute
   * @param workflowData - Workflow definition with nodes and edges
   * @param variables - Initial variables for the workflow
   * @returns Execution ID
   */
  async executeWorkflow(workflowId, workflowData, variables = {}) {
    try {
      if (!workflowData || !workflowData.nodes || !workflowData.edges) {
        throw new Error("Invalid workflow data");
      }
      const executionId = uuidv43();
      const context = {
        executionId,
        workflowId,
        status: "pending" /* PENDING */,
        variables,
        nodeResults: {},
        startTime: /* @__PURE__ */ new Date()
      };
      this.activeExecutions.set(executionId, context);
      if (!this.executionHistory.has(workflowId)) {
        this.executionHistory.set(workflowId, []);
      }
      this.executionHistory.get(workflowId)?.push(executionId);
      this.runWorkflow(executionId, workflowData).catch((error) => {
        console.error(`Execution ${executionId} failed:`, error);
        const context2 = this.activeExecutions.get(executionId);
        if (context2) {
          context2.status = "failed" /* FAILED */;
          context2.lastError = error.message;
          context2.endTime = /* @__PURE__ */ new Date();
          this.sendExecutionUpdate(executionId, {
            status: context2.status,
            error: context2.lastError
          });
        }
      });
      return executionId;
    } catch (error) {
      console.error("Failed to start workflow execution:", error);
      throw error;
    }
  }
  /**
   * Get all active executions
   * @returns Set of active execution IDs
   */
  getActiveExecutions() {
    return new Set(this.activeExecutions.keys());
  }
  /**
   * Get execution context
   * @param executionId - ID of the execution
   * @returns Execution context
   */
  getExecutionContext(executionId) {
    return this.activeExecutions.get(executionId);
  }
  /**
   * Get execution history for a workflow
   * @param workflowId - ID of the workflow
   * @returns Array of execution IDs
   */
  getExecutionHistory(workflowId) {
    return this.executionHistory.get(workflowId) || [];
  }
  /**
   * Stop a running execution
   * @param executionId - ID of the execution to stop
   * @returns True if execution was stopped, false otherwise
   */
  stopExecution(executionId) {
    const context = this.activeExecutions.get(executionId);
    if (!context || context.status !== "running" /* RUNNING */) {
      return false;
    }
    context.status = "stopped" /* STOPPED */;
    context.endTime = /* @__PURE__ */ new Date();
    this.sendExecutionUpdate(executionId, {
      status: context.status
    });
    return true;
  }
  /**
   * Run a workflow
   * @param executionId - ID of the execution
   * @param workflow - Workflow definition
   */
  async runWorkflow(executionId, workflow) {
    const context = this.activeExecutions.get(executionId);
    if (!context) {
      throw new Error("Execution context not found");
    }
    context.status = "running" /* RUNNING */;
    this.sendExecutionUpdate(executionId, {
      status: context.status
    });
    try {
      const { nodes, edges } = workflow;
      const nodesWithIncomingEdges = /* @__PURE__ */ new Set();
      for (const edge of edges) {
        nodesWithIncomingEdges.add(edge.target);
      }
      const triggerNodes = nodes.filter((node) => !nodesWithIncomingEdges.has(node.id));
      if (triggerNodes.length === 0) {
        throw new Error("No trigger nodes found in workflow");
      }
      for (const triggerNode of triggerNodes) {
        await this.executeNode(executionId, triggerNode.id, workflow);
      }
      context.status = "completed" /* COMPLETED */;
      context.endTime = /* @__PURE__ */ new Date();
      this.sendExecutionUpdate(executionId, {
        status: context.status
      });
    } catch (error) {
      context.status = "failed" /* FAILED */;
      context.lastError = error.message;
      context.endTime = /* @__PURE__ */ new Date();
      this.sendExecutionUpdate(executionId, {
        status: context.status,
        error: context.lastError
      });
      throw error;
    }
  }
  /**
   * Execute a node and its downstream nodes
   * @param executionId - ID of the execution
   * @param nodeId - ID of the node to execute
   * @param workflow - Workflow definition
   * @returns Output of the node
   */
  async executeNode(executionId, nodeId, workflow) {
    const context = this.activeExecutions.get(executionId);
    if (!context) {
      throw new Error("Execution context not found");
    }
    if (context.nodeResults[nodeId]) {
      return context.nodeResults[nodeId].output;
    }
    const node = workflow.nodes.find((n) => n.id === nodeId);
    if (!node) {
      throw new Error(`Node ${nodeId} not found in workflow`);
    }
    const nodeResult = {
      nodeId,
      status: "running" /* RUNNING */,
      startTime: /* @__PURE__ */ new Date()
    };
    context.nodeResults[nodeId] = nodeResult;
    context.currentNodeId = nodeId;
    this.sendExecutionUpdate(executionId, {
      nodeId,
      nodeStatus: nodeResult.status
    });
    try {
      const output = await this.processNode(node, context.variables, workflow);
      nodeResult.status = "completed" /* COMPLETED */;
      nodeResult.output = output;
      nodeResult.endTime = /* @__PURE__ */ new Date();
      nodeResult.executionTime = nodeResult.endTime.getTime() - (nodeResult.startTime?.getTime() || 0);
      this.sendExecutionUpdate(executionId, {
        nodeId,
        nodeStatus: nodeResult.status,
        output: nodeResult.output
      });
      let outgoingEdges = workflow.edges.filter((edge) => edge.source === nodeId);
      if (node.type === "CONDITION" && output && typeof output === "object") {
        const outputHandle = output.outputHandle;
        if (outputHandle) {
          outgoingEdges = outgoingEdges.filter(
            (edge) => edge.sourceHandle === outputHandle || // For backward compatibility with edges that don't specify sourceHandle
            !edge.sourceHandle && outputHandle === "output"
          );
        } else if (output.noPathTaken) {
          outgoingEdges = [];
        }
      }
      for (const edge of outgoingEdges) {
        await this.executeNode(executionId, edge.target, workflow);
      }
      return output;
    } catch (error) {
      nodeResult.status = "failed" /* FAILED */;
      nodeResult.error = error.message;
      nodeResult.endTime = /* @__PURE__ */ new Date();
      nodeResult.executionTime = nodeResult.endTime.getTime() - (nodeResult.startTime?.getTime() || 0);
      this.sendExecutionUpdate(executionId, {
        nodeId,
        nodeStatus: nodeResult.status,
        error: nodeResult.error
      });
      throw error;
    }
  }
  /**
   * Process a node based on its type
   * @param node - Node to process
   * @param variables - Current workflow variables
   * @param workflow - Workflow definition
   * @returns Output of the node
   */
  async processNode(node, variables, workflow) {
    await new Promise((resolve) => setTimeout(resolve, 500));
    const data = node.data || {};
    const type = node.type;
    switch (type) {
      case "MANUAL_TRIGGER":
      case "SCHEDULE_TRIGGER":
      case "WEBHOOK_TRIGGER":
      case "EVENT_TRIGGER":
        return { message: "Workflow triggered", ...data };
      case "TEXT_INPUT":
      case "FILE_INPUT":
      case "DATA_SOURCE":
        return data.value || { value: "Sample input" };
      case "FILTER":
      case "TRANSFORM":
      case "MERGE":
      case "SPLIT":
        return { processed: true, value: data.value || "Processed data" };
      case "CONDITION":
        return this.processConditionalNode(node, variables);
      case "OCR":
      case "TEXT_GENERATION":
      case "AGENT":
      case "SCRAPER":
        return { type: "ai_output", result: "Sample AI output" };
      case "API_REQUEST":
      case "DATABASE":
      case "WEBHOOK":
        return { status: "success", data: { result: "Sample integration result" } };
      case "EMAIL":
      case "NOTIFICATION":
      case "FILE_OUTPUT":
      case "DATA_EXPORT":
        return { sent: true, message: "Output produced" };
      case "SWITCH":
      case "LOOP":
      case "PARALLEL":
        return { flow: "controlled", result: "Sample flow control result" };
      case "DELAY":
        const delayMs = data.delayMs || 1e3;
        await new Promise((resolve) => setTimeout(resolve, delayMs));
        return { delayed: true, delayMs };
      case "LOGGER":
        console.log(`[Workflow Logger] Node ${node.id}:`, data);
        return { logged: true, data };
      case "CODE":
        return { executed: true, result: "Sample code execution result" };
      case "VARIABLE":
        return { variable: data.name, value: data.value };
      default:
        return { processed: true, nodeType: type };
    }
  }
  /**
   * Process a conditional node
   * @param node - Conditional node
   * @param variables - Current workflow variables
   * @returns Result of the condition evaluation
   */
  processConditionalNode(node, variables) {
    const data = node.data || {};
    if (data.useCustomCode && data.customCode) {
      try {
        const result2 = { output: "Custom code condition result", conditionMet: true };
        return result2;
      } catch (error) {
        throw new Error(`Error executing custom code: ${error.message}`);
      }
    }
    const conditions = data.conditions || [];
    for (const condition of conditions) {
      const { field, operator, value } = condition;
      let fieldValue;
      try {
        fieldValue = variables[field] || null;
      } catch (error) {
        fieldValue = null;
      }
      let conditionMet = false;
      switch (operator) {
        case "==":
          conditionMet = fieldValue == value;
          break;
        case "!=":
          conditionMet = fieldValue != value;
          break;
        case ">":
          conditionMet = fieldValue > value;
          break;
        case "<":
          conditionMet = fieldValue < value;
          break;
        case ">=":
          conditionMet = fieldValue >= value;
          break;
        case "<=":
          conditionMet = fieldValue <= value;
          break;
        case "contains":
          conditionMet = String(fieldValue).includes(value);
          break;
        case "startsWith":
          conditionMet = String(fieldValue).startsWith(value);
          break;
        case "endsWith":
          conditionMet = String(fieldValue).endsWith(value);
          break;
        case "isEmpty":
          conditionMet = !fieldValue || Array.isArray(fieldValue) && fieldValue.length === 0 || typeof fieldValue === "string" && fieldValue.trim() === "";
          break;
        case "isNotEmpty":
          conditionMet = fieldValue && (!Array.isArray(fieldValue) || fieldValue.length > 0) && (typeof fieldValue !== "string" || fieldValue.trim() !== "");
          break;
        case "isNull":
          conditionMet = fieldValue === null || fieldValue === void 0;
          break;
        case "isNotNull":
          conditionMet = fieldValue !== null && fieldValue !== void 0;
          break;
        default:
          conditionMet = false;
      }
      if (conditionMet) {
        return {
          conditionMet: true,
          condition,
          outputHandle: condition.outputHandle,
          fieldValue
        };
      }
    }
    if (data.hasElseCondition) {
      return {
        conditionMet: false,
        outputHandle: "else",
        defaultPath: true
      };
    }
    return {
      conditionMet: false,
      noPathTaken: true
    };
  }
  /**
   * Send execution update via WebSocket
   * @param executionId - ID of the execution
   * @param update - Update data
   */
  sendExecutionUpdate(executionId, update) {
    const event = {
      type: "execution_update",
      executionId,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      ...update
    };
    WebSocketHandler_default.sendExecutionEvent(executionId, event);
  }
};
var workflowService = new WorkflowService();
var WorkflowService_default = workflowService;

// server/routes/workflow.ts
import { eq as eq4 } from "drizzle-orm";
var router = Router();
router.get("/executions", async (req2, res2) => {
  try {
    const activeExecutions = Array.from(WorkflowService_default.getActiveExecutions());
    const executionDetails = activeExecutions.map((executionId) => {
      const context = WorkflowService_default.getExecutionContext(executionId);
      return {
        executionId,
        workflowId: context?.workflowId,
        status: context?.status,
        startTime: context?.startTime,
        lastError: context?.lastError
      };
    });
    res2.json(executionDetails);
  } catch (error) {
    console.error("Error fetching executions:", error);
    res2.status(500).json({ message: "Failed to fetch executions" });
  }
});
router.get("/executions/:executionId", async (req2, res2) => {
  try {
    const { executionId } = req2.params;
    const context = WorkflowService_default.getExecutionContext(executionId);
    if (!context) {
      return res2.status(404).json({ message: "Execution not found" });
    }
    res2.json({
      executionId,
      workflowId: context.workflowId,
      status: context.status,
      startTime: context.startTime,
      variables: context.variables,
      nodeResults: context.nodeResults,
      lastError: context.lastError
    });
  } catch (error) {
    console.error("Error fetching execution details:", error);
    res2.status(500).json({ message: "Failed to fetch execution details" });
  }
});
router.post("/:id/execute", async (req2, res2) => {
  try {
    const workflowId = parseInt(req2.params.id);
    const { variables } = req2.body || {};
    const [workflow] = await db.select().from(workflows).where(eq4(workflows.id, workflowId));
    if (!workflow) {
      return res2.status(404).json({ message: "Workflow not found" });
    }
    const workflowData = workflowDataSchema.parse(workflow.data);
    const validatedNodes = (workflowData.nodes || []).map((node) => {
      return {
        ...node,
        data: node.data || {}
        // Ensure data property is present and not null/undefined
      };
    });
    const executionId = await WorkflowService_default.executeWorkflow(
      workflowId,
      {
        nodes: validatedNodes,
        edges: workflowData.edges || []
      },
      variables || {}
    );
    res2.status(200).json({ executionId });
  } catch (error) {
    console.error("Error executing workflow:", error);
    res2.status(500).json({ message: "Failed to execute workflow", error: error.message });
  }
});
router.post("/executions/:executionId/stop", async (req2, res2) => {
  try {
    const { executionId } = req2.params;
    const stopped = WorkflowService_default.stopExecution(executionId);
    if (!stopped) {
      return res2.status(400).json({ message: "Execution not found or already completed" });
    }
    res2.status(200).json({ message: "Execution stopped successfully" });
  } catch (error) {
    console.error("Error stopping execution:", error);
    res2.status(500).json({ message: "Failed to stop execution", error: error.message });
  }
});
router.get("/:id/history", async (req2, res2) => {
  try {
    const workflowId = parseInt(req2.params.id);
    const history = WorkflowService_default.getExecutionHistory(workflowId);
    const executionDetails = history.map((executionId) => {
      const context = WorkflowService_default.getExecutionContext(executionId);
      return {
        executionId,
        status: context?.status,
        startTime: context?.startTime,
        lastError: context?.lastError
      };
    });
    res2.json(executionDetails);
  } catch (error) {
    console.error("Error fetching execution history:", error);
    res2.status(500).json({ message: "Failed to fetch execution history" });
  }
});
router.post("/execute", async (req2, res2) => {
  try {
    const { workflowId, nodes, edges, variables } = req2.body;
    if (!workflowId && (!nodes || !edges)) {
      return res2.status(400).json({
        message: "Either workflowId or workflow definition (nodes and edges) must be provided"
      });
    }
    let workflow = null;
    let workflowDef = null;
    if (workflowId) {
      const result2 = await db.select().from(workflows).where(eq4(workflows.id, workflowId));
      workflow = result2[0];
      if (!workflow) {
        return res2.status(404).json({ message: "Workflow not found" });
      }
      workflowDef = workflow.data;
    } else {
      workflowDef = { nodes, edges };
    }
    if (!workflowDef || !workflowDef.nodes || !workflowDef.edges) {
      return res2.status(400).json({ message: "Invalid workflow definition" });
    }
    const executionId = await WorkflowService_default.executeWorkflow(
      workflowId || 0,
      // Use 0 for temporary workflows
      {
        nodes: workflowDef.nodes || [],
        edges: workflowDef.edges || []
      },
      variables || {}
    );
    res2.status(201).json({
      executionId,
      message: "Workflow execution started successfully"
    });
  } catch (error) {
    console.error("Error executing workflow:", error);
    res2.status(500).json({
      message: "Failed to execute workflow",
      error: error.message
    });
  }
});
var workflow_default = router;

// server/routes/usage-routes.ts
import express2 from "express";
import { and as and3, eq as eq5, gte as gte2, lte as lte2, sql as sql2 } from "drizzle-orm";
var router2 = express2.Router();
var isAuthenticated = (req2, res2, next) => {
  if (!req2.isAuthenticated()) {
    return res2.status(401).json({ message: "Not authenticated" });
  }
  next();
};
router2.get("/api/usage", isAuthenticated, async (req2, res2) => {
  try {
    const startDate = req2.query.start ? new Date(req2.query.start) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3);
    const endDate = req2.query.end ? new Date(req2.query.end) : /* @__PURE__ */ new Date();
    const userId = req2.user?.id;
    if (!userId) {
      return res2.status(401).json({ message: "User not authenticated" });
    }
    const user = await storage.getUser(userId);
    if (!user) {
      return res2.status(404).json({ message: "User not found" });
    }
    let organizationId = null;
    if (user.organizationId) {
      organizationId = user.organizationId;
    }
    const quotas = await db.select().from(usageQuotas).where(
      organizationId ? eq5(usageQuotas.organizationId, organizationId) : eq5(usageQuotas.userId, userId)
    );
    const usageSummary = await db.select({
      usageType: usageRecords.usageType,
      totalUsage: sql2`SUM(${usageRecords.quantity})`
    }).from(usageRecords).where(
      and3(
        organizationId ? eq5(usageRecords.organizationId, organizationId) : eq5(usageRecords.userId, userId),
        gte2(usageRecords.timestamp, startDate),
        lte2(usageRecords.timestamp, endDate)
      )
    ).groupBy(usageRecords.usageType);
    const modelUsage = await db.select({
      model: modelCostLogs.model,
      totalInputTokens: sql2`SUM(${modelCostLogs.tokensInput})`,
      totalOutputTokens: sql2`SUM(${modelCostLogs.tokensOutput})`,
      totalCost: sql2`SUM(${modelCostLogs.cost})`,
      count: sql2`COUNT(*)`
    }).from(modelCostLogs).where(
      and3(
        eq5(modelCostLogs.userId, userId),
        gte2(modelCostLogs.timestamp, startDate),
        lte2(modelCostLogs.timestamp, endDate)
      )
    ).groupBy(modelCostLogs.model);
    const summaryWithQuotas = usageSummary.map((summary) => {
      const quota = quotas.find((q) => q.usageType === summary.usageType);
      let percentUsed = null;
      if (quota && quota.limit > 0) {
        percentUsed = Math.min(100, Math.round(summary.totalUsage / quota.limit * 100));
      }
      return {
        ...summary,
        quota: quota?.limit || null,
        percentUsed
      };
    });
    res2.json({
      period: {
        start: startDate.toISOString(),
        end: endDate.toISOString()
      },
      summary: summaryWithQuotas,
      modelUsage
    });
  } catch (error) {
    console.error("Error fetching usage data:", error);
    res2.status(500).json({ message: "Failed to fetch usage data" });
  }
});
router2.get("/api/usage/history", isAuthenticated, async (req2, res2) => {
  try {
    const period = req2.query.period || "30d";
    const endDate = /* @__PURE__ */ new Date();
    let startDate;
    switch (period) {
      case "7d":
        startDate = new Date(endDate.getTime() - 7 * 24 * 60 * 60 * 1e3);
        break;
      case "90d":
        startDate = new Date(endDate.getTime() - 90 * 24 * 60 * 60 * 1e3);
        break;
      case "30d":
      default:
        startDate = new Date(endDate.getTime() - 30 * 24 * 60 * 60 * 1e3);
        break;
    }
    const userId = req2.user?.id;
    if (!userId) {
      return res2.status(401).json({ message: "User not authenticated" });
    }
    const dailyData = await db.execute(sql2`
      SELECT 
        DATE_TRUNC('day', timestamp) as date,
        usage_type as type,
        SUM(quantity) as value
      FROM usage_records
      WHERE 
        user_id = ${userId} AND
        timestamp >= ${startDate} AND
        timestamp <= ${endDate}
      GROUP BY DATE_TRUNC('day', timestamp), usage_type
      ORDER BY date
    `);
    const byTypeData = await db.execute(sql2`
      SELECT 
        usage_type as type,
        SUM(quantity) as value,
        ROUND(100.0 * SUM(quantity) / (
          SELECT SUM(quantity) FROM usage_records
          WHERE 
            user_id = ${userId} AND
            timestamp >= ${startDate} AND
            timestamp <= ${endDate}
        ), 1) as percentage
      FROM usage_records
      WHERE 
        user_id = ${userId} AND
        timestamp >= ${startDate} AND
        timestamp <= ${endDate}
      GROUP BY usage_type
    `);
    const byModelData = await db.execute(sql2`
      SELECT 
        model,
        SUM(tokens_input + tokens_output) as tokens,
        SUM(cost) as cost,
        ROUND(100.0 * SUM(tokens_input + tokens_output) / (
          SELECT SUM(tokens_input + tokens_output) FROM model_cost_logs
          WHERE 
            user_id = ${userId} AND
            timestamp >= ${startDate} AND
            timestamp <= ${endDate}
        ), 1) as percentage
      FROM model_cost_logs
      WHERE 
        user_id = ${userId} AND
        timestamp >= ${startDate} AND
        timestamp <= ${endDate}
      GROUP BY model
    `);
    const totalCostResult = await db.execute(sql2`
      SELECT SUM(cost) as total_cost
      FROM model_cost_logs
      WHERE 
        user_id = ${userId} AND
        timestamp >= ${startDate} AND
        timestamp <= ${endDate}
    `);
    const totalCost = totalCostResult.rows[0]?.total_cost || 0;
    const totalTokensResult = await db.execute(sql2`
      SELECT SUM(tokens_input + tokens_output) as total_tokens
      FROM model_cost_logs
      WHERE 
        user_id = ${userId} AND
        timestamp >= ${startDate} AND
        timestamp <= ${endDate}
    `);
    const totalTokens2 = totalTokensResult.rows[0]?.total_tokens || 0;
    res2.json({
      daily: dailyData.rows,
      byType: byTypeData.rows,
      byModel: byModelData.rows,
      totalCost,
      totalTokens: totalTokens2
    });
  } catch (error) {
    console.error("Error fetching usage history:", error);
    res2.status(500).json({ message: "Failed to fetch usage history" });
  }
});
var usage_routes_default = router2;

// server/routes/subscription-routes.ts
import express3 from "express";
import { eq as eq6, sql as sql3 } from "drizzle-orm";
import Stripe from "stripe";
var priceIdCol = sql3.identifier("stripe_price_id");
var amountCol = sql3.identifier("price");
var router3 = express3.Router();
var stripeApiKey = process.env.STRIPE_SECRET_KEY;
var stripe = stripeApiKey ? new Stripe(stripeApiKey, { apiVersion: "2025-04-30.basil" }) : void 0;
var isAuthenticated2 = (req2, res2, next) => {
  if (!req2.isAuthenticated()) {
    return res2.status(401).json({ message: "Not authenticated" });
  }
  next();
};
router3.get("/api/subscription-plans", async (req2, res2) => {
  try {
    const plans = await db.select().from(subscriptionPlans).where(eq6(subscriptionPlans.isActive, true)).orderBy(subscriptionPlans.sortOrder);
    if (!plans || plans.length === 0) {
      return res2.json([]);
    }
    const transformedPlans = plans.map((plan) => {
      const limits = typeof plan.limits === "object" ? plan.limits : {};
      const amount = plan.price || 0;
      const priceId = plan.stripePriceId || "";
      return {
        id: plan.id,
        name: plan.name,
        tier: limits?.tier || plan.slug || "free",
        // Get tier from limits.tier or fallback to slug
        description: plan.description,
        price: amount / 100,
        // Convert cents to dollars for display
        interval: plan.interval,
        features: plan.features,
        limits,
        stripePriceId: priceId
      };
    });
    res2.json(transformedPlans);
  } catch (error) {
    console.error("Error fetching subscription plans:", error);
    res2.status(500).json({ message: "Failed to fetch subscription plans" });
  }
});
router3.post("/api/checkout/subscription", isAuthenticated2, async (req2, res2) => {
  try {
    if (!stripe) {
      return res2.status(500).json({ message: "Stripe is not configured" });
    }
    const { priceId } = req2.body;
    if (!priceId) {
      return res2.status(400).json({ message: "Price ID is required" });
    }
    const userId = req2.user?.id;
    const user = await storage.getUser(userId);
    if (!user) {
      return res2.status(404).json({ message: "User not found" });
    }
    const plan = await db.select().from(subscriptionPlans).where(eq6(priceIdCol, priceId)).limit(1);
    if (!plan || plan.length === 0) {
      return res2.status(404).json({ message: "Invalid price ID" });
    }
    let customerId = user.stripeCustomerId;
    if (!customerId) {
      const customer = await stripe.customers.create({
        email: user.email,
        name: user.name || user.username,
        metadata: {
          userId: userId.toString()
        }
      });
      customerId = customer.id;
      await storage.updateUser(userId, { stripeCustomerId: customerId });
    }
    const session2 = await stripe.checkout.sessions.create({
      customer: customerId,
      payment_method_types: ["card"],
      line_items: [
        {
          price: priceId,
          quantity: 1
        }
      ],
      mode: "subscription",
      success_url: `${req2.headers.origin}/billing?success=true`,
      cancel_url: `${req2.headers.origin}/billing?canceled=true`,
      metadata: {
        userId: userId.toString()
      }
    });
    res2.json({ sessionId: session2.id, url: session2.url });
  } catch (error) {
    console.error("Error creating checkout session:", error);
    res2.status(500).json({ message: "Failed to create checkout session" });
  }
});
router3.get("/api/billing", isAuthenticated2, async (req2, res2) => {
  try {
    if (!stripe) {
      return res2.status(500).json({ message: "Stripe is not configured" });
    }
    const userId = req2.user?.id;
    const user = await storage.getUser(userId);
    if (!user) {
      return res2.status(404).json({ message: "User not found" });
    }
    const customerId = user.stripeCustomerId;
    if (!customerId) {
      return res2.json({
        subscription: null,
        plan: null,
        invoices: []
      });
    }
    let subscription = null;
    let plan = null;
    if (user.stripeSubscriptionId) {
      try {
        subscription = await stripe.subscriptions.retrieve(user.stripeSubscriptionId);
        if (subscription.items.data[0]?.price.id) {
          const dbPlan = await db.select().from(subscriptionPlans).where(eq6(priceIdCol, subscription.items.data[0].price.id)).limit(1);
          if (dbPlan && dbPlan.length > 0) {
            const limits = typeof dbPlan[0].limits === "object" ? dbPlan[0].limits : {};
            const amount = dbPlan[0].price || 0;
            plan = {
              ...dbPlan[0],
              price: amount / 100,
              // Convert to dollars for display
              tier: limits?.tier || dbPlan[0].slug || "free"
            };
          }
        }
      } catch (error) {
        console.error("Error retrieving subscription:", error);
        subscription = null;
      }
    }
    const invoices = await stripe.invoices.list({
      customer: customerId,
      limit: 5
    });
    const subscriptionData = subscription ? {
      id: subscription.id,
      status: subscription.status,
      currentPeriodStart: new Date(subscription.current_period_start * 1e3).toISOString(),
      currentPeriodEnd: new Date(subscription.current_period_end * 1e3).toISOString(),
      cancelAtPeriodEnd: subscription.cancel_at_period_end
    } : null;
    const invoicesData = invoices.data.map((invoice) => ({
      id: invoice.id,
      number: invoice.number,
      status: invoice.status,
      amount: invoice.amount_due / 100,
      currency: invoice.currency,
      date: new Date(invoice.created * 1e3).toISOString(),
      url: invoice.hosted_invoice_url
    }));
    res2.json({
      subscription: subscriptionData,
      plan,
      invoices: invoicesData
    });
  } catch (error) {
    console.error("Error fetching billing information:", error);
    res2.status(500).json({ message: "Failed to fetch billing information" });
  }
});
router3.post("/api/billing-portal", isAuthenticated2, async (req2, res2) => {
  try {
    if (!stripe) {
      return res2.status(500).json({ message: "Stripe is not configured" });
    }
    const userId = req2.user?.id;
    const user = await storage.getUser(userId);
    if (!user) {
      return res2.status(404).json({ message: "User not found" });
    }
    const customerId = user.stripeCustomerId;
    if (!customerId) {
      return res2.status(400).json({ message: "User does not have a Stripe customer ID" });
    }
    const session2 = await stripe.billingPortal.sessions.create({
      customer: customerId,
      return_url: `${req2.headers.origin}/billing`
    });
    res2.json({ url: session2.url });
  } catch (error) {
    console.error("Error creating billing portal session:", error);
    res2.status(500).json({ message: "Failed to create billing portal session" });
  }
});
var subscription_routes_default = router3;

// server/routes/social-routes.ts
import { Router as Router2 } from "express";
var router4 = Router2();
var userServices = /* @__PURE__ */ new Map();
var getSocialMonitoringService = async (req2, res2, next) => {
  try {
    const user = req2.user;
    if (!user || !user.id) {
      return res2.status(401).json({ error: "Authentication required" });
    }
    const userId = user.id;
    if (!userServices.has(userId)) {
      const service = new SocialMonitoringService(userId);
      await service.initialize();
      userServices.set(userId, service);
    }
    req2.socialMonitorService = userServices.get(userId);
    next();
  } catch (error) {
    console.error("Error initializing social monitoring service:", error);
    res2.status(500).json({ error: "Failed to initialize monitoring service" });
  }
};
router4.use((req2, res2, next) => {
  if (!req2.isAuthenticated()) {
    return res2.status(401).json({ message: "Unauthorized" });
  }
  next();
});
router4.use(getSocialMonitoringService);
router4.get("/connectors", async (req2, res2) => {
  try {
    const connectors = await req2.socialMonitorService.getConnectors();
    const sanitizedConnectors = connectors.map((c) => ({
      id: c.id,
      name: c.name,
      platform: c.platform,
      isActive: c.isActive,
      createdAt: c.createdAt,
      // Include only public credential fields for UI display
      apiKeyProvided: Boolean(c.credentials?.apiKey),
      accessTokenProvided: Boolean(c.credentials?.accessToken),
      bearerTokenProvided: Boolean(c.credentials?.bearerToken),
      clientIdProvided: Boolean(c.credentials?.clientId)
    }));
    res2.json(sanitizedConnectors);
  } catch (error) {
    console.error("Error getting social connectors:", error);
    res2.status(500).json({ error: "Failed to get social connectors" });
  }
});
router4.post("/connectors", async (req2, res2) => {
  try {
    const user = req2.user;
    const validatedData = insertSocialConnectorSchema.parse({
      ...req2.body,
      userId: user.id
    });
    const connector = await req2.socialMonitorService.createConnector(
      validatedData.platform,
      validatedData.name,
      validatedData.credentials || {}
    );
    res2.status(201).json({
      id: connector.id,
      platform: connector.platform,
      name: connector.name,
      isActive: connector.isActive,
      createdAt: connector.createdAt
    });
  } catch (error) {
    console.error("Error creating social connector:", error);
    res2.status(400).json({ error: "Failed to create social connector" });
  }
});
router4.get("/connectors/:id", async (req2, res2) => {
  try {
    const connector = await req2.socialMonitorService.getConnector(parseInt(req2.params.id));
    res2.json({
      id: connector.id,
      platform: connector.getPlatform(),
      name: connector.getName(),
      isAuthenticated: await connector.isAuthenticated()
    });
  } catch (error) {
    console.error(`Error getting connector ${req2.params.id}:`, error);
    res2.status(404).json({ error: "Connector not found or access denied" });
  }
});
router4.delete("/connectors/:id", async (req2, res2) => {
  try {
    await req2.socialMonitorService.deleteConnector(parseInt(req2.params.id));
    res2.status(204).send();
  } catch (error) {
    console.error(`Error deleting connector ${req2.params.id}:`, error);
    res2.status(404).json({ error: "Connector not found or access denied" });
  }
});
router4.post("/search", async (req2, res2) => {
  try {
    const { keywords, accounts, limit, sort, platforms } = req2.body;
    if (!keywords || !Array.isArray(keywords) || keywords.length === 0) {
      return res2.status(400).json({ error: "At least one keyword is required" });
    }
    const results = await req2.socialMonitorService.search({
      keywords,
      accounts,
      limit: limit || 100,
      sort: sort || "recent",
      platforms
    });
    res2.json(results);
  } catch (error) {
    console.error("Error searching social platforms:", error);
    res2.status(500).json({ error: "Failed to search social platforms" });
  }
});
router4.get("/monitors", async (req2, res2) => {
  try {
    const monitors = await req2.socialMonitorService.getMonitors();
    res2.json(monitors);
  } catch (error) {
    console.error("Error getting social monitors:", error);
    res2.status(500).json({ error: "Failed to get social monitors" });
  }
});
router4.post("/monitors", async (req2, res2) => {
  try {
    const user = req2.user;
    const validatedData = insertSocialMonitorSchema.parse({
      ...req2.body,
      userId: user.id
    });
    const monitor = await req2.socialMonitorService.createMonitor(
      validatedData.name,
      validatedData.description || null,
      validatedData.platforms,
      validatedData.keywords,
      validatedData.accounts || null,
      validatedData.frequency,
      validatedData.alertThreshold || null
    );
    res2.status(201).json(monitor);
  } catch (error) {
    console.error("Error creating social monitor:", error);
    res2.status(400).json({ error: "Failed to create social monitor" });
  }
});
router4.get("/monitors/:id", async (req2, res2) => {
  try {
    const monitor = await req2.socialMonitorService.getMonitor(parseInt(req2.params.id));
    res2.json(monitor);
  } catch (error) {
    console.error(`Error getting monitor ${req2.params.id}:`, error);
    res2.status(404).json({ error: "Monitor not found or access denied" });
  }
});
router4.patch("/monitors/:id", async (req2, res2) => {
  try {
    const allowedUpdates = [
      "name",
      "description",
      "platforms",
      "keywords",
      "accounts",
      "frequency",
      "alertThreshold",
      "isActive"
    ];
    const updates = Object.keys(req2.body).filter((key) => allowedUpdates.includes(key)).reduce((obj, key) => {
      obj[key] = req2.body[key];
      return obj;
    }, {});
    const updatedMonitor = await req2.socialMonitorService.updateMonitor(
      parseInt(req2.params.id),
      updates
    );
    res2.json(updatedMonitor);
  } catch (error) {
    console.error(`Error updating monitor ${req2.params.id}:`, error);
    res2.status(404).json({ error: "Monitor not found or access denied" });
  }
});
router4.delete("/monitors/:id", async (req2, res2) => {
  try {
    await req2.socialMonitorService.deleteMonitor(parseInt(req2.params.id));
    res2.status(204).send();
  } catch (error) {
    console.error(`Error deleting monitor ${req2.params.id}:`, error);
    res2.status(404).json({ error: "Monitor not found or access denied" });
  }
});
router4.get("/monitors/:id/results", async (req2, res2) => {
  try {
    const limit = req2.query.limit ? parseInt(req2.query.limit) : 100;
    const results = await req2.socialMonitorService.getMonitorResults(
      parseInt(req2.params.id),
      limit
    );
    res2.json(results);
  } catch (error) {
    console.error(`Error getting results for monitor ${req2.params.id}:`, error);
    res2.status(404).json({ error: "Monitor not found or access denied" });
  }
});
router4.get("/monitors/:id/alerts", async (req2, res2) => {
  try {
    const limit = req2.query.limit ? parseInt(req2.query.limit) : 100;
    const alerts = await req2.socialMonitorService.getMonitorAlerts(
      parseInt(req2.params.id),
      limit
    );
    res2.json(alerts);
  } catch (error) {
    console.error(`Error getting alerts for monitor ${req2.params.id}:`, error);
    res2.status(404).json({ error: "Monitor not found or access denied" });
  }
});
router4.patch("/alerts/:id/read", async (req2, res2) => {
  try {
    await req2.socialMonitorService.markAlertRead(parseInt(req2.params.id));
    res2.status(204).send();
  } catch (error) {
    console.error(`Error marking alert ${req2.params.id} as read:`, error);
    res2.status(404).json({ error: "Alert not found or access denied" });
  }
});
var social_routes_default = router4;

// server/routes/scraping-routes.ts
import { Router as Router3 } from "express";

// server/services/scraping/BaseScraper.ts
var BaseScraper = class {
  config;
  startTime = 0;
  endTime = 0;
  /**
   * Constructor for BaseScraper
   * 
   * @param config The base configuration for the scraper
   */
  constructor(config) {
    this.config = config;
  }
  /**
   * Get the runtime of the last scraping operation
   * 
   * @returns Runtime in milliseconds
   */
  getRuntime() {
    return this.endTime - this.startTime;
  }
  /**
   * Helper to start timing the scrape operation
   */
  startTimer() {
    this.startTime = Date.now();
  }
  /**
   * Helper to end timing the scrape operation
   */
  endTimer() {
    this.endTime = Date.now();
  }
  /**
   * Check if the config is valid
   * 
   * @returns True if valid, false otherwise
   */
  validateConfig() {
    return !!this.config && !!this.config.url;
  }
  /**
   * Sleep for the specified number of milliseconds
   * 
   * @param ms Milliseconds to sleep
   */
  async sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  /**
   * Handle rate limiting with backoff
   * 
   * @param attempt Current attempt number
   */
  async handleRateLimit(attempt = 0) {
    const baseDelay = 1e3;
    const maxAttempts = this.config.retries || 3;
    if (attempt >= maxAttempts) {
      throw new Error(`Rate limit exceeded after ${maxAttempts} attempts`);
    }
    const delay = baseDelay * Math.pow(2, attempt) * (0.5 + Math.random() * 0.5);
    await this.sleep(delay);
  }
};

// server/services/scraping/python/BasePythonScraper.ts
import * as fs2 from "fs";
import * as path3 from "path";
import { exec } from "child_process";
import { v4 as uuid } from "uuid";
import * as os from "os";
var BasePythonScraper = class extends BaseScraper {
  tempDir;
  pythonScriptPath;
  outputPath;
  /**
   * Constructor for BasePythonScraper
   * 
   * @param config The base configuration for the scraper
   */
  constructor(config) {
    super(config);
    this.tempDir = path3.join(os.tmpdir(), `scraper-${uuid()}`);
    fs2.mkdirSync(this.tempDir, { recursive: true });
    this.pythonScriptPath = path3.join(this.tempDir, "scraper.py");
    this.outputPath = path3.join(this.tempDir, "output.json");
  }
  /**
   * Run the scraper by generating and executing a Python script
   */
  async scrape() {
    try {
      if (!this.validateConfig()) {
        throw new Error("Invalid scraper configuration");
      }
      this.startTimer();
      const pythonScript = this.generatePythonScript();
      fs2.writeFileSync(this.pythonScriptPath, pythonScript);
      await this.executePythonScript();
      const output = this.readOutput();
      this.endTimer();
      this.cleanup();
      return output;
    } catch (error) {
      this.cleanup();
      throw error;
    }
  }
  /**
   * Execute the Python script
   */
  async executePythonScript() {
    return new Promise((resolve, reject) => {
      exec(`python ${this.pythonScriptPath}`, {
        timeout: this.config.timeout || 6e4
        // Default timeout: 60 seconds
      }, (error, stdout, stderr) => {
        if (error) {
          console.error("Python script execution error:", error);
          console.error("Standard error output:", stderr);
          return reject(new Error(`Python execution error: ${error.message}`));
        }
        if (stderr) {
          console.warn("Python script stderr:", stderr);
        }
        console.log("Python script stdout:", stdout);
        resolve();
      });
    });
  }
  /**
   * Read the output file
   */
  readOutput() {
    try {
      if (!fs2.existsSync(this.outputPath)) {
        throw new Error("Output file not found");
      }
      const outputContent = fs2.readFileSync(this.outputPath, "utf-8");
      return JSON.parse(outputContent);
    } catch (error) {
      throw new Error(`Error reading output: ${error.message}`);
    }
  }
  /**
   * Clean up temporary files
   */
  cleanup() {
    try {
      if (fs2.existsSync(this.pythonScriptPath)) {
        fs2.unlinkSync(this.pythonScriptPath);
      }
      if (fs2.existsSync(this.outputPath)) {
        fs2.unlinkSync(this.outputPath);
      }
      try {
        fs2.rmdirSync(this.tempDir);
      } catch (error) {
        console.warn("Failed to remove temp directory:", error);
      }
    } catch (error) {
      console.warn("Error during cleanup:", error);
    }
  }
};

// server/services/scraping/python/BeautifulSoupScraper.ts
var BeautifulSoupScraper = class extends BasePythonScraper {
  config;
  /**
   * Constructor for BeautifulSoup scraper
   * 
   * @param config The BeautifulSoup scraper configuration
   */
  constructor(config) {
    super(config);
    this.config = config;
  }
  /**
   * Generate Python script for BeautifulSoup scraping
   */
  generatePythonScript() {
    const headers = this.config.headers || {
      "User-Agent": this.config.userAgent || "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
    };
    const selectors = JSON.stringify(this.config.selectors);
    return `
import json
import requests
from bs4 import BeautifulSoup
import time
import random
import sys

# Configuration
url = "${this.config.url}"
headers = ${JSON.stringify(headers)}
selectors = ${selectors}
timeout = ${this.config.timeout || 30}
request_delay = ${this.config.requestDelay || 0}
output_path = "${this.outputPath.replace(/\\/g, "\\\\")}"
parse_js = ${this.config.parseJs ? "True" : "False"}
encoding = "${this.config.encoding || "utf-8"}"

# Add delay if configured
if request_delay > 0:
    delay = request_delay + (random.random() * request_delay * 0.5)  # Add jitter
    time.sleep(delay)

try:
    # Make the request
    print(f"Fetching {url}...")
    response = requests.get(url, headers=headers, timeout=timeout)
    response.raise_for_status()
    
    # Set encoding
    if encoding:
        response.encoding = encoding
    
    # Parse HTML
    print("Parsing HTML...")
    soup = BeautifulSoup(response.text, 'html.parser')
    
    # Extract data using selectors
    result = {}
    
    for key, selector in selectors.items():
        elements = soup.select(selector)
        
        if len(elements) == 1:
            # Single element handling
            element = elements[0]
            if element.name == 'a':
                result[key] = {
                    'text': element.get_text(strip=True),
                    'href': element.get('href', '')
                }
            elif element.name == 'img':
                result[key] = {
                    'alt': element.get('alt', ''),
                    'src': element.get('src', '')
                }
            else:
                result[key] = element.get_text(strip=True)
        else:
            # Multiple elements handling (create array)
            result[key] = []
            for element in elements:
                if element.name == 'a':
                    result[key].append({
                        'text': element.get_text(strip=True),
                        'href': element.get('href', '')
                    })
                elif element.name == 'img':
                    result[key].append({
                        'alt': element.get('alt', ''),
                        'src': element.get('src', '')
                    })
                else:
                    result[key].append(element.get_text(strip=True))
    
    # Add metadata
    result['__metadata'] = {
        'timestamp': time.time(),
        'url': url,
        'status_code': response.status_code,
        'headers': dict(response.headers),
        'content_length': len(response.content)
    }
    
    # Save to file
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(result, f, ensure_ascii=False, indent=2)
    
    print(f"Scraping completed and saved to {output_path}")
    
except Exception as e:
    error_data = {
        'error': str(e),
        'type': type(e).__name__,
        '__metadata': {
            'timestamp': time.time(),
            'url': url
        }
    }
    
    # Save error to file
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(error_data, f, ensure_ascii=False, indent=2)
    
    print(f"Error: {str(e)}", file=sys.stderr)
    sys.exit(1)
`;
  }
  /**
   * Override validateConfig to check for BeautifulSoup specific requirements
   */
  validateConfig() {
    return super.validateConfig() && !!this.config.selectors && Object.keys(this.config.selectors).length > 0;
  }
};

// server/services/scraping/types.ts
var ScraperType = /* @__PURE__ */ ((ScraperType2) => {
  ScraperType2["BeautifulSoup"] = "beautifulsoup";
  ScraperType2["Scrapy"] = "scrapy";
  ScraperType2["Playwright"] = "playwright";
  ScraperType2["Puppeteer"] = "puppeteer";
  ScraperType2["Selenium"] = "selenium";
  ScraperType2["JobSpy"] = "jobspy";
  ScraperType2["Cloudscraper"] = "cloudscraper";
  return ScraperType2;
})(ScraperType || {});

// server/services/scraping/ScraperFactory.ts
var ScraperFactory = class _ScraperFactory {
  static instance;
  /**
   * Get the singleton instance of ScraperFactory
   */
  static getInstance() {
    if (!_ScraperFactory.instance) {
      _ScraperFactory.instance = new _ScraperFactory();
    }
    return _ScraperFactory.instance;
  }
  /**
   * Private constructor to enforce singleton pattern
   */
  constructor() {
  }
  /**
   * Check if a scraper type is supported
   */
  isTypeSupported(type) {
    const supportedTypes = [
      "beautifulsoup" /* BeautifulSoup */
      // Add more supported scraper types as they are implemented
    ];
    return supportedTypes.includes(type);
  }
  /**
   * Create a scraper instance based on type and configuration
   */
  async createScraper(type, config) {
    switch (type) {
      case "beautifulsoup" /* BeautifulSoup */:
        return new BeautifulSoupScraper(config);
      // Add cases for other scraper types as they are implemented
      default:
        throw new Error(`Unsupported scraper type: ${type}`);
    }
  }
};

// server/services/scraping/ScrapingService.ts
import { eq as eq7, desc as desc4 } from "drizzle-orm";

// server/services/scraping/utils/textDiff.ts
import { diffWords, diffLines, diffJson, diffArrays, convertChangesToDMP } from "diff";
import * as cheerio2 from "cheerio";
function diffText(oldText, newText, options2 = {}) {
  if (options2.ignoreWhitespace) {
    oldText = oldText.replace(/\s+/g, " ").trim();
    newText = newText.replace(/\s+/g, " ").trim();
  }
  if (options2.ignoreCase) {
    oldText = oldText.toLowerCase();
    newText = newText.toLowerCase();
  }
  let diffResult = [];
  if (options2.mode === "lines") {
    diffResult = diffLines(oldText, newText);
  } else if (options2.mode === "json") {
    try {
      const oldJson = typeof oldText === "string" ? JSON.parse(oldText) : oldText;
      const newJson = typeof newText === "string" ? JSON.parse(newText) : newText;
      diffResult = diffJson(oldJson, newJson);
    } catch (error) {
      console.warn("Failed to parse JSON, falling back to line-based diff", error);
      diffResult = diffLines(oldText, newText);
    }
  } else if (options2.mode === "arrays") {
    try {
      const oldArray = typeof oldText === "string" ? JSON.parse(oldText) : oldText;
      const newArray = typeof newText === "string" ? JSON.parse(newText) : newText;
      if (!Array.isArray(oldArray) || !Array.isArray(newArray)) {
        throw new Error("Inputs are not arrays");
      }
      diffResult = diffArrays(oldArray, newArray);
    } catch (error) {
      console.warn("Failed to parse arrays, falling back to word-based diff", error);
      diffResult = diffWords(oldText, newText);
    }
  } else if (options2.mode === "html") {
    return diffHtml(oldText, newText, options2);
  } else {
    diffResult = diffWords(oldText, newText);
  }
  const added = [];
  const removed = [];
  const unchanged = [];
  let addedCount = 0;
  let removedCount = 0;
  let unchangedCount = 0;
  diffResult.forEach((part) => {
    if (part.added) {
      added.push(part.value);
      addedCount += part.count || part.value.length;
    } else if (part.removed) {
      removed.push(part.value);
      removedCount += part.count || part.value.length;
    } else {
      unchanged.push(part.value);
      unchangedCount += part.count || part.value.length;
    }
  });
  const totalCount = addedCount + removedCount + unchangedCount;
  const changePercentage = totalCount > 0 ? (addedCount + removedCount) / totalCount : 0;
  const patches = convertChangesToDMP(diffResult);
  return {
    added,
    removed,
    unchanged,
    changes: {
      added: addedCount,
      removed: removedCount,
      unchanged: unchangedCount
    },
    changePercentage,
    patches
  };
}
function diffHtml(oldHtml, newHtml, options2) {
  const textDiff = diffText(oldHtml, newHtml, { ...options2, mode: "words" });
  const $old = cheerio2.load(oldHtml);
  const $new = cheerio2.load(newHtml);
  const htmlChanges = [];
  $new("*").each((i, elem) => {
    const $elem = $new(elem);
    const selector = getSelector($elem);
    if (!selector) return;
    const $oldElem = $old(selector);
    if ($oldElem.length === 0) {
      htmlChanges.push({
        selector,
        before: "",
        after: $elem.html() || $elem.text() || "",
        context: options2.htmlContext ? getContext($new, $elem) : void 0
      });
    } else if ($oldElem.html() !== $elem.html()) {
      htmlChanges.push({
        selector,
        before: $oldElem.html() || $oldElem.text() || "",
        after: $elem.html() || $elem.text() || "",
        context: options2.htmlContext ? getContext($new, $elem) : void 0
      });
    }
  });
  $old("*").each((i, elem) => {
    const $elem = $old(elem);
    const selector = getSelector($elem);
    if (!selector) return;
    if ($new(selector).length === 0) {
      htmlChanges.push({
        selector,
        before: $elem.html() || $elem.text() || "",
        after: "",
        context: options2.htmlContext ? getContext($old, $elem) : void 0
      });
    }
  });
  return {
    ...textDiff,
    htmlChanges
  };
}
function getSelector($elem) {
  const id = $elem.attr("id");
  if (id) {
    return `#${id}`;
  }
  const classes = $elem.attr("class");
  if (classes) {
    const classList = classes.split(/\s+/).filter(Boolean);
    if (classList.length > 0) {
      return `.${classList.join(".")}`;
    }
  }
  const tagName = $elem.prop("tagName")?.toLowerCase();
  if (!tagName || tagName === "html" || tagName === "body") {
    return null;
  }
  const name = $elem.attr("name");
  const href = $elem.attr("href");
  const src = $elem.attr("src");
  if (name) {
    return `${tagName}[name="${name}"]`;
  }
  if (href && !href.includes("javascript:")) {
    return `${tagName}[href="${href}"]`;
  }
  if (src) {
    return `${tagName}[src="${src}"]`;
  }
  return null;
}
function getContext($, $elem) {
  const $parent = $elem.parent();
  if (!$parent || $parent.length === 0) {
    return "";
  }
  const parentHtml = $.html($parent);
  if (parentHtml.length > 500) {
    return parentHtml.substring(0, 500) + "...";
  }
  return parentHtml;
}

// server/services/scraping/ScrapingService.ts
import { v4 as uuid2 } from "uuid";
var ScrapingService = class {
  scraperFactory;
  constructor() {
    this.scraperFactory = ScraperFactory.getInstance();
  }
  /**
   * Create a new scraping job
   */
  async createJob(userId, name, description, type, config) {
    const jobId = uuid2();
    const [job] = await db.insert(scrapingJobs).values({
      id: jobId,
      userId,
      name,
      description,
      type,
      config,
      status: "created" /* Created */
    }).returning();
    return job;
  }
  /**
   * Get all scraping jobs for a user
   */
  async getJobsByUser(userId) {
    const jobs = await db.select().from(scrapingJobs).where(eq7(scrapingJobs.userId, userId)).orderBy(desc4(scrapingJobs.createdAt));
    return jobs;
  }
  /**
   * Get a specific scraping job
   */
  async getJob(jobId) {
    const [job] = await db.select().from(scrapingJobs).where(eq7(scrapingJobs.id, jobId));
    return job;
  }
  /**
   * Get results for a specific job
   */
  async getJobResults(jobId) {
    const results = await db.select().from(scrapingResults).where(eq7(scrapingResults.jobId, jobId)).orderBy(desc4(scrapingResults.createdAt));
    return results;
  }
  /**
   * Delete a scraping job
   */
  async deleteJob(jobId) {
    await db.delete(scrapingResults).where(eq7(scrapingResults.jobId, jobId));
    await db.delete(scrapingJobs).where(eq7(scrapingJobs.id, jobId));
    return true;
  }
  /**
   * Run a scraping job
   */
  async runJob(jobId) {
    const job = await this.getJob(jobId);
    if (!job) {
      throw new Error("Job not found");
    }
    await db.update(scrapingJobs).set({
      status: "running" /* Running */,
      lastRunAt: /* @__PURE__ */ new Date()
    }).where(eq7(scrapingJobs.id, jobId));
    try {
      const scraper = await this.scraperFactory.createScraper(job.type, job.config);
      const data = await scraper.scrape();
      const [result2] = await db.insert(scrapingResults).values({
        jobId,
        success: true,
        data,
        metadata: {
          runtime: (/* @__PURE__ */ new Date()).getTime() - new Date(job.lastRunAt || job.createdAt).getTime(),
          itemCount: Array.isArray(data) ? data.length : 1
        }
      }).returning();
      await db.update(scrapingJobs).set({
        status: "completed" /* Completed */,
        lastCompletedAt: /* @__PURE__ */ new Date()
      }).where(eq7(scrapingJobs.id, jobId));
      return result2;
    } catch (error) {
      console.error("Error running scraping job:", error);
      const [result2] = await db.insert(scrapingResults).values({
        jobId,
        success: false,
        error: error.message,
        metadata: {
          stack: error.stack
        }
      }).returning();
      await db.update(scrapingJobs).set({
        status: "failed" /* Failed */
      }).where(eq7(scrapingJobs.id, jobId));
      return result2;
    }
  }
  /**
   * Run a scraper without saving as a job
   */
  async scrape(type, config) {
    try {
      if (!this.scraperFactory.isTypeSupported(type)) {
        throw new Error(`Unsupported scraper type: ${type}`);
      }
      const scraper = await this.scraperFactory.createScraper(type, config);
      const data = await scraper.scrape();
      return {
        success: true,
        data,
        metadata: {
          runtime: scraper.getRuntime(),
          itemCount: Array.isArray(data) ? data.length : 1
        }
      };
    } catch (error) {
      console.error("Error running scraper:", error);
      return {
        success: false,
        error: error.message,
        metadata: {
          stack: error.stack
        }
      };
    }
  }
  /**
   * Create a change detection monitor
   */
  async createChangeDetectionMonitor(userId, name, url, selectors, frequency, diffThreshold = 0.05, ignoredSelectors) {
    const [monitor] = await db.insert(changeDetectionMonitors).values({
      userId,
      name,
      url,
      selectors,
      frequency,
      diffThreshold,
      ignoredSelectors: ignoredSelectors || [],
      isActive: true
    }).returning();
    await this.runChangeDetection(monitor.id, true);
    return monitor;
  }
  /**
   * Get all change detection monitors for a user
   */
  async getChangeDetectionMonitors(userId) {
    const monitors = await db.select().from(changeDetectionMonitors).where(eq7(changeDetectionMonitors.userId, userId)).orderBy(desc4(changeDetectionMonitors.createdAt));
    return monitors;
  }
  /**
   * Update a change detection monitor
   */
  async updateChangeDetectionMonitor(monitorId, updates) {
    const [updatedMonitor] = await db.update(changeDetectionMonitors).set({
      ...updates,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq7(changeDetectionMonitors.id, monitorId)).returning();
    return updatedMonitor;
  }
  /**
   * Delete a change detection monitor
   */
  async deleteChangeDetectionMonitor(monitorId) {
    await db.delete(changeDetectionAlerts).where(eq7(changeDetectionAlerts.monitorId, monitorId));
    await db.delete(changeDetectionMonitors).where(eq7(changeDetectionMonitors.id, monitorId));
    return true;
  }
  /**
   * Run a change detection check
   */
  async runChangeDetection(monitorId, isBaseline = false) {
    const [monitor] = await db.select().from(changeDetectionMonitors).where(eq7(changeDetectionMonitors.id, monitorId));
    if (!monitor) {
      throw new Error("Monitor not found");
    }
    try {
      const scraper = await this.scraperFactory.createScraper("beautifulsoup" /* BeautifulSoup */, {
        url: monitor.url,
        selectors: monitor.selectors,
        waitForSelector: Object.values(monitor.selectors)[0]
        // Use first selector as wait condition
      });
      const content2 = await scraper.scrape();
      if (isBaseline || !monitor.baselineContent) {
        await db.update(changeDetectionMonitors).set({
          baselineContent: content2,
          lastCheckedAt: /* @__PURE__ */ new Date()
        }).where(eq7(changeDetectionMonitors.id, monitorId));
        return null;
      }
      const diffResult = diffText(
        JSON.stringify(monitor.baselineContent),
        JSON.stringify(content2),
        { ignoreWhitespace: true }
      );
      if (diffResult.changePercentage > monitor.diffThreshold) {
        const [alert] = await db.insert(changeDetectionAlerts).values({
          monitorId,
          previousContent: monitor.baselineContent,
          currentContent: content2,
          diffPct: diffResult.changePercentage,
          diffDetails: diffResult,
          status: "unread" /* Unread */
        }).returning();
        await db.update(changeDetectionMonitors).set({
          baselineContent: content2,
          // Update baseline to current
          lastCheckedAt: /* @__PURE__ */ new Date(),
          lastChangedAt: /* @__PURE__ */ new Date()
        }).where(eq7(changeDetectionMonitors.id, monitorId));
        return alert;
      }
      await db.update(changeDetectionMonitors).set({
        lastCheckedAt: /* @__PURE__ */ new Date()
      }).where(eq7(changeDetectionMonitors.id, monitorId));
      return null;
    } catch (error) {
      console.error("Error running change detection:", error);
      await db.update(changeDetectionMonitors).set({
        lastCheckedAt: /* @__PURE__ */ new Date()
      }).where(eq7(changeDetectionMonitors.id, monitorId));
      throw error;
    }
  }
  /**
   * Get all alerts for a monitor
   */
  async getChangeDetectionAlerts(monitorId) {
    const alerts = await db.select().from(changeDetectionAlerts).where(eq7(changeDetectionAlerts.monitorId, monitorId)).orderBy(desc4(changeDetectionAlerts.createdAt));
    return alerts;
  }
  /**
   * Mark an alert as read
   */
  async markChangeDetectionAlertAsRead(alertId) {
    const [alert] = await db.update(changeDetectionAlerts).set({
      status: "read" /* Read */,
      readAt: /* @__PURE__ */ new Date()
    }).where(eq7(changeDetectionAlerts.id, alertId)).returning();
    return alert;
  }
};

// server/routes/scraping-routes.ts
import { eq as eq8 } from "drizzle-orm";

// server/middleware/auth.ts
function isAuthenticated3(req2, res2, next) {
  if (req2.isAuthenticated()) {
    return next();
  }
  res2.status(401).json({ message: "Unauthorized" });
}

// server/routes/scraping-routes.ts
var router5 = Router3();
var scrapingService = new ScrapingService();
router5.get("/api/scrapers", isAuthenticated3, async (req2, res2) => {
  const types = Object.values(ScraperType);
  res2.json({ scrapers: types });
});
router5.post("/api/scraping-jobs", isAuthenticated3, async (req2, res2) => {
  try {
    const validatedData = insertScrapingJobSchema.parse(req2.body);
    const job = await scrapingService.createJob(
      req2.user.id,
      validatedData.name,
      validatedData.description,
      validatedData.type,
      validatedData.config
    );
    res2.status(201).json(job);
  } catch (error) {
    console.error("Error creating scraping job:", error);
    res2.status(400).json({ error: error.message });
  }
});
router5.get("/api/scraping-jobs", isAuthenticated3, async (req2, res2) => {
  try {
    const jobs = await scrapingService.getJobsByUser(req2.user.id);
    res2.json(jobs);
  } catch (error) {
    console.error("Error fetching scraping jobs:", error);
    res2.status(500).json({ error: error.message });
  }
});
router5.get("/api/scraping-jobs/:id", isAuthenticated3, async (req2, res2) => {
  try {
    const job = await scrapingService.getJob(req2.params.id);
    if (!job) {
      return res2.status(404).json({ error: "Job not found" });
    }
    if (job.userId !== req2.user.id) {
      return res2.status(403).json({ error: "Unauthorized" });
    }
    const results = await scrapingService.getJobResults(job.id);
    res2.json({ ...job, results });
  } catch (error) {
    console.error("Error fetching scraping job:", error);
    res2.status(500).json({ error: error.message });
  }
});
router5.post("/api/scraping-jobs/:id/run", isAuthenticated3, async (req2, res2) => {
  try {
    const job = await scrapingService.getJob(req2.params.id);
    if (!job) {
      return res2.status(404).json({ error: "Job not found" });
    }
    if (job.userId !== req2.user.id) {
      return res2.status(403).json({ error: "Unauthorized" });
    }
    const result2 = await scrapingService.runJob(job.id);
    res2.json(result2);
  } catch (error) {
    console.error("Error running scraping job:", error);
    res2.status(500).json({ error: error.message });
  }
});
router5.delete("/api/scraping-jobs/:id", isAuthenticated3, async (req2, res2) => {
  try {
    const job = await scrapingService.getJob(req2.params.id);
    if (!job) {
      return res2.status(404).json({ error: "Job not found" });
    }
    if (job.userId !== req2.user.id) {
      return res2.status(403).json({ error: "Unauthorized" });
    }
    await scrapingService.deleteJob(job.id);
    res2.json({ success: true });
  } catch (error) {
    console.error("Error deleting scraping job:", error);
    res2.status(500).json({ error: error.message });
  }
});
router5.post("/api/scrape", isAuthenticated3, async (req2, res2) => {
  try {
    const { type, config } = req2.body;
    if (!type || !config) {
      return res2.status(400).json({ error: "Type and config are required" });
    }
    if (!Object.values(ScraperType).includes(type)) {
      return res2.status(400).json({ error: "Invalid scraper type" });
    }
    const result2 = await scrapingService.scrape(type, config);
    res2.json(result2);
  } catch (error) {
    console.error("Error during ad-hoc scraping:", error);
    res2.status(500).json({ error: error.message });
  }
});
router5.get("/api/scraping-jobs/:id/results", isAuthenticated3, async (req2, res2) => {
  try {
    const job = await scrapingService.getJob(req2.params.id);
    if (!job) {
      return res2.status(404).json({ error: "Job not found" });
    }
    if (job.userId !== req2.user.id) {
      return res2.status(403).json({ error: "Unauthorized" });
    }
    const results = await scrapingService.getJobResults(job.id);
    res2.json(results);
  } catch (error) {
    console.error("Error fetching job results:", error);
    res2.status(500).json({ error: error.message });
  }
});
router5.post("/api/change-detection", isAuthenticated3, async (req2, res2) => {
  try {
    const { name, url, selectors, frequency, diffThreshold, ignoredSelectors } = req2.body;
    if (!name || !url || !selectors || !frequency) {
      return res2.status(400).json({ error: "Name, URL, selectors, and frequency are required" });
    }
    const monitor = await scrapingService.createChangeDetectionMonitor(
      req2.user.id,
      name,
      url,
      selectors,
      frequency,
      diffThreshold,
      ignoredSelectors
    );
    res2.status(201).json(monitor);
  } catch (error) {
    console.error("Error creating change detection monitor:", error);
    res2.status(400).json({ error: error.message });
  }
});
router5.get("/api/change-detection", isAuthenticated3, async (req2, res2) => {
  try {
    const monitors = await scrapingService.getChangeDetectionMonitors(req2.user.id);
    res2.json(monitors);
  } catch (error) {
    console.error("Error fetching change detection monitors:", error);
    res2.status(500).json({ error: error.message });
  }
});
router5.patch("/api/change-detection/:id", isAuthenticated3, async (req2, res2) => {
  try {
    const monitorId = parseInt(req2.params.id);
    if (isNaN(monitorId)) {
      return res2.status(400).json({ error: "Invalid monitor ID" });
    }
    const [monitor] = await db.select().from(changeDetectionMonitors).where(eq8(changeDetectionMonitors.id, monitorId));
    if (!monitor) {
      return res2.status(404).json({ error: "Monitor not found" });
    }
    if (monitor.userId !== req2.user.id) {
      return res2.status(403).json({ error: "Unauthorized" });
    }
    const updatedMonitor = await scrapingService.updateChangeDetectionMonitor(
      monitorId,
      req2.body
    );
    res2.json(updatedMonitor);
  } catch (error) {
    console.error("Error updating change detection monitor:", error);
    res2.status(500).json({ error: error.message });
  }
});
router5.delete("/api/change-detection/:id", isAuthenticated3, async (req2, res2) => {
  try {
    const monitorId = parseInt(req2.params.id);
    if (isNaN(monitorId)) {
      return res2.status(400).json({ error: "Invalid monitor ID" });
    }
    const [monitor] = await db.select().from(changeDetectionMonitors).where(eq8(changeDetectionMonitors.id, monitorId));
    if (!monitor) {
      return res2.status(404).json({ error: "Monitor not found" });
    }
    if (monitor.userId !== req2.user.id) {
      return res2.status(403).json({ error: "Unauthorized" });
    }
    await scrapingService.deleteChangeDetectionMonitor(monitorId);
    res2.json({ success: true });
  } catch (error) {
    console.error("Error deleting change detection monitor:", error);
    res2.status(500).json({ error: error.message });
  }
});
router5.post("/api/change-detection/:id/check", isAuthenticated3, async (req2, res2) => {
  try {
    const monitorId = parseInt(req2.params.id);
    if (isNaN(monitorId)) {
      return res2.status(400).json({ error: "Invalid monitor ID" });
    }
    const [monitor] = await db.select().from(changeDetectionMonitors).where(eq8(changeDetectionMonitors.id, monitorId));
    if (!monitor) {
      return res2.status(404).json({ error: "Monitor not found" });
    }
    if (monitor.userId !== req2.user.id) {
      return res2.status(403).json({ error: "Unauthorized" });
    }
    const alert = await scrapingService.runChangeDetection(monitorId);
    res2.json({
      success: true,
      changeDetected: !!alert,
      alert
    });
  } catch (error) {
    console.error("Error running change detection check:", error);
    res2.status(500).json({ error: error.message });
  }
});
router5.get("/api/change-detection/:id/alerts", isAuthenticated3, async (req2, res2) => {
  try {
    const monitorId = parseInt(req2.params.id);
    if (isNaN(monitorId)) {
      return res2.status(400).json({ error: "Invalid monitor ID" });
    }
    const [monitor] = await db.select().from(changeDetectionMonitors).where(eq8(changeDetectionMonitors.id, monitorId));
    if (!monitor) {
      return res2.status(404).json({ error: "Monitor not found" });
    }
    if (monitor.userId !== req2.user.id) {
      return res2.status(403).json({ error: "Unauthorized" });
    }
    const alerts = await scrapingService.getChangeDetectionAlerts(monitorId);
    res2.json(alerts);
  } catch (error) {
    console.error("Error fetching change detection alerts:", error);
    res2.status(500).json({ error: error.message });
  }
});
router5.post("/api/change-detection/alerts/:id/read", isAuthenticated3, async (req2, res2) => {
  try {
    const alertId = parseInt(req2.params.id);
    if (isNaN(alertId)) {
      return res2.status(400).json({ error: "Invalid alert ID" });
    }
    const [alert] = await db.select().from(changeDetectionAlerts).where(eq8(changeDetectionAlerts.id, alertId));
    if (!alert) {
      return res2.status(404).json({ error: "Alert not found" });
    }
    const [monitor] = await db.select().from(changeDetectionMonitors).where(eq8(changeDetectionMonitors.id, alert.monitorId));
    if (monitor.userId !== req2.user.id) {
      return res2.status(403).json({ error: "Unauthorized" });
    }
    const updatedAlert = await scrapingService.markChangeDetectionAlertAsRead(alertId);
    res2.json(updatedAlert);
  } catch (error) {
    console.error("Error marking alert as read:", error);
    res2.status(500).json({ error: error.message });
  }
});
var scraping_routes_default = router5;

// server/routes/agent-routes.ts
import express4 from "express";
import { z as z2 } from "zod";

// server/services/agent/protocols/ProtocolRegistry.ts
var ProtocolRegistry = class _ProtocolRegistry {
  static instance;
  protocols = /* @__PURE__ */ new Map();
  protocolMetadata = /* @__PURE__ */ new Map();
  // Private constructor for singleton pattern
  constructor() {
  }
  // Get singleton instance
  static getInstance() {
    if (!_ProtocolRegistry.instance) {
      _ProtocolRegistry.instance = new _ProtocolRegistry();
    }
    return _ProtocolRegistry.instance;
  }
  // Register a new protocol
  registerProtocol(name, protocolClass, metadata) {
    if (this.protocols.has(name)) {
      console.warn(`Protocol with name ${name} already registered. Overwriting.`);
    }
    this.protocols.set(name, protocolClass);
    this.protocolMetadata.set(name, metadata);
  }
  // Get a protocol by name
  getProtocol(name) {
    const protocol = this.protocols.get(name);
    if (!protocol) {
      throw new Error(`Protocol ${name} not found in registry`);
    }
    return protocol;
  }
  // Create a new instance of a protocol
  createProtocolInstance(name) {
    const ProtocolClass = this.getProtocol(name);
    return new ProtocolClass();
  }
  // Get metadata for a protocol
  getProtocolMetadata(name) {
    const metadata = this.protocolMetadata.get(name);
    if (!metadata) {
      throw new Error(`Metadata for protocol ${name} not found in registry`);
    }
    return metadata;
  }
  // List all registered protocols
  listProtocols() {
    return Array.from(this.protocols.keys()).map((name) => ({
      name,
      metadata: this.protocolMetadata.get(name)
    }));
  }
  // Check if a protocol is registered
  hasProtocol(name) {
    return this.protocols.has(name);
  }
  // Unregister a protocol
  unregisterProtocol(name) {
    if (!this.protocols.has(name)) {
      return false;
    }
    this.protocols.delete(name);
    this.protocolMetadata.delete(name);
    return true;
  }
};

// server/services/agent/protocols/AgentGPTProtocol.ts
import Anthropic3 from "@anthropic-ai/sdk";
var DEFAULT_MODEL = "claude-3-7-sonnet-20250219";
var AgentGPTProtocol = class {
  config = {
    systemPrompt: "You are a helpful AI assistant that completes one-shot tasks efficiently.",
    tools: [],
    modelName: DEFAULT_MODEL,
    temperature: 0.7,
    maxTokens: 1024,
    capabilities: [
      "single_shot" /* SINGLE_SHOT */,
      "tool_use" /* TOOL_USE */
    ]
  };
  anthropicClient = null;
  availableTools = [];
  initialized = false;
  /**
   * Get metadata about this protocol
   */
  getMetadata() {
    return {
      name: "AgentGPT",
      version: "1.0.0",
      description: "Protocol for standalone one-shot agents (prompt \u2192 task)",
      capabilities: [
        "single_shot" /* SINGLE_SHOT */,
        "tool_use" /* TOOL_USE */
      ],
      requiresAuthentication: true,
      supportedModels: [
        "claude-3-7-sonnet-20250219",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "claude-3-haiku-20240307",
        "gpt-4o",
        "gpt-4-turbo",
        "gpt-4"
      ]
    };
  }
  /**
   * Initialize the protocol with configuration
   */
  async init(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (this.config.modelName?.includes("claude")) {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY environment variable is required for Claude models");
      }
      this.anthropicClient = new Anthropic3({
        apiKey: process.env.ANTHROPIC_API_KEY
      });
    }
    this.availableTools = this.config.tools || [];
    this.initialized = true;
  }
  /**
   * Execute a task using this protocol
   */
  async execute(options2) {
    if (!this.initialized) {
      throw new Error("Protocol not initialized. Call init() first.");
    }
    const startTime2 = Date.now();
    try {
      if (options2.callbacks?.onStart) {
        options2.callbacks.onStart();
      }
      let systemPrompt = this.config.systemPrompt || "";
      const tools2 = options2.tools || this.availableTools;
      if (tools2.length > 0) {
        systemPrompt += "\n\nYou have access to the following tools:\n";
        tools2.forEach((tool) => {
          systemPrompt += `- ${tool.name}: ${tool.description}
`;
          systemPrompt += "  Parameters:\n";
          Object.entries(tool.parameters).forEach(([paramName, paramInfo]) => {
            systemPrompt += `    - ${paramName} (${paramInfo.type}${paramInfo.required ? ", required" : ""}): ${paramInfo.description}
`;
          });
        });
        systemPrompt += `
To use a tool, respond with a JSON object in the following format:
{
  "reasoning": "your step-by-step reasoning about what to do",
  "tool": "tool_name",
  "tool_input": {
    "param1": "value1",
    ...
  }
}

If you don't need to use a tool, respond with a JSON object in the following format:
{
  "reasoning": "your step-by-step reasoning",
  "response": "your final response"
}`;
      }
      if (this.config.modelName?.includes("claude")) {
        return await this.executeWithClaude(options2.task, systemPrompt, tools2, options2);
      } else {
        return await this.executeWithClaude(options2.task, systemPrompt, tools2, options2);
      }
    } catch (error) {
      log(`AgentGPT Protocol execution error: ${error}`, "agent");
      if (options2.callbacks?.onError) {
        options2.callbacks.onError(error);
      }
      throw error;
    }
  }
  /**
   * Execute with Claude model
   */
  async executeWithClaude(task, systemPrompt, tools2, options2) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const startTime2 = Date.now();
    try {
      const response = await this.anthropicClient.messages.create({
        model: this.config.modelName,
        max_tokens: this.config.maxTokens,
        temperature: this.config.temperature,
        system: systemPrompt,
        messages: [{ role: "user", content: task }]
      });
      const content2 = response.content[0].text;
      const toolResults = await this.parseResponseAndExecuteTools(content2, tools2, options2);
      const agentResponse = {
        response: content2,
        usedTools: toolResults,
        executionTime: Date.now() - startTime2
      };
      if (options2.callbacks?.onComplete) {
        options2.callbacks.onComplete(agentResponse);
      }
      return agentResponse;
    } catch (error) {
      log(`Claude execution error: ${error}`, "agent");
      throw error;
    }
  }
  /**
   * Parse the response and execute any tools that were called
   */
  async parseResponseAndExecuteTools(content2, tools2, options2) {
    if (tools2.length === 0) {
      return void 0;
    }
    try {
      let parsedResponse;
      const jsonMatch = content2.match(/```json\n([\s\S]*?)\n```/) || content2.match(/```([\s\S]*?)```/) || content2.match(/{[\s\S]*?}/);
      if (jsonMatch) {
        try {
          parsedResponse = JSON.parse(jsonMatch[0].replace(/```json\n|```/g, ""));
        } catch (e) {
          try {
            parsedResponse = JSON.parse(jsonMatch[1].trim());
          } catch (e2) {
            parsedResponse = null;
          }
        }
      }
      if (!parsedResponse) {
        return void 0;
      }
      if (parsedResponse.tool && parsedResponse.tool_input) {
        const toolName = parsedResponse.tool;
        const toolInput = parsedResponse.tool_input;
        const tool = tools2.find((t) => t.name === toolName);
        if (tool) {
          try {
            if (options2.callbacks?.onToolUse) {
              options2.callbacks.onToolUse({
                toolName,
                input: toolInput,
                output: void 0,
                error: void 0
              });
            }
            const result2 = await tool.execute(toolInput);
            if (options2.callbacks?.onToolUse) {
              options2.callbacks.onToolUse({
                toolName,
                input: toolInput,
                output: result2,
                error: void 0
              });
            }
            return [{
              tool: toolName,
              input: toolInput,
              output: result2
            }];
          } catch (error) {
            log(`Tool execution error: ${error}`, "agent");
            if (options2.callbacks?.onToolUse) {
              options2.callbacks.onToolUse({
                toolName,
                input: toolInput,
                output: void 0,
                error: error.message
              });
            }
            return [{
              tool: toolName,
              input: toolInput,
              output: `Error: ${error.message}`
            }];
          }
        }
      }
      return void 0;
    } catch (error) {
      log(`Error parsing response and executing tools: ${error}`, "agent");
      return void 0;
    }
  }
  /**
   * Get available tools
   */
  getAvailableTools() {
    return this.availableTools;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.tools) {
      this.availableTools = config.tools;
    }
  }
  /**
   * Get supported execution modes
   */
  getSupportedExecutionModes() {
    return ["synchronous" /* SYNCHRONOUS */];
  }
  /**
   * Check if protocol supports a specific capability
   */
  supportsCapability(capability) {
    return this.config.capabilities.includes(capability);
  }
  /**
   * Get current protocol configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    this.initialized = false;
    return Promise.resolve();
  }
};

// server/services/agent/protocols/AutoGPTProtocol.ts
import Anthropic4 from "@anthropic-ai/sdk";
var DEFAULT_MODEL2 = "claude-3-7-sonnet-20250219";
var AutoGPTProtocol = class {
  config = {
    systemPrompt: "You are an autonomous agent that can break down tasks into steps, plan, and execute them sequentially.",
    tools: [],
    modelName: DEFAULT_MODEL2,
    temperature: 0.7,
    maxTokens: 2048,
    capabilities: [
      "multi_step" /* MULTI_STEP */,
      "tool_use" /* TOOL_USE */,
      "recursive_planning" /* RECURSIVE_PLANNING */,
      "self_correction" /* SELF_CORRECTION */
    ],
    maxSteps: 10,
    // Maximum number of steps before forcing completion
    thoughtDepth: 2
    // Depth of recursive reasoning
  };
  anthropicClient = null;
  availableTools = [];
  initialized = false;
  executionSteps = [];
  currentStepIndex = 0;
  /**
   * Get metadata about this protocol
   */
  getMetadata() {
    return {
      name: "AutoGPT",
      version: "1.0.0",
      description: "Protocol for recursive planning agents (multi-step)",
      capabilities: [
        "multi_step" /* MULTI_STEP */,
        "tool_use" /* TOOL_USE */,
        "recursive_planning" /* RECURSIVE_PLANNING */,
        "self_correction" /* SELF_CORRECTION */
      ],
      requiresAuthentication: true,
      supportedModels: [
        "claude-3-7-sonnet-20250219",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "gpt-4o",
        "gpt-4-turbo",
        "gpt-4"
      ]
    };
  }
  /**
   * Initialize the protocol with configuration
   */
  async init(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (this.config.modelName?.includes("claude")) {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY environment variable is required for Claude models");
      }
      this.anthropicClient = new Anthropic4({
        apiKey: process.env.ANTHROPIC_API_KEY
      });
    }
    this.availableTools = this.config.tools || [];
    this.executionSteps = [];
    this.currentStepIndex = 0;
    this.initialized = true;
  }
  /**
   * Execute a task using this protocol
   */
  async execute(options2) {
    if (!this.initialized) {
      throw new Error("Protocol not initialized. Call init() first.");
    }
    const startTime2 = Date.now();
    try {
      if (options2.callbacks?.onStart) {
        options2.callbacks.onStart();
      }
      await this.generatePlan(options2.task, options2);
      const executionResult = await this.executePlan(options2);
      const agentResponse = {
        response: executionResult.finalSummary,
        usedTools: executionResult.toolExecutions,
        thinking: executionResult.thinking,
        executionTime: Date.now() - startTime2
      };
      if (options2.callbacks?.onComplete) {
        options2.callbacks.onComplete(agentResponse);
      }
      return agentResponse;
    } catch (error) {
      log(`AutoGPT Protocol execution error: ${error}`, "agent");
      if (options2.callbacks?.onError) {
        options2.callbacks.onError(error);
      }
      throw error;
    }
  }
  /**
   * Generate a plan for executing the task
   */
  async generatePlan(task, options2) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const planningPrompt = `${this.config.systemPrompt}

You are a recursive planning agent that can break down complex tasks into simple, executable steps. Your job is to:

1. Analyze the given task 
2. Break it down into a sequence of 3-7 logical steps
3. Ensure each step is specific, actionable, and achievable
4. Consider dependencies between steps
5. Include any tool usage needed for each step

${this.getToolsInstructionsString()}

Respond with a JSON object in the following format:
{
  "reasoning": "Your step-by-step reasoning about how to approach this task",
  "plan": [
    {
      "name": "Step 1 name - should be short and descriptive",
      "description": "Detailed description of what this step will accomplish"
    },
    ...
  ]
}`;
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: planningPrompt,
      messages: [{ role: "user", content: `Task: ${task}` }]
    });
    const content2 = response.content[0].text;
    this.executionSteps = await this.parsePlanFromResponse(content2);
    this.currentStepIndex = 0;
  }
  /**
   * Parse the plan from the LLM response
   */
  async parsePlanFromResponse(content2) {
    try {
      const jsonMatch = content2.match(/```json\n([\s\S]*?)\n```/) || content2.match(/```([\s\S]*?)```/) || content2.match(/{[\s\S]*?}/);
      if (!jsonMatch) {
        throw new Error("Could not extract JSON plan from response");
      }
      let planJson;
      try {
        planJson = JSON.parse(jsonMatch[0].replace(/```json\n|```/g, ""));
      } catch (e) {
        planJson = JSON.parse(jsonMatch[1].trim());
      }
      if (!planJson || !Array.isArray(planJson.plan)) {
        throw new Error("Invalid plan format in response");
      }
      return planJson.plan.map((step, index2) => ({
        id: index2 + 1,
        name: step.name || `Step ${index2 + 1}`,
        description: step.description || "",
        completed: false
      }));
    } catch (error) {
      log(`Error parsing plan from response: ${error}`, "agent");
      return [{
        id: 1,
        name: "Execute task",
        description: "Execute the requested task directly",
        completed: false
      }];
    }
  }
  /**
   * Execute the generated plan
   */
  async executePlan(options2) {
    const tools2 = options2.tools || this.availableTools;
    const maxSteps = this.config.maxSteps;
    const toolExecutions = [];
    let thinking = "";
    while (this.currentStepIndex < this.executionSteps.length && this.currentStepIndex < maxSteps) {
      const currentStep = this.executionSteps[this.currentStepIndex];
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: currentStep.name,
          description: currentStep.description,
          status: "started"
        });
      }
      try {
        const stepResult = await this.executeStep(currentStep, options2.task, this.getExecutionContext(), tools2, options2);
        currentStep.completed = true;
        currentStep.output = stepResult.output;
        thinking += `Step ${currentStep.id}: ${currentStep.name}
`;
        thinking += `Reasoning: ${stepResult.reasoning}
`;
        thinking += `Output: ${JSON.stringify(stepResult.output)}

`;
        if (stepResult.toolExecution) {
          toolExecutions.push(stepResult.toolExecution);
        }
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: currentStep.name,
            description: currentStep.description,
            output: stepResult.output,
            status: "completed"
          });
        }
      } catch (error) {
        currentStep.completed = false;
        currentStep.error = error.message;
        thinking += `Step ${currentStep.id}: ${currentStep.name}
`;
        thinking += `Error: ${currentStep.error}

`;
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: currentStep.name,
            description: currentStep.description,
            error: currentStep.error,
            status: "failed"
          });
        }
        if (this.supportsCapability("self_correction" /* SELF_CORRECTION */)) {
          const correctionResult = await this.attemptStepCorrection(currentStep, options2.task, error, tools2, options2);
          if (correctionResult.success) {
            currentStep.completed = true;
            currentStep.output = correctionResult.output;
            currentStep.error = void 0;
            thinking += `Self-correction attempt:
`;
            thinking += `Reasoning: ${correctionResult.reasoning}
`;
            thinking += `Corrected output: ${JSON.stringify(correctionResult.output)}

`;
            if (correctionResult.toolExecution) {
              toolExecutions.push(correctionResult.toolExecution);
            }
            if (options2.callbacks?.onStep) {
              options2.callbacks.onStep({
                name: currentStep.name,
                description: currentStep.description,
                output: correctionResult.output,
                status: "completed"
              });
            }
          } else {
            thinking += `Self-correction failed: ${correctionResult.error}

`;
          }
        }
      }
      this.currentStepIndex++;
    }
    const finalSummary = await this.generateSummary(options2.task);
    return {
      finalSummary,
      toolExecutions,
      thinking
    };
  }
  /**
   * Execute a single step in the plan
   */
  async executeStep(step, task, context, tools2, options2) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const stepExecutionPrompt = `${this.config.systemPrompt}

You are currently executing a step in a multi-step plan to accomplish a task. Focus only on this step.

Current task: ${task}

Current step: ${step.name}
Step description: ${step.description}

Context from previous steps:
${JSON.stringify(context, null, 2)}

${this.getToolsInstructionsString()}

Think step by step about how to accomplish this specific step. Consider:
1. What information do you need?
2. What tools (if any) would help accomplish this step?
3. What is the expected output of this step?

Respond with a JSON object in the following format:
{
  "reasoning": "Your detailed reasoning about how to accomplish this step",
  "action": {
    "type": "tool_use" OR "direct_response",
    "tool": "tool_name" (if using a tool),
    "input": { ... tool parameters ... } (if using a tool),
    "response": "Your direct response" (if not using a tool)
  }
}`;
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: stepExecutionPrompt,
      messages: [{
        role: "user",
        content: `Execute step: ${step.name}`
      }]
    });
    const content2 = response.content[0].text;
    return await this.parseStepResponse(content2, tools2, options2);
  }
  /**
   * Parse the step execution response
   */
  async parseStepResponse(content2, tools2, options2) {
    try {
      const jsonMatch = content2.match(/```json\n([\s\S]*?)\n```/) || content2.match(/```([\s\S]*?)```/) || content2.match(/{[\s\S]*?}/);
      if (!jsonMatch) {
        throw new Error("Could not extract JSON from step execution response");
      }
      let responseJson;
      try {
        responseJson = JSON.parse(jsonMatch[0].replace(/```json\n|```/g, ""));
      } catch (e) {
        responseJson = JSON.parse(jsonMatch[1].trim());
      }
      const reasoning = responseJson.reasoning || "";
      if (responseJson.action.type === "tool_use" && responseJson.action.tool && responseJson.action.input) {
        const toolName = responseJson.action.tool;
        const toolInput = responseJson.action.input;
        const tool = tools2.find((t) => t.name === toolName);
        if (!tool) {
          throw new Error(`Tool '${toolName}' not found`);
        }
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName,
            input: toolInput,
            output: void 0,
            error: void 0
          });
        }
        const result2 = await tool.execute(toolInput);
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName,
            input: toolInput,
            output: result2,
            error: void 0
          });
        }
        return {
          reasoning,
          output: result2,
          toolExecution: {
            tool: toolName,
            input: toolInput,
            output: result2
          }
        };
      } else {
        return {
          reasoning,
          output: responseJson.action.response || ""
        };
      }
    } catch (error) {
      log(`Error parsing step response: ${error}`, "agent");
      throw error;
    }
  }
  /**
   * Attempt to correct a failed step
   */
  async attemptStepCorrection(step, task, error, tools2, options2) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const correctionPrompt = `${this.config.systemPrompt}

You are attempting to correct a failed step in a multi-step plan.

Current task: ${task}

Failed step: ${step.name}
Step description: ${step.description}
Error: ${error.message}

Context from execution:
${JSON.stringify(this.getExecutionContext(), null, 2)}

${this.getToolsInstructionsString()}

Analyze the error carefully and determine how to fix the issue. Think of alternative approaches or parameter adjustments that could resolve the problem.

Respond with a JSON object in the following format:
{
  "reasoning": "Your analysis of what went wrong and how to fix it",
  "action": {
    "type": "tool_use" OR "direct_response",
    "tool": "tool_name" (if using a tool),
    "input": { ... tool parameters ... } (if using a tool),
    "response": "Your direct response" (if not using a tool)
  }
}`;
    try {
      const response = await this.anthropicClient.messages.create({
        model: this.config.modelName,
        max_tokens: this.config.maxTokens,
        temperature: this.config.temperature,
        system: correctionPrompt,
        messages: [{
          role: "user",
          content: `Correct the failed step: ${step.name}. Error: ${error.message}`
        }]
      });
      const content2 = response.content[0].text;
      const result2 = await this.parseStepResponse(content2, tools2, options2);
      return {
        success: true,
        reasoning: result2.reasoning,
        output: result2.output,
        toolExecution: result2.toolExecution
      };
    } catch (error2) {
      log(`Error in step correction: ${error2}`, "agent");
      return {
        success: false,
        error: error2.message
      };
    }
  }
  /**
   * Generate a summary of the execution
   */
  async generateSummary(task) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const summaryPrompt = `${this.config.systemPrompt}

You are generating a summary of a multi-step task execution. The summary should:
1. Describe what was accomplished
2. Highlight key results and findings
3. Be concise but comprehensive
4. Use a professional tone`;
    const completedSteps = this.executionSteps.filter((step) => step.completed);
    const failedSteps = this.executionSteps.filter((step) => !step.completed);
    const executionSummaryContent = `
Task: ${task}

Execution Summary:
- Total steps planned: ${this.executionSteps.length}
- Steps completed: ${completedSteps.length}
- Steps failed: ${failedSteps.length}

Completed steps:
${completedSteps.map((step) => `- ${step.name}: ${JSON.stringify(step.output)}`).join("\n")}

${failedSteps.length > 0 ? `Failed steps:
${failedSteps.map((step) => `- ${step.name}: ${step.error}`).join("\n")}` : ""}

Please generate a comprehensive summary of what was accomplished.
`;
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: 0.5,
      // Lower temperature for more focused summary
      system: summaryPrompt,
      messages: [{ role: "user", content: executionSummaryContent }]
    });
    return response.content[0].text;
  }
  /**
   * Get the current execution context
   */
  getExecutionContext() {
    const completedSteps = this.executionSteps.filter((step) => step.completed && step.id < this.currentStepIndex + 1).map((step) => ({
      id: step.id,
      name: step.name,
      output: step.output
    }));
    return {
      completedSteps,
      currentStepIndex: this.currentStepIndex,
      totalSteps: this.executionSteps.length
    };
  }
  /**
   * Get tools instructions string
   */
  getToolsInstructionsString() {
    const tools2 = this.availableTools;
    if (tools2.length === 0) {
      return "";
    }
    let toolsString = "You have access to the following tools:\n";
    tools2.forEach((tool) => {
      toolsString += `- ${tool.name}: ${tool.description}
`;
      toolsString += "  Parameters:\n";
      Object.entries(tool.parameters).forEach(([paramName, paramInfo]) => {
        toolsString += `    - ${paramName} (${paramInfo.type}${paramInfo.required ? ", required" : ""}): ${paramInfo.description}
`;
      });
    });
    return toolsString;
  }
  /**
   * Get available tools
   */
  getAvailableTools() {
    return this.availableTools;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.tools) {
      this.availableTools = config.tools;
    }
  }
  /**
   * Get supported execution modes
   */
  getSupportedExecutionModes() {
    return ["synchronous" /* SYNCHRONOUS */, "asynchronous" /* ASYNCHRONOUS */];
  }
  /**
   * Check if protocol supports a specific capability
   */
  supportsCapability(capability) {
    return this.config.capabilities.includes(capability);
  }
  /**
   * Get current protocol configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    this.executionSteps = [];
    this.currentStepIndex = 0;
    this.initialized = false;
    return Promise.resolve();
  }
};

// server/services/agent/protocols/MetaGPTProtocol.ts
import Anthropic5 from "@anthropic-ai/sdk";
var DEFAULT_MODEL3 = "claude-3-7-sonnet-20250219";
var DEFAULT_ROLES = [
  {
    name: "ProjectManager",
    description: "Manages the overall project, delegates tasks, and ensures goals are met",
    responsibilities: [
      "Break down the main task into subtasks",
      "Assign subtasks to appropriate roles",
      "Monitor progress and provide guidance",
      "Ensure the final deliverable meets requirements",
      "Coordinate team communication"
    ],
    systemPrompt: "You are a Project Manager responsible for coordinating a team of specialized agents. Your job is to break down complex tasks, delegate effectively, and ensure the team delivers high-quality results on time."
  },
  {
    name: "Developer",
    description: "Implements technical solutions and writes code",
    responsibilities: [
      "Write code to solve technical problems",
      "Debug and fix issues",
      "Implement features according to specifications",
      "Optimize performance",
      "Ensure code quality and maintainability"
    ],
    systemPrompt: "You are a Developer responsible for implementing technical solutions. Your expertise is in writing clean, efficient code and solving technical challenges."
  },
  {
    name: "QA",
    description: "Tests implementations and ensures quality",
    responsibilities: [
      "Test implementations for bugs and issues",
      "Verify that requirements are met",
      "Identify edge cases and potential problems",
      "Provide feedback for improvements",
      "Ensure overall product quality"
    ],
    systemPrompt: "You are a Quality Assurance specialist responsible for testing implementations. Your expertise is in finding bugs, identifying edge cases, and ensuring product quality."
  },
  {
    name: "Researcher",
    description: "Gathers information and provides domain expertise",
    responsibilities: [
      "Research relevant topics and provide insights",
      "Gather data and information",
      "Analyze information and identify patterns",
      "Provide domain expertise",
      "Support decision-making with evidence"
    ],
    systemPrompt: "You are a Researcher responsible for gathering and analyzing information. Your expertise is in finding relevant data, providing insights, and supporting the team with domain knowledge."
  }
];
var MetaGPTProtocol = class {
  config = {
    systemPrompt: "You are participating in a multi-agent team with specialized roles to solve complex problems collaboratively.",
    tools: [],
    modelName: DEFAULT_MODEL3,
    temperature: 0.7,
    maxTokens: 2048,
    capabilities: [
      "multi_step" /* MULTI_STEP */,
      "tool_use" /* TOOL_USE */,
      "collaboration" /* COLLABORATION */,
      "role_playing" /* ROLE_PLAYING */
    ],
    roles: DEFAULT_ROLES,
    maxRounds: 10,
    // Maximum number of interaction rounds
    memoryEnabled: true
    // Whether agents have memory of past interactions
  };
  anthropicClient = null;
  availableTools = [];
  initialized = false;
  roles = [];
  messages = [];
  currentRound = 0;
  /**
   * Get metadata about this protocol
   */
  getMetadata() {
    return {
      name: "MetaGPT",
      version: "1.0.0",
      description: "Protocol for role-based agent teams (PM, Developer, QA agent team)",
      capabilities: [
        "multi_step" /* MULTI_STEP */,
        "tool_use" /* TOOL_USE */,
        "collaboration" /* COLLABORATION */,
        "role_playing" /* ROLE_PLAYING */
      ],
      requiresAuthentication: true,
      supportedModels: [
        "claude-3-7-sonnet-20250219",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "gpt-4o",
        "gpt-4-turbo",
        "gpt-4"
      ]
    };
  }
  /**
   * Initialize the protocol with configuration
   */
  async init(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (this.config.modelName?.includes("claude")) {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY environment variable is required for Claude models");
      }
      this.anthropicClient = new Anthropic5({
        apiKey: process.env.ANTHROPIC_API_KEY
      });
    }
    this.availableTools = this.config.tools || [];
    this.roles = this.config.roles || DEFAULT_ROLES;
    this.messages = [];
    this.currentRound = 0;
    this.initialized = true;
  }
  /**
   * Execute a task using this protocol
   */
  async execute(options2) {
    if (!this.initialized) {
      throw new Error("Protocol not initialized. Call init() first.");
    }
    const startTime2 = Date.now();
    try {
      if (options2.callbacks?.onStart) {
        options2.callbacks.onStart();
      }
      await this.startCollaboration(options2.task, options2);
      const finalOutput = await this.runCollaborationRounds(options2);
      const agentResponse = {
        response: finalOutput.summary,
        usedTools: finalOutput.toolExecutions,
        thinking: this.getCollaborationTranscript(),
        executionTime: Date.now() - startTime2
      };
      if (options2.callbacks?.onComplete) {
        options2.callbacks.onComplete(agentResponse);
      }
      return agentResponse;
    } catch (error) {
      log(`MetaGPT Protocol execution error: ${error}`, "agent");
      if (options2.callbacks?.onError) {
        options2.callbacks.onError(error);
      }
      throw error;
    }
  }
  /**
   * Start the collaboration with a task briefing from the Project Manager
   */
  async startCollaboration(task, options2) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const pmRole = this.roles.find((role) => role.name === "ProjectManager");
    if (!pmRole) {
      throw new Error("Project Manager role not found");
    }
    const pmInitialPrompt = `${pmRole.systemPrompt}

You are starting a new project with the following team members:
${this.roles.filter((role) => role.name !== "ProjectManager").map((role) => `- ${role.name}: ${role.description}`).join("\n")}

Your task is to:
1. Analyze the given task
2. Break it down into subtasks
3. Assign each subtask to the appropriate team member
4. Provide an initial plan and timeline
5. Set expectations for collaboration

Please provide a comprehensive briefing to the team that introduces the task, explains your plan, and gives clear instructions to each team member.

Task: ${task}`;
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: pmInitialPrompt,
      messages: [{ role: "user", content: `Create an initial project briefing for the task: ${task}` }]
    });
    this.addMessage("ProjectManager", "all", response.content[0].text);
    if (options2.callbacks?.onStep) {
      options2.callbacks.onStep({
        name: "Project Briefing",
        description: "Initial project briefing from the Project Manager",
        output: response.content[0].text,
        status: "completed"
      });
    }
  }
  /**
   * Run the collaboration rounds
   */
  async runCollaborationRounds(options2) {
    const tools2 = options2.tools || this.availableTools;
    const maxRounds = this.config.maxRounds;
    const toolExecutions = [];
    for (this.currentRound = 1; this.currentRound <= maxRounds; this.currentRound++) {
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Round ${this.currentRound}`,
          description: `Starting collaboration round ${this.currentRound}`,
          status: "started"
        });
      }
      for (const role of this.roles) {
        try {
          if (this.currentRound === 1 && role.name === "ProjectManager") {
            continue;
          }
          const roleResponse = await this.generateRoleResponse(role, tools2, options2);
          if (roleResponse.toolExecution) {
            toolExecutions.push(roleResponse.toolExecution);
          }
          this.addMessage(role.name, roleResponse.to, roleResponse.content);
          if (options2.callbacks?.onStep) {
            options2.callbacks.onStep({
              name: `${role.name} Response`,
              description: `Response from ${role.name} in round ${this.currentRound}`,
              output: roleResponse.content,
              status: "completed"
            });
          }
        } catch (error) {
          log(`Error generating response for ${role.name}: ${error}`, "agent");
          this.addMessage(role.name, "all", `I encountered an error: ${error.message}`);
          if (options2.callbacks?.onStep) {
            options2.callbacks.onStep({
              name: `${role.name} Response`,
              description: `Response from ${role.name} in round ${this.currentRound}`,
              error: error.message,
              status: "failed"
            });
          }
        }
      }
      if (await this.shouldEndCollaboration()) {
        break;
      }
    }
    const summary = await this.generateFinalSummary(options2.task);
    if (options2.callbacks?.onStep) {
      options2.callbacks.onStep({
        name: "Collaboration Complete",
        description: "The role-based agent collaboration has completed",
        output: summary,
        status: "completed"
      });
    }
    return {
      summary,
      toolExecutions
    };
  }
  /**
   * Generate a response from a specific role
   */
  async generateRoleResponse(role, tools2, options2) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const roleTools = this.getToolsForRole(role, tools2);
    const toolsInstructions = this.getToolsInstructionsString(roleTools);
    const relevantMessages = this.getRelevantMessages(role.name);
    const rolePrompt = `${role.systemPrompt}

You are participating in a collaborative team working on a task. Your role is: ${role.name}

Your responsibilities:
${role.responsibilities.map((r) => `- ${r}`).join("\n")}

Team members:
${this.roles.filter((r) => r.name !== role.name).map((r) => `- ${r.name}: ${r.description}`).join("\n")}

${toolsInstructions}

Previous messages in the conversation:
${this.formatMessagesForPrompt(relevantMessages)}

Based on the conversation so far, provide a response that:
1. Addresses the latest messages or tasks assigned to you
2. Contributes meaningfully to the collaborative process
3. Utilizes your specific expertise as a ${role.name}
4. Is directed to either a specific team member or the entire team

Respond with a JSON object in the following format:
{
  "reasoning": "Your internal reasoning about how to respond (this will not be shared with the team)",
  "to": "recipient_name or 'all' for everyone",
  "content": "Your actual message to the team",
  "action": {
    "type": "tool_use" OR "direct_response",
    "tool": "tool_name" (if using a tool),
    "input": { ... tool parameters ... } (if using a tool)
  }
}`;
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: rolePrompt,
      messages: [{
        role: "user",
        content: `Generate a response as ${role.name} for round ${this.currentRound} of the collaboration.`
      }]
    });
    return await this.parseRoleResponse(response.content[0].text, role.name, roleTools, options2);
  }
  /**
   * Parse a role's response
   */
  async parseRoleResponse(content2, roleName, tools2, options2) {
    try {
      const jsonMatch = content2.match(/```json\n([\s\S]*?)\n```/) || content2.match(/```([\s\S]*?)```/) || content2.match(/{[\s\S]*?}/);
      if (!jsonMatch) {
        throw new Error(`Could not extract JSON from ${roleName}'s response`);
      }
      let responseJson;
      try {
        responseJson = JSON.parse(jsonMatch[0].replace(/```json\n|```/g, ""));
      } catch (e) {
        responseJson = JSON.parse(jsonMatch[1].trim());
      }
      const to = responseJson.to || "all";
      let messageContent = responseJson.content || "";
      if (responseJson.action?.type === "tool_use" && responseJson.action.tool && responseJson.action.input) {
        const toolName = responseJson.action.tool;
        const toolInput = responseJson.action.input;
        const tool = tools2.find((t) => t.name === toolName);
        if (!tool) {
          throw new Error(`Tool '${toolName}' not found for ${roleName}`);
        }
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName,
            input: toolInput,
            output: void 0,
            error: void 0
          });
        }
        try {
          const result2 = await tool.execute(toolInput);
          if (options2.callbacks?.onToolUse) {
            options2.callbacks.onToolUse({
              toolName,
              input: toolInput,
              output: result2,
              error: void 0
            });
          }
          messageContent += `

**Tool Result (${toolName}):**
\`\`\`
${JSON.stringify(result2, null, 2)}
\`\`\``;
          return {
            to,
            content: messageContent,
            toolExecution: {
              tool: toolName,
              input: toolInput,
              output: result2
            }
          };
        } catch (error) {
          log(`Error executing ${toolName} for ${roleName}: ${error}`, "agent");
          if (options2.callbacks?.onToolUse) {
            options2.callbacks.onToolUse({
              toolName,
              input: toolInput,
              output: void 0,
              error: error.message
            });
          }
          messageContent += `

**Tool Error (${toolName}):**
\`\`\`
${error.message}
\`\`\``;
          return {
            to,
            content: messageContent,
            toolExecution: {
              tool: toolName,
              input: toolInput,
              output: `Error: ${error.message}`
            }
          };
        }
      }
      return {
        to,
        content: messageContent
      };
    } catch (error) {
      log(`Error parsing ${roleName}'s response: ${error}`, "agent");
      return {
        to: "all",
        content: `I attempted to respond but encountered an error: ${error.message}`
      };
    }
  }
  /**
   * Determine if the collaboration should end
   */
  async shouldEndCollaboration() {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    if (this.currentRound >= this.config.maxRounds) {
      return true;
    }
    const recentPMMessages = this.messages.filter((msg) => msg.from === "ProjectManager").slice(-2);
    for (const msg of recentPMMessages) {
      const completionIndicators = [
        "task is complete",
        "we have finished",
        "final deliverable",
        "final result",
        "successfully completed",
        "project is complete"
      ];
      if (completionIndicators.some((indicator) => msg.content.toLowerCase().includes(indicator))) {
        return true;
      }
    }
    return false;
  }
  /**
   * Generate a final summary from the Project Manager
   */
  async generateFinalSummary(task) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const pmRole = this.roles.find((role) => role.name === "ProjectManager");
    if (!pmRole) {
      throw new Error("Project Manager role not found");
    }
    const summaryPrompt = `${pmRole.systemPrompt}

As the Project Manager, you are responsible for providing a final summary of the collaborative work done by your team.

Task: ${task}

Team collaboration transcript:
${this.getCollaborationTranscript()}

Please provide a comprehensive final summary that:
1. Recaps the original task and goals
2. Summarizes the approach and methodology used
3. Highlights key contributions from each team member
4. Presents the final deliverable or outcome
5. Notes any challenges faced and how they were addressed
6. Provides any relevant recommendations or next steps

Your summary should be professional, concise, and highlight the successful completion of the task.`;
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: 0.5,
      // Lower temperature for more focused summary
      system: summaryPrompt,
      messages: [{ role: "user", content: "Generate the final project summary." }]
    });
    return response.content[0].text;
  }
  /**
   * Add a message to the conversation
   */
  addMessage(from, to, content2) {
    this.messages.push({
      id: `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
      from,
      to,
      content: content2,
      timestamp: /* @__PURE__ */ new Date()
    });
  }
  /**
   * Get relevant messages for a specific role
   */
  getRelevantMessages(roleName) {
    return this.messages.filter(
      (msg) => msg.to === roleName || msg.to === "all" || msg.from === roleName
    );
  }
  /**
   * Format messages for inclusion in a prompt
   */
  formatMessagesForPrompt(messages) {
    return messages.map((msg) => {
      const time = msg.timestamp.toLocaleTimeString();
      return `[${time}] ${msg.from} to ${msg.to === "all" ? "Everyone" : msg.to}: ${msg.content}`;
    }).join("\n\n---\n\n");
  }
  /**
   * Get tools available for a specific role
   */
  getToolsForRole(role, allTools) {
    if (!role.tools || role.tools.length === 0) {
      return allTools;
    }
    return allTools.filter((tool) => role.tools.includes(tool.name));
  }
  /**
   * Get tools instructions string
   */
  getToolsInstructionsString(tools2) {
    if (tools2.length === 0) {
      return "";
    }
    let toolsString = "You have access to the following tools:\n";
    tools2.forEach((tool) => {
      toolsString += `- ${tool.name}: ${tool.description}
`;
      toolsString += "  Parameters:\n";
      Object.entries(tool.parameters).forEach(([paramName, paramInfo]) => {
        toolsString += `    - ${paramName} (${paramInfo.type}${paramInfo.required ? ", required" : ""}): ${paramInfo.description}
`;
      });
    });
    return toolsString;
  }
  /**
   * Get the collaboration transcript
   */
  getCollaborationTranscript() {
    return this.formatMessagesForPrompt(this.messages);
  }
  /**
   * Get available tools
   */
  getAvailableTools() {
    return this.availableTools;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.tools) {
      this.availableTools = config.tools;
    }
    if (config.roles) {
      this.roles = config.roles;
    }
  }
  /**
   * Get supported execution modes
   */
  getSupportedExecutionModes() {
    return ["synchronous" /* SYNCHRONOUS */, "asynchronous" /* ASYNCHRONOUS */];
  }
  /**
   * Check if protocol supports a specific capability
   */
  supportsCapability(capability) {
    return this.config.capabilities.includes(capability);
  }
  /**
   * Get current protocol configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    this.messages = [];
    this.currentRound = 0;
    this.initialized = false;
    return Promise.resolve();
  }
};

// server/services/agent/protocols/CrewAIProtocol.ts
import Anthropic6 from "@anthropic-ai/sdk";
var DEFAULT_MODEL4 = "claude-3-7-sonnet-20250219";
var CrewAIProtocol = class {
  config = {
    systemPrompt: "You are part of a collaborative crew of AI agents working together to solve complex problems.",
    tools: [],
    modelName: DEFAULT_MODEL4,
    temperature: 0.7,
    maxTokens: 2048,
    capabilities: [
      "multi_step" /* MULTI_STEP */,
      "tool_use" /* TOOL_USE */,
      "collaboration" /* COLLABORATION */,
      "role_playing" /* ROLE_PLAYING */
    ],
    processType: "hierarchical" /* HIERARCHICAL */,
    maxIterations: 10,
    // Maximum number of process iterations
    agents: [],
    // Will be populated in init()
    taskTimeout: 3e5
    // 5 minutes per task
  };
  anthropicClient = null;
  availableTools = [];
  initialized = false;
  agents = [];
  tasks = [];
  processLog = [];
  /**
   * Get metadata about this protocol
   */
  getMetadata() {
    return {
      name: "CrewAI",
      version: "1.0.0",
      description: "Protocol for multi-role, goal-driven agent flows",
      capabilities: [
        "multi_step" /* MULTI_STEP */,
        "tool_use" /* TOOL_USE */,
        "collaboration" /* COLLABORATION */,
        "role_playing" /* ROLE_PLAYING */
      ],
      requiresAuthentication: true,
      supportedModels: [
        "claude-3-7-sonnet-20250219",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "gpt-4o",
        "gpt-4-turbo",
        "gpt-4"
      ]
    };
  }
  /**
   * Initialize the protocol with configuration
   */
  async init(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (this.config.modelName?.includes("claude")) {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY environment variable is required for Claude models");
      }
      this.anthropicClient = new Anthropic6({
        apiKey: process.env.ANTHROPIC_API_KEY
      });
    }
    this.availableTools = this.config.tools || [];
    if (this.config.agents && Array.isArray(this.config.agents) && this.config.agents.length > 0) {
      this.agents = this.config.agents;
    } else {
      this.agents = this.createDefaultAgents();
    }
    this.tasks = [];
    this.processLog = [];
    this.initialized = true;
  }
  /**
   * Execute a task using this protocol
   */
  async execute(options2) {
    if (!this.initialized) {
      throw new Error("Protocol not initialized. Call init() first.");
    }
    const startTime2 = Date.now();
    try {
      if (options2.callbacks?.onStart) {
        options2.callbacks.onStart();
      }
      let result2;
      switch (this.config.processType) {
        case "sequential" /* SEQUENTIAL */:
          result2 = await this.runSequentialProcess(options2);
          break;
        case "hierarchical" /* HIERARCHICAL */:
          result2 = await this.runHierarchicalProcess(options2);
          break;
        case "consensus" /* CONSENSUS */:
          result2 = await this.runConsensusProcess(options2);
          break;
        default:
          result2 = await this.runHierarchicalProcess(options2);
      }
      const agentResponse = {
        response: result2.finalOutput,
        usedTools: result2.toolExecutions,
        thinking: this.getProcessTranscript(),
        executionTime: Date.now() - startTime2
      };
      if (options2.callbacks?.onComplete) {
        options2.callbacks.onComplete(agentResponse);
      }
      return agentResponse;
    } catch (error) {
      log(`CrewAI Protocol execution error: ${error}`, "agent");
      if (options2.callbacks?.onError) {
        options2.callbacks.onError(error);
      }
      throw error;
    }
  }
  /**
   * Run a sequential process where tasks are executed in order
   */
  async runSequentialProcess(options2) {
    await this.generateInitialTasks(options2.task);
    this.addToLog("Crew", "planning", {
      message: "Generated initial task plan",
      tasks: this.tasks.map((t) => ({
        id: t.id,
        name: t.name,
        assignedTo: t.assignedTo
      }))
    });
    if (options2.callbacks?.onStep) {
      options2.callbacks.onStep({
        name: "Task Planning",
        description: "Generated initial tasks for sequential execution",
        output: this.tasks.map((t) => t.name).join(", "),
        status: "completed"
      });
    }
    const tools2 = options2.tools || this.availableTools;
    const toolExecutions = [];
    for (const task of this.tasks) {
      task.status = "in_progress";
      this.addToLog(task.assignedTo || "Crew", "task_start", {
        taskId: task.id,
        taskName: task.name
      });
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Task: ${task.name}`,
          description: task.description,
          status: "started"
        });
      }
      try {
        const agent2 = this.agents.find((a) => a.id === task.assignedTo);
        if (!agent2) {
          throw new Error(`Agent with ID ${task.assignedTo} not found for task ${task.id}`);
        }
        const result2 = await this.executeTask(task, agent2, tools2, options2);
        task.status = "completed";
        task.result = result2.output;
        if (result2.toolExecution) {
          toolExecutions.push(result2.toolExecution);
        }
        this.addToLog(agent2.name, "task_complete", {
          taskId: task.id,
          taskName: task.name,
          output: result2.output
        });
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: `Task: ${task.name}`,
            description: task.description,
            output: result2.output,
            status: "completed"
          });
        }
      } catch (error) {
        task.status = "failed";
        task.error = error.message;
        this.addToLog(task.assignedTo || "Crew", "task_failed", {
          taskId: task.id,
          taskName: task.name,
          error: error.message
        });
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: `Task: ${task.name}`,
            description: task.description,
            error: error.message,
            status: "failed"
          });
        }
      }
    }
    const finalOutput = await this.generateFinalOutput(options2.task);
    return {
      finalOutput,
      toolExecutions
    };
  }
  /**
   * Run a hierarchical process where a manager delegates to workers
   */
  async runHierarchicalProcess(options2) {
    const manager = this.agents.find((a) => a.allowDelegation);
    if (!manager) {
      throw new Error("No manager agent found for hierarchical process");
    }
    if (options2.callbacks?.onStep) {
      options2.callbacks.onStep({
        name: "Process Initialization",
        description: `Starting hierarchical process with ${manager.name} as manager`,
        status: "started"
      });
    }
    const plan = await this.generateManagerPlan(manager, options2.task);
    this.addToLog(manager.name, "planning", {
      message: "Generated hierarchical execution plan",
      plan
    });
    if (options2.callbacks?.onStep) {
      options2.callbacks.onStep({
        name: "Task Planning",
        description: `${manager.name} generated execution plan`,
        output: this.tasks.map((t) => t.name).join(", "),
        status: "completed"
      });
    }
    const tools2 = options2.tools || this.availableTools;
    const toolExecutions = [];
    for (const task of this.tasks) {
      if (task.dependsOn && task.dependsOn.length > 0) {
        const dependencies = this.tasks.filter((t) => task.dependsOn.includes(t.id));
        if (dependencies.some((d) => d.status !== "completed")) {
          continue;
        }
      }
      task.status = "in_progress";
      this.addToLog(task.assignedTo || "Crew", "task_start", {
        taskId: task.id,
        taskName: task.name
      });
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Task: ${task.name}`,
          description: task.description,
          status: "started"
        });
      }
      try {
        const agent2 = this.agents.find((a) => a.id === task.assignedTo);
        if (!agent2) {
          throw new Error(`Agent with ID ${task.assignedTo} not found for task ${task.id}`);
        }
        const result2 = await this.executeTask(task, agent2, tools2, options2);
        task.status = "completed";
        task.result = result2.output;
        if (result2.toolExecution) {
          toolExecutions.push(result2.toolExecution);
        }
        this.addToLog(agent2.name, "task_complete", {
          taskId: task.id,
          taskName: task.name,
          output: result2.output
        });
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: `Task: ${task.name}`,
            description: task.description,
            output: result2.output,
            status: "completed"
          });
        }
      } catch (error) {
        task.status = "failed";
        task.error = error.message;
        this.addToLog(task.assignedTo || "Crew", "task_failed", {
          taskId: task.id,
          taskName: task.name,
          error: error.message
        });
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: `Task: ${task.name}`,
            description: task.description,
            error: error.message,
            status: "failed"
          });
        }
      }
    }
    const managerReview = await this.generateManagerReview(manager, options2.task);
    this.addToLog(manager.name, "review", {
      message: "Generated final review and integration",
      review: managerReview
    });
    if (options2.callbacks?.onStep) {
      options2.callbacks.onStep({
        name: "Final Review",
        description: `${manager.name} reviewed and integrated results`,
        output: managerReview,
        status: "completed"
      });
    }
    return {
      finalOutput: managerReview,
      toolExecutions
    };
  }
  /**
   * Run a consensus process where agents must reach agreement
   */
  async runConsensusProcess(options2) {
    if (options2.callbacks?.onStep) {
      options2.callbacks.onStep({
        name: "Process Initialization",
        description: "Starting consensus process with all agents",
        status: "started"
      });
    }
    const tools2 = options2.tools || this.availableTools;
    const toolExecutions = [];
    const proposals = [];
    for (const agent2 of this.agents) {
      try {
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: `Initial Proposal: ${agent2.name}`,
            description: `${agent2.name} generating initial proposal`,
            status: "started"
          });
        }
        const proposal = await this.generateAgentProposal(agent2, options2.task, tools2, options2);
        proposals.push({
          agent: agent2.name,
          proposal: proposal.output
        });
        if (proposal.toolExecution) {
          toolExecutions.push(proposal.toolExecution);
        }
        this.addToLog(agent2.name, "proposal", {
          agentName: agent2.name,
          proposal: proposal.output
        });
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: `Initial Proposal: ${agent2.name}`,
            description: `${agent2.name} generated initial proposal`,
            output: proposal.output,
            status: "completed"
          });
        }
      } catch (error) {
        this.addToLog(agent2.name, "proposal_failed", {
          agentName: agent2.name,
          error: error.message
        });
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: `Initial Proposal: ${agent2.name}`,
            description: `${agent2.name} generating initial proposal`,
            error: error.message,
            status: "failed"
          });
        }
      }
    }
    const consensusResult = await this.generateConsensus(proposals, options2.task);
    this.addToLog("Crew", "consensus", {
      message: "Generated consensus result",
      result: consensusResult
    });
    if (options2.callbacks?.onStep) {
      options2.callbacks.onStep({
        name: "Consensus Generation",
        description: "Generated final consensus result",
        output: consensusResult,
        status: "completed"
      });
    }
    return {
      finalOutput: consensusResult,
      toolExecutions
    };
  }
  /**
   * Generate initial tasks for the sequential process
   */
  async generateInitialTasks(task) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const taskPrompt = `${this.config.systemPrompt}

You are tasked with breaking down a complex problem into a sequence of well-defined tasks that can be assigned to specialized agents in the crew.

The crew consists of the following agents:
${this.agents.map((agent2) => `- ${agent2.name} (${agent2.role}): ${agent2.goal}`).join("\n")}

For the given task, create a sequential plan with 3-7 subtasks. Each task should:
1. Have a clear objective
2. Be assigned to the most appropriate agent
3. Have well-defined expected outputs
4. Be organized in a logical sequence

Respond with a JSON array of tasks in the following format:
[
  {
    "id": "task_1",
    "name": "Short task name",
    "description": "Detailed task description",
    "expectedOutput": "What this task should produce",
    "assignedTo": "agent_id"
  },
  ...
]`;
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: taskPrompt,
      messages: [{ role: "user", content: `Generate tasks for: ${task}` }]
    });
    const content2 = response.content[0].text;
    this.tasks = await this.parseTasksFromResponse(content2);
  }
  /**
   * Parse tasks from the LLM response
   */
  async parseTasksFromResponse(content2) {
    try {
      const jsonMatch = content2.match(/```json\n([\s\S]*?)\n```/) || content2.match(/```([\s\S]*?)```/) || content2.match(/\[([\s\S]*?)\]/);
      if (!jsonMatch) {
        throw new Error("Could not extract JSON tasks from response");
      }
      let tasksJson;
      try {
        tasksJson = JSON.parse(jsonMatch[0].replace(/```json\n|```/g, ""));
      } catch (e) {
        tasksJson = JSON.parse(jsonMatch[1].trim());
      }
      if (!Array.isArray(tasksJson)) {
        throw new Error("Invalid tasks format in response");
      }
      return tasksJson.map((task) => ({
        id: task.id || `task_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
        name: task.name || "Unnamed Task",
        description: task.description || "",
        expectedOutput: task.expectedOutput || "",
        assignedTo: task.assignedTo || this.agents[0]?.id,
        status: "pending"
      }));
    } catch (error) {
      log(`Error parsing tasks from response: ${error}`, "agent");
      return [{
        id: `task_${Date.now()}`,
        name: "Execute Main Task",
        description: "Execute the requested task directly",
        expectedOutput: "Completed task result",
        assignedTo: this.agents[0]?.id,
        status: "pending"
      }];
    }
  }
  /**
   * Execute a task with a specific agent
   */
  async executeTask(task, agent2, tools2, options2) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const agentTools = this.getToolsForAgent(agent2, tools2);
    const context = this.getContextForTask(task);
    const agentPrompt = `${this.config.systemPrompt}

${agent2.systemPrompt}

You are ${agent2.name}, a ${agent2.role} with the following goal: ${agent2.goal}

Backstory: ${agent2.backstory}

You are executing a specific task as part of a crew of AI agents:
Task: ${task.name}
Description: ${task.description}
Expected Output: ${task.expectedOutput}

${this.getToolsInstructionsString(agentTools)}

Context from previous tasks:
${JSON.stringify(context, null, 2)}

Think step by step about how to accomplish this task given your role and expertise. Your response should include:
1. Your analysis of the task
2. Your approach to solving it
3. The actual work/solution
4. A clear final output that matches the expected format

Respond with a JSON object in the following format:
{
  "reasoning": "Your internal reasoning about how to approach this task",
  "output": "Your actual task output that will be used by the crew",
  "action": {
    "type": "tool_use" OR "direct_response",
    "tool": "tool_name" (if using a tool),
    "input": { ... tool parameters ... } (if using a tool)
  }
}`;
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: agentPrompt,
      messages: [{
        role: "user",
        content: `Execute task: ${task.name}`
      }]
    });
    return await this.parseTaskResponse(response.content[0].text, agentTools, options2);
  }
  /**
   * Parse a task execution response
   */
  async parseTaskResponse(content2, tools2, options2) {
    try {
      const jsonMatch = content2.match(/```json\n([\s\S]*?)\n```/) || content2.match(/```([\s\S]*?)```/) || content2.match(/{[\s\S]*?}/);
      if (!jsonMatch) {
        throw new Error("Could not extract JSON from task response");
      }
      let responseJson;
      try {
        responseJson = JSON.parse(jsonMatch[0].replace(/```json\n|```/g, ""));
      } catch (e) {
        responseJson = JSON.parse(jsonMatch[1].trim());
      }
      if (responseJson.action?.type === "tool_use" && responseJson.action.tool && responseJson.action.input) {
        const toolName = responseJson.action.tool;
        const toolInput = responseJson.action.input;
        const tool = tools2.find((t) => t.name === toolName);
        if (!tool) {
          throw new Error(`Tool '${toolName}' not found`);
        }
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName,
            input: toolInput,
            output: void 0,
            error: void 0
          });
        }
        try {
          const result2 = await tool.execute(toolInput);
          if (options2.callbacks?.onToolUse) {
            options2.callbacks.onToolUse({
              toolName,
              input: toolInput,
              output: result2,
              error: void 0
            });
          }
          return {
            output: responseJson.output || result2,
            toolExecution: {
              tool: toolName,
              input: toolInput,
              output: result2
            }
          };
        } catch (error) {
          log(`Error executing ${toolName}: ${error}`, "agent");
          if (options2.callbacks?.onToolUse) {
            options2.callbacks.onToolUse({
              toolName,
              input: toolInput,
              output: void 0,
              error: error.message
            });
          }
          return {
            output: responseJson.output || `Error executing tool: ${error.message}`,
            toolExecution: {
              tool: toolName,
              input: toolInput,
              output: `Error: ${error.message}`
            }
          };
        }
      }
      return {
        output: responseJson.output || content2
      };
    } catch (error) {
      log(`Error parsing task response: ${error}`, "agent");
      return {
        output: `Failed to parse response: ${error.message}. Raw response: ${content2}`
      };
    }
  }
  /**
   * Generate a hierarchical execution plan from the manager
   */
  async generateManagerPlan(manager, task) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const planPrompt = `${this.config.systemPrompt}

${manager.systemPrompt}

You are ${manager.name}, the manager of this crew, with the following goal: ${manager.goal}

Backstory: ${manager.backstory}

You are responsible for creating a hierarchical execution plan for the following task: ${task}

The crew consists of the following agents that you can delegate tasks to:
${this.agents.filter((a) => a.id !== manager.id).map((agent2) => `- ${agent2.name} (${agent2.role}): ${agent2.goal}`).join("\n")}

Create a plan with 3-7 subtasks where:
1. Each task has a clear objective
2. Tasks are assigned to the most appropriate agent
3. Dependencies between tasks are identified (if any)
4. The expected output of each task is defined

Present your plan as a JSON array in the following format:
[
  {
    "id": "task_1",
    "name": "Short task name",
    "description": "Detailed task description",
    "expectedOutput": "What this task should produce",
    "assignedTo": "agent_id",
    "dependsOn": [] // Array of task IDs this task depends on
  },
  ...
]

Explain your reasoning before providing the plan.`;
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: planPrompt,
      messages: [{ role: "user", content: `Create an execution plan for: ${task}` }]
    });
    const content2 = response.content[0].text;
    try {
      const jsonMatch = content2.match(/```json\n([\s\S]*?)\n```/) || content2.match(/```([\s\S]*?)```/) || content2.match(/\[([\s\S]*?)\]/);
      if (jsonMatch) {
        let tasksJson;
        try {
          tasksJson = JSON.parse(jsonMatch[0].replace(/```json\n|```/g, ""));
        } catch (e) {
          try {
            tasksJson = JSON.parse(`[${jsonMatch[1].trim()}]`);
          } catch (e2) {
            throw new Error("Invalid JSON format in manager plan");
          }
        }
        if (Array.isArray(tasksJson)) {
          this.tasks = tasksJson.map((task2) => ({
            id: task2.id || `task_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
            name: task2.name || "Unnamed Task",
            description: task2.description || "",
            expectedOutput: task2.expectedOutput || "",
            assignedTo: task2.assignedTo,
            dependsOn: task2.dependsOn || [],
            status: "pending"
          }));
        }
      }
    } catch (error) {
      log(`Error parsing manager plan: ${error}`, "agent");
      this.tasks = [{
        id: `task_${Date.now()}`,
        name: "Execute Main Task",
        description: "Execute the requested task directly",
        expectedOutput: "Completed task result",
        assignedTo: this.agents.find((a) => a.id !== manager.id)?.id || manager.id,
        status: "pending"
      }];
    }
    return content2;
  }
  /**
   * Generate a review and integration of results from the manager
   */
  async generateManagerReview(manager, task) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const completedTasks = this.tasks.filter((t) => t.status === "completed");
    const failedTasks = this.tasks.filter((t) => t.status === "failed");
    const reviewPrompt = `${this.config.systemPrompt}

${manager.systemPrompt}

You are ${manager.name}, the manager of this crew, with the following goal: ${manager.goal}

Backstory: ${manager.backstory}

You are reviewing and integrating the results of a hierarchical execution plan for the task: ${task}

The execution produced the following results:

Completed tasks (${completedTasks.length}/${this.tasks.length}):
${completedTasks.map((t) => {
      const agent2 = this.agents.find((a) => a.id === t.assignedTo);
      return `- ${t.name} (${agent2?.name || "Unknown"}): ${JSON.stringify(t.result)}`;
    }).join("\n")}

${failedTasks.length > 0 ? `Failed tasks (${failedTasks.length}/${this.tasks.length}):
${failedTasks.map((t) => {
      const agent2 = this.agents.find((a) => a.id === t.assignedTo);
      return `- ${t.name} (${agent2?.name || "Unknown"}): ${t.error}`;
    }).join("\n")}` : ""}

Your job is to:
1. Review each task result
2. Integrate the results into a cohesive final output
3. Address any gaps or issues from failed tasks (if any)
4. Provide a comprehensive summary of the work completed
5. Deliver the final output that accomplishes the original task

Provide your integrated review and final output in a clear, well-structured format.`;
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: 0.5,
      // Lower temperature for more focused review
      system: reviewPrompt,
      messages: [{ role: "user", content: `Review and integrate the results for: ${task}` }]
    });
    return response.content[0].text;
  }
  /**
   * Generate a proposal from an agent for the consensus process
   */
  async generateAgentProposal(agent2, task, tools2, options2) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const agentTools = this.getToolsForAgent(agent2, tools2);
    const proposalPrompt = `${this.config.systemPrompt}

${agent2.systemPrompt}

You are ${agent2.name}, a ${agent2.role} with the following goal: ${agent2.goal}

Backstory: ${agent2.backstory}

You are part of a consensus-based crew of AI agents working together to solve the following task: ${task}

${this.getToolsInstructionsString(agentTools)}

Your job is to create a comprehensive proposal for solving this task based on your expertise and role. Your proposal should:
1. Analyze the task from your perspective
2. Propose a solution or approach
3. Highlight the strengths of your proposal
4. Acknowledge any limitations or assumptions

Respond with a JSON object in the following format:
{
  "reasoning": "Your internal reasoning about how to approach this task",
  "proposal": "Your detailed proposal for solving the task",
  "action": {
    "type": "tool_use" OR "direct_response",
    "tool": "tool_name" (if using a tool),
    "input": { ... tool parameters ... } (if using a tool)
  }
}`;
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: proposalPrompt,
      messages: [{
        role: "user",
        content: `Generate a proposal for: ${task}`
      }]
    });
    try {
      const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/) || content.match(/```([\s\S]*?)```/) || content.match(/{[\s\S]*?}/);
      if (!jsonMatch) {
        return {
          output: response.content[0].text
        };
      }
      let responseJson;
      try {
        responseJson = JSON.parse(jsonMatch[0].replace(/```json\n|```/g, ""));
      } catch (e) {
        responseJson = JSON.parse(jsonMatch[1].trim());
      }
      if (responseJson.action?.type === "tool_use" && responseJson.action.tool && responseJson.action.input) {
        const toolName = responseJson.action.tool;
        const toolInput = responseJson.action.input;
        const tool = agentTools.find((t) => t.name === toolName);
        if (!tool) {
          return {
            output: responseJson.proposal || response.content[0].text
          };
        }
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName,
            input: toolInput,
            output: void 0,
            error: void 0
          });
        }
        try {
          const result2 = await tool.execute(toolInput);
          if (options2.callbacks?.onToolUse) {
            options2.callbacks.onToolUse({
              toolName,
              input: toolInput,
              output: result2,
              error: void 0
            });
          }
          return {
            output: responseJson.proposal || response.content[0].text,
            toolExecution: {
              tool: toolName,
              input: toolInput,
              output: result2
            }
          };
        } catch (error) {
          log(`Error executing ${toolName}: ${error}`, "agent");
          return {
            output: responseJson.proposal || response.content[0].text,
            toolExecution: {
              tool: toolName,
              input: toolInput,
              output: `Error: ${error.message}`
            }
          };
        }
      }
      return {
        output: responseJson.proposal || response.content[0].text
      };
    } catch (error) {
      return {
        output: response.content[0].text
      };
    }
  }
  /**
   * Generate a consensus result from all proposals
   */
  async generateConsensus(proposals, task) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const consensusPrompt = `${this.config.systemPrompt}

You are synthesizing multiple proposals from a crew of AI agents to generate a consensus solution for the following task: ${task}

Each agent has provided their proposal based on their role and expertise. Your job is to:
1. Identify the strengths and unique contributions of each proposal
2. Find common elements and points of agreement
3. Resolve any contradictions or conflicts
4. Create a unified solution that incorporates the best ideas
5. Ensure the final consensus addresses the original task comprehensively

The proposals are:

${proposals.map((p) => `## ${p.agent}'s Proposal
${p.proposal}
`).join("\n\n")}

Generate a consensus solution that represents the best integration of these proposals, addressing any gaps or conflicts, and providing a comprehensive final answer to the task.`;
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: 0.5,
      // Lower temperature for more focused consensus
      system: consensusPrompt,
      messages: [{ role: "user", content: `Generate consensus for: ${task}` }]
    });
    return response.content[0].text;
  }
  /**
   * Generate a final output based on task results
   */
  async generateFinalOutput(task) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const completedTasks = this.tasks.filter((t) => t.status === "completed");
    const failedTasks = this.tasks.filter((t) => t.status === "failed");
    const finalOutputPrompt = `${this.config.systemPrompt}

You are generating a final output for a sequential execution of tasks that were performed to complete the following main task: ${task}

The execution produced the following results:

Completed tasks (${completedTasks.length}/${this.tasks.length}):
${completedTasks.map((t) => {
      const agent2 = this.agents.find((a) => a.id === t.assignedTo);
      return `- ${t.name} (${agent2?.name || "Unknown"}): ${JSON.stringify(t.result)}`;
    }).join("\n")}

${failedTasks.length > 0 ? `Failed tasks (${failedTasks.length}/${this.tasks.length}):
${failedTasks.map((t) => {
      const agent2 = this.agents.find((a) => a.id === t.assignedTo);
      return `- ${t.name} (${agent2?.name || "Unknown"}): ${t.error}`;
    }).join("\n")}` : ""}

Your job is to:
1. Integrate the results from all completed tasks
2. Address any gaps from failed tasks (if any)
3. Create a coherent, comprehensive final output
4. Ensure the output directly addresses the original task
5. Format the output in a clear, well-structured manner

Generate the final output that accomplishes the original task.`;
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: 0.5,
      // Lower temperature for more focused output
      system: finalOutputPrompt,
      messages: [{ role: "user", content: `Generate final output for: ${task}` }]
    });
    return response.content[0].text;
  }
  /**
   * Create default agents if none are provided
   */
  createDefaultAgents() {
    return [
      {
        id: "manager",
        name: "Project Manager",
        role: "Manager",
        goal: "Coordinate the team and ensure task completion",
        backstory: "An experienced project manager with a track record of successful multi-agent coordination and efficient task delegation.",
        systemPrompt: "You are a Project Manager responsible for coordinating a team of specialized agents. Your job is to break down complex tasks, delegate effectively, and ensure the team delivers high-quality results on time.",
        allowDelegation: true
      },
      {
        id: "researcher",
        name: "Research Specialist",
        role: "Researcher",
        goal: "Gather information and provide insights",
        backstory: "A meticulous researcher with expertise in finding relevant information, analyzing data, and providing evidence-based insights.",
        systemPrompt: "You are a Research Specialist responsible for information gathering and analysis. Your expertise is in finding relevant data, providing insights, and supporting the team with evidence-based information."
      },
      {
        id: "implementer",
        name: "Implementation Expert",
        role: "Implementer",
        goal: "Execute tasks and implement solutions",
        backstory: "A skilled implementer with extensive experience in executing plans, creating solutions, and handling operational details efficiently.",
        systemPrompt: "You are an Implementation Expert responsible for executing plans and creating solutions. Your expertise is in turning ideas into reality, handling details, and ensuring practical feasibility."
      },
      {
        id: "critic",
        name: "Quality Assurance Specialist",
        role: "Critic",
        goal: "Evaluate solutions and identify improvements",
        backstory: "A detail-oriented critic with a keen eye for identifying potential issues, evaluating quality, and suggesting improvements.",
        systemPrompt: "You are a Quality Assurance Specialist responsible for evaluating solutions and identifying improvements. Your expertise is in critical thinking, quality control, and constructive feedback."
      }
    ];
  }
  /**
   * Get context for a task from previous task results
   */
  getContextForTask(task) {
    if (task.dependsOn && task.dependsOn.length > 0) {
      const dependencies = this.tasks.filter(
        (t) => task.dependsOn.includes(t.id) && t.status === "completed"
      );
      return {
        dependencyResults: dependencies.map((d) => ({
          taskId: d.id,
          taskName: d.name,
          result: d.result
        }))
      };
    }
    const currentTaskIndex = this.tasks.findIndex((t) => t.id === task.id);
    const previousTasks = this.tasks.slice(0, currentTaskIndex).filter((t) => t.status === "completed");
    return {
      previousResults: previousTasks.map((t) => ({
        taskId: t.id,
        taskName: t.name,
        result: t.result
      }))
    };
  }
  /**
   * Get tools available for a specific agent
   */
  getToolsForAgent(agent2, allTools) {
    if (!agent2.tools || agent2.tools.length === 0) {
      return allTools;
    }
    return allTools.filter((tool) => agent2.tools.includes(tool.name));
  }
  /**
   * Get tools instructions string
   */
  getToolsInstructionsString(tools2) {
    if (tools2.length === 0) {
      return "";
    }
    let toolsString = "You have access to the following tools:\n";
    tools2.forEach((tool) => {
      toolsString += `- ${tool.name}: ${tool.description}
`;
      toolsString += "  Parameters:\n";
      Object.entries(tool.parameters).forEach(([paramName, paramInfo]) => {
        toolsString += `    - ${paramName} (${paramInfo.type}${paramInfo.required ? ", required" : ""}): ${paramInfo.description}
`;
      });
    });
    return toolsString;
  }
  /**
   * Add an entry to the process log
   */
  addToLog(agent2, action, details) {
    this.processLog.push({
      timestamp: /* @__PURE__ */ new Date(),
      agent: agent2,
      action,
      details
    });
  }
  /**
   * Get the process transcript
   */
  getProcessTranscript() {
    let transcript = "";
    this.processLog.forEach((entry) => {
      const time = entry.timestamp.toLocaleTimeString();
      transcript += `[${time}] ${entry.agent} - ${entry.action}
`;
      if (entry.details) {
        if (typeof entry.details === "string") {
          transcript += entry.details + "\n";
        } else if (typeof entry.details === "object") {
          if (entry.details.message) {
            transcript += `${entry.details.message}
`;
          }
          if (entry.details.output) {
            transcript += `Output: ${JSON.stringify(entry.details.output)}
`;
          }
          if (entry.details.error) {
            transcript += `Error: ${entry.details.error}
`;
          }
        }
      }
      transcript += "\n";
    });
    return transcript;
  }
  /**
   * Get available tools
   */
  getAvailableTools() {
    return this.availableTools;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.tools) {
      this.availableTools = config.tools;
    }
    if (config.agents) {
      this.agents = config.agents;
    }
  }
  /**
   * Get supported execution modes
   */
  getSupportedExecutionModes() {
    return ["synchronous" /* SYNCHRONOUS */, "asynchronous" /* ASYNCHRONOUS */];
  }
  /**
   * Check if protocol supports a specific capability
   */
  supportsCapability(capability) {
    return this.config.capabilities.includes(capability);
  }
  /**
   * Get current protocol configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    this.tasks = [];
    this.processLog = [];
    this.initialized = false;
    return Promise.resolve();
  }
};

// server/services/agent/protocols/OpenInterpreterProtocol.ts
import Anthropic7 from "@anthropic-ai/sdk";
import { exec as exec2 } from "child_process";
import { promisify } from "util";
import * as fs3 from "fs/promises";
import * as path4 from "path";
var execAsync = promisify(exec2);
var DEFAULT_MODEL5 = "claude-3-7-sonnet-20250219";
var SupportedLanguage = /* @__PURE__ */ ((SupportedLanguage2) => {
  SupportedLanguage2["PYTHON"] = "python";
  SupportedLanguage2["JAVASCRIPT"] = "javascript";
  SupportedLanguage2["TYPESCRIPT"] = "typescript";
  SupportedLanguage2["BASH"] = "bash";
  SupportedLanguage2["SQL"] = "sql";
  return SupportedLanguage2;
})(SupportedLanguage || {});
var languageCommands = {
  ["python" /* PYTHON */]: "python",
  ["javascript" /* JAVASCRIPT */]: "node",
  ["typescript" /* TYPESCRIPT */]: "tsx",
  ["bash" /* BASH */]: "bash",
  ["sql" /* SQL */]: "sqlite3"
};
var OpenInterpreterProtocol = class {
  config = {
    systemPrompt: "You are a code interpreter that can write and execute code to solve tasks.",
    tools: [],
    modelName: DEFAULT_MODEL5,
    temperature: 0.5,
    maxTokens: 4096,
    capabilities: [
      "multi_step" /* MULTI_STEP */,
      "code_execution" /* CODE_EXECUTION */,
      "self_correction" /* SELF_CORRECTION */,
      "tool_use" /* TOOL_USE */
    ],
    allowedLanguages: Object.values(SupportedLanguage),
    maxExecutions: 5,
    // Maximum number of code execution attempts
    sandboxed: true,
    // Whether to run in a sandboxed environment
    workingDir: "./tmp"
    // Working directory for code execution
  };
  anthropicClient = null;
  availableTools = [];
  initialized = false;
  codeHistory = [];
  /**
   * Get metadata about this protocol
   */
  getMetadata() {
    return {
      name: "OpenInterpreter",
      version: "1.0.0",
      description: "Protocol for LLM-powered code execution and correction",
      capabilities: [
        "multi_step" /* MULTI_STEP */,
        "code_execution" /* CODE_EXECUTION */,
        "self_correction" /* SELF_CORRECTION */,
        "tool_use" /* TOOL_USE */
      ],
      requiresAuthentication: true,
      supportedModels: [
        "claude-3-7-sonnet-20250219",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "gpt-4o",
        "gpt-4-turbo",
        "gpt-4"
      ]
    };
  }
  /**
   * Initialize the protocol with configuration
   */
  async init(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (this.config.modelName?.includes("claude")) {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY environment variable is required for Claude models");
      }
      this.anthropicClient = new Anthropic7({
        apiKey: process.env.ANTHROPIC_API_KEY
      });
    }
    this.availableTools = this.config.tools || [];
    const workingDir = this.config.workingDir;
    try {
      await fs3.mkdir(workingDir, { recursive: true });
    } catch (error) {
      log(`Error creating working directory: ${error}`, "agent");
    }
    this.codeHistory = [];
    this.initialized = true;
  }
  /**
   * Execute a task using this protocol
   */
  async execute(options2) {
    if (!this.initialized) {
      throw new Error("Protocol not initialized. Call init() first.");
    }
    const startTime2 = Date.now();
    try {
      if (options2.callbacks?.onStart) {
        options2.callbacks.onStart();
      }
      const result2 = await this.solveTaskWithCode(options2.task, options2);
      const agentResponse = {
        response: result2.finalSummary,
        usedTools: result2.toolExecutions,
        thinking: this.getCodeExecutionHistory(),
        executionTime: Date.now() - startTime2
      };
      if (options2.callbacks?.onComplete) {
        options2.callbacks.onComplete(agentResponse);
      }
      return agentResponse;
    } catch (error) {
      log(`OpenInterpreter Protocol execution error: ${error}`, "agent");
      if (options2.callbacks?.onError) {
        options2.callbacks.onError(error);
      }
      throw error;
    }
  }
  /**
   * Solve a task by generating and executing code
   */
  async solveTaskWithCode(task, options2) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const maxExecutions = this.config.maxExecutions;
    const tools2 = options2.tools || this.availableTools;
    const toolExecutions = [];
    if (options2.callbacks?.onStep) {
      options2.callbacks.onStep({
        name: "Task Analysis",
        description: "Analyzing the task and determining approach",
        status: "started"
      });
    }
    const initialCodeGeneration = await this.generateCode(task, null);
    this.codeHistory.push({
      language: initialCodeGeneration.language,
      code: initialCodeGeneration.code
    });
    if (options2.callbacks?.onStep) {
      options2.callbacks.onStep({
        name: "Code Generation",
        description: `Generated initial ${initialCodeGeneration.language} code`,
        output: initialCodeGeneration.code,
        status: "completed"
      });
    }
    let currentCode = initialCodeGeneration.code;
    let currentLanguage = initialCodeGeneration.language;
    let finalOutput = null;
    let executionCount = 0;
    while (executionCount < maxExecutions && finalOutput === null) {
      executionCount++;
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Execution Attempt ${executionCount}`,
          description: `Executing ${currentLanguage} code (attempt ${executionCount})`,
          status: "started"
        });
      }
      try {
        const executionResult = await this.executeCode(currentLanguage, currentCode);
        this.codeHistory[this.codeHistory.length - 1].result = executionResult;
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: `Execution Attempt ${executionCount}`,
            description: `Executed ${currentLanguage} code (attempt ${executionCount})`,
            output: `stdout: ${executionResult.stdout}
stderr: ${executionResult.stderr}
exit code: ${executionResult.exitCode}`,
            status: "completed"
          });
        }
        if (executionResult.exitCode === 0) {
          const evaluationResult = await this.evaluateExecution(
            task,
            currentLanguage,
            currentCode,
            executionResult
          );
          if (evaluationResult.solved) {
            finalOutput = evaluationResult.explanation;
            if (options2.callbacks?.onStep) {
              options2.callbacks.onStep({
                name: "Task Completion",
                description: "Task successfully solved with code execution",
                output: finalOutput,
                status: "completed"
              });
            }
          } else {
            const improvedCode = await this.generateCode(
              task,
              {
                previousCode: currentCode,
                previousLanguage: currentLanguage,
                executionResult,
                feedback: evaluationResult.explanation
              }
            );
            currentCode = improvedCode.code;
            currentLanguage = improvedCode.language;
            this.codeHistory.push({
              language: improvedCode.language,
              code: improvedCode.code
            });
            if (options2.callbacks?.onStep) {
              options2.callbacks.onStep({
                name: "Code Improvement",
                description: `Generated improved ${improvedCode.language} code`,
                output: improvedCode.code,
                status: "completed"
              });
            }
          }
        } else {
          const fixedCode = await this.generateCode(
            task,
            {
              previousCode: currentCode,
              previousLanguage: currentLanguage,
              executionResult,
              feedback: `Execution failed with exit code ${executionResult.exitCode}. Error: ${executionResult.stderr}`
            }
          );
          currentCode = fixedCode.code;
          currentLanguage = fixedCode.language;
          this.codeHistory.push({
            language: fixedCode.language,
            code: fixedCode.code
          });
          if (options2.callbacks?.onStep) {
            options2.callbacks.onStep({
              name: "Code Fixing",
              description: `Generated fixed ${fixedCode.language} code`,
              output: fixedCode.code,
              status: "completed"
            });
          }
        }
      } catch (error) {
        const errorMessage = error.message;
        this.codeHistory[this.codeHistory.length - 1].error = errorMessage;
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: `Execution Attempt ${executionCount}`,
            description: `Executing ${currentLanguage} code (attempt ${executionCount})`,
            error: errorMessage,
            status: "failed"
          });
        }
        const fixedCode = await this.generateCode(
          task,
          {
            previousCode: currentCode,
            previousLanguage: currentLanguage,
            feedback: `Execution encountered a system error: ${errorMessage}`
          }
        );
        currentCode = fixedCode.code;
        currentLanguage = fixedCode.language;
        this.codeHistory.push({
          language: fixedCode.language,
          code: fixedCode.code
        });
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: "Code Fixing",
            description: `Generated fixed ${fixedCode.language} code after system error`,
            output: fixedCode.code,
            status: "completed"
          });
        }
      }
      if (tools2.length > 0 && executionCount === maxExecutions && finalOutput === null) {
        try {
          const toolResult = await this.attemptToolUse(task, tools2, options2);
          if (toolResult) {
            toolExecutions.push(toolResult);
            finalOutput = `I used the ${toolResult.tool} tool to help solve this task:

${JSON.stringify(toolResult.output, null, 2)}`;
            if (options2.callbacks?.onStep) {
              options2.callbacks.onStep({
                name: "Tool Usage",
                description: `Used ${toolResult.tool} tool as fallback`,
                output: JSON.stringify(toolResult.output),
                status: "completed"
              });
            }
          }
        } catch (error) {
          log(`Error using tools as fallback: ${error}`, "agent");
        }
      }
    }
    if (finalOutput === null) {
      finalOutput = await this.generateFinalSummary(task);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Final Summary",
          description: "Generated summary of execution attempts",
          output: finalOutput,
          status: "completed"
        });
      }
    }
    return {
      finalSummary: finalOutput,
      toolExecutions
    };
  }
  /**
   * Generate code to solve a task
   */
  async generateCode(task, context) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const allowedLanguages = this.config.allowedLanguages;
    let codePrompt = `${this.config.systemPrompt}

You are a code interpreter that can write and execute code to solve tasks. Your goal is to write code that solves the given task. You should:

1. Choose the most appropriate programming language for the task from: ${allowedLanguages.join(", ")}
2. Write clear, efficient, and correct code
3. Include helpful comments to explain your approach
4. Ensure the code is complete and ready to execute
5. Assume standard libraries are available but specify any non-standard dependencies`;
    if (context) {
      codePrompt += `

Context from previous attempt:
      
Programming language: ${context.previousLanguage || "Not specified"}

Previous code:
\`\`\`${context.previousLanguage || ""}
${context.previousCode || "No previous code"}
\`\`\`

${context.executionResult ? `Execution result:
- stdout: ${context.executionResult.stdout}
- stderr: ${context.executionResult.stderr}
- exit code: ${context.executionResult.exitCode}
- execution time: ${context.executionResult.executionTime}ms` : ""}

${context.feedback ? `Feedback: ${context.feedback}` : ""}

Based on this context, please improve the code to better solve the task. You can:
1. Fix any errors in the previous code
2. Improve the algorithm or approach
3. Add missing functionality
4. Switch to a different programming language if appropriate`;
    }
    codePrompt += `

Respond with a JSON object in the following format:
{
  "reasoning": "Your step-by-step reasoning about how to approach the task",
  "language": "The programming language you chose (must be one of the allowed languages)",
  "code": "Your complete code solution"
}`;
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: codePrompt,
      messages: [{ role: "user", content: `Task: ${task}` }]
    });
    const content2 = response.content[0].text;
    return this.parseCodeFromResponse(content2, allowedLanguages);
  }
  /**
   * Parse code from the LLM response
   */
  async parseCodeFromResponse(content2, allowedLanguages) {
    try {
      const jsonMatch = content2.match(/```json\n([\s\S]*?)\n```/) || content2.match(/```([\s\S]*?)```/) || content2.match(/{[\s\S]*?}/);
      if (!jsonMatch) {
        const codeBlockMatch = content2.match(/```([a-zA-Z0-9]+)\n([\s\S]*?)\n```/);
        if (codeBlockMatch) {
          const language2 = codeBlockMatch[1].toLowerCase();
          const code2 = codeBlockMatch[2];
          if (allowedLanguages.includes(language2)) {
            return { language: language2, code: code2 };
          } else {
            return { language: allowedLanguages[0], code: code2 };
          }
        }
        throw new Error("Could not extract code or JSON from response");
      }
      let responseJson;
      try {
        responseJson = JSON.parse(jsonMatch[0].replace(/```json\n|```/g, ""));
      } catch (e) {
        try {
          responseJson = JSON.parse(jsonMatch[1].trim());
        } catch (e2) {
          throw new Error("Invalid JSON format in response");
        }
      }
      let language = responseJson.language?.toLowerCase();
      const code = responseJson.code || "";
      if (!language || !allowedLanguages.includes(language)) {
        language = allowedLanguages[0];
      }
      return { language, code };
    } catch (error) {
      log(`Error parsing code from response: ${error}`, "agent");
      return {
        language: allowedLanguages[0],
        code: content2
      };
    }
  }
  /**
   * Execute code
   */
  async executeCode(language, code) {
    const command = languageCommands[language];
    if (!command) {
      throw new Error(`Unsupported language: ${language}`);
    }
    const workingDir = this.config.workingDir;
    const extension = this.getFileExtension(language);
    const filename = `code_${Date.now()}_${Math.random().toString(36).substring(2, 9)}${extension}`;
    const filepath = path4.join(workingDir, filename);
    try {
      await fs3.writeFile(filepath, code);
      const startTime2 = Date.now();
      let result2;
      if (language === "sql" /* SQL */) {
        const dbPath = path4.join(workingDir, `db_${Date.now()}.sqlite`);
        result2 = await execAsync(`${command} ${dbPath} < ${filepath}`);
      } else {
        result2 = await execAsync(`${command} ${filepath}`, {
          cwd: workingDir,
          timeout: 3e4
          // 30 second timeout
        });
      }
      const executionTime = Date.now() - startTime2;
      return {
        stdout: result2.stdout,
        stderr: result2.stderr,
        exitCode: 0,
        executionTime
      };
    } catch (error) {
      return {
        stdout: error.stdout || "",
        stderr: error.stderr || error.message,
        exitCode: error.code || 1,
        executionTime: 0
      };
    } finally {
      try {
        await fs3.unlink(filepath);
      } catch (error) {
      }
    }
  }
  /**
   * Evaluate if the execution solved the task
   */
  async evaluateExecution(task, language, code, executionResult) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const evaluationPrompt = `${this.config.systemPrompt}

You are evaluating whether a code execution successfully solved a given task. Your goal is to determine if the task is fully solved or if more work is needed.

Task: ${task}

Code (${language}):
\`\`\`${language}
${code}
\`\`\`

Execution result:
- stdout: ${executionResult.stdout}
- stderr: ${executionResult.stderr}
- exit code: ${executionResult.exitCode}
- execution time: ${executionResult.executionTime}ms

Please analyze:
1. Does the code correctly implement a solution to the task?
2. Does the execution result indicate success?
3. Are there any errors or warnings that need to be addressed?
4. Is the output correct and complete?
5. Is there anything missing or any improvements needed?

Respond with a JSON object in the following format:
{
  "solved": true/false,
  "explanation": "Your detailed explanation of why the task is solved or what still needs to be done"
}`;
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: 0.3,
      // Lower temperature for more consistent evaluation
      system: evaluationPrompt,
      messages: [{ role: "user", content: "Evaluate code execution result" }]
    });
    try {
      const content2 = response.content[0].text;
      const jsonMatch = content2.match(/```json\n([\s\S]*?)\n```/) || content2.match(/```([\s\S]*?)```/) || content2.match(/{[\s\S]*?}/);
      if (!jsonMatch) {
        return {
          solved: false,
          explanation: "Could not parse evaluation response"
        };
      }
      let evaluationJson;
      try {
        evaluationJson = JSON.parse(jsonMatch[0].replace(/```json\n|```/g, ""));
      } catch (e) {
        try {
          evaluationJson = JSON.parse(jsonMatch[1].trim());
        } catch (e2) {
          throw new Error("Invalid JSON format in evaluation response");
        }
      }
      return {
        solved: evaluationJson.solved === true,
        explanation: evaluationJson.explanation || "No explanation provided"
      };
    } catch (error) {
      log(`Error parsing evaluation: ${error}`, "agent");
      return {
        solved: false,
        explanation: `Error evaluating result: ${error.message}`
      };
    }
  }
  /**
   * Generate a final summary of execution attempts
   */
  async generateFinalSummary(task) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const summaryPrompt = `${this.config.systemPrompt}

You are generating a final summary of code execution attempts for a task. Your goal is to explain what was attempted, what worked, what didn't work, and what could be done differently.

Task: ${task}

Code execution history:
${this.codeHistory.map((entry, index2) => `
Attempt ${index2 + 1} (${entry.language}):
\`\`\`${entry.language}
${entry.code}
\`\`\`

${entry.result ? `Execution result:
- stdout: ${entry.result.stdout}
- stderr: ${entry.result.stderr}
- exit code: ${entry.result.exitCode}
- execution time: ${entry.result.executionTime}ms` : entry.error ? `Execution error: ${entry.error}` : "No execution information"}`).join("\n\n")}

Please provide a comprehensive summary that:
1. Explains the overall approach taken
2. Highlights what worked and what didn't
3. Analyzes the main challenges encountered
4. Suggests what could be done differently
5. Provides the most useful output or results from the attempts

Your summary should be informative and help the user understand the outcome of the code execution attempts.`;
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: 0.5,
      system: summaryPrompt,
      messages: [{ role: "user", content: "Generate a final summary of code execution attempts" }]
    });
    return response.content[0].text;
  }
  /**
   * Attempt to use a tool as a fallback
   */
  async attemptToolUse(task, tools2, options2) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    if (tools2.length === 0) {
      return null;
    }
    const toolPrompt = `${this.config.systemPrompt}

You are selecting a tool to help solve a task after code execution attempts have failed. Your goal is to choose the most appropriate tool and provide the correct inputs.

Task: ${task}

Code execution history:
${this.codeHistory.map((entry, index2) => `
Attempt ${index2 + 1} (${entry.language}):
\`\`\`${entry.language}
${entry.code}
\`\`\`

${entry.result ? `Execution result:
- stdout: ${entry.result.stdout}
- stderr: ${entry.result.stderr}
- exit code: ${entry.result.exitCode}
- execution time: ${entry.result.executionTime}ms` : entry.error ? `Execution error: ${entry.error}` : "No execution information"}`).join("\n\n")}

Available tools:
${tools2.map((tool) => {
      return `- ${tool.name}: ${tool.description}
  Parameters:
${Object.entries(tool.parameters).map(([paramName, paramInfo]) => {
        return `    - ${paramName} (${paramInfo.type}${paramInfo.required ? ", required" : ""}): ${paramInfo.description}`;
      }).join("\n")}`;
    }).join("\n\n")}

Choose the most appropriate tool to help solve this task. Respond with a JSON object in the following format:
{
  "reasoning": "Your step-by-step reasoning about which tool to use and why",
  "tool": "tool_name",
  "input": {
    "param1": "value1",
    ...
  }
}`;
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: 0.5,
      system: toolPrompt,
      messages: [{ role: "user", content: "Select a tool to help solve the task" }]
    });
    try {
      const content2 = response.content[0].text;
      const jsonMatch = content2.match(/```json\n([\s\S]*?)\n```/) || content2.match(/```([\s\S]*?)```/) || content2.match(/{[\s\S]*?}/);
      if (!jsonMatch) {
        return null;
      }
      let toolSelection;
      try {
        toolSelection = JSON.parse(jsonMatch[0].replace(/```json\n|```/g, ""));
      } catch (e) {
        try {
          toolSelection = JSON.parse(jsonMatch[1].trim());
        } catch (e2) {
          return null;
        }
      }
      const toolName = toolSelection.tool;
      const toolInput = toolSelection.input;
      const tool = tools2.find((t) => t.name === toolName);
      if (!tool) {
        return null;
      }
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName,
          input: toolInput,
          output: void 0,
          error: void 0
        });
      }
      try {
        const result2 = await tool.execute(toolInput);
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName,
            input: toolInput,
            output: result2,
            error: void 0
          });
        }
        return {
          tool: toolName,
          input: toolInput,
          output: result2
        };
      } catch (error) {
        log(`Error executing ${toolName}: ${error}`, "agent");
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName,
            input: toolInput,
            output: void 0,
            error: error.message
          });
        }
        return null;
      }
    } catch (error) {
      log(`Error parsing tool selection: ${error}`, "agent");
      return null;
    }
  }
  /**
   * Get file extension for a language
   */
  getFileExtension(language) {
    switch (language) {
      case "python" /* PYTHON */:
        return ".py";
      case "javascript" /* JAVASCRIPT */:
        return ".js";
      case "typescript" /* TYPESCRIPT */:
        return ".ts";
      case "bash" /* BASH */:
        return ".sh";
      case "sql" /* SQL */:
        return ".sql";
      default:
        return ".txt";
    }
  }
  /**
   * Get code execution history as formatted string
   */
  getCodeExecutionHistory() {
    return this.codeHistory.map((entry, index2) => {
      return `# Attempt ${index2 + 1} (${entry.language})

\`\`\`${entry.language}
${entry.code}
\`\`\`

${entry.result ? `## Execution Result
\`\`\`
stdout: ${entry.result.stdout}
stderr: ${entry.result.stderr}
exit code: ${entry.result.exitCode}
execution time: ${entry.result.executionTime}ms
\`\`\`` : entry.error ? `## Execution Error
\`\`\`
${entry.error}
\`\`\`` : "## No Execution Information"}`;
    }).join("\n\n---\n\n");
  }
  /**
   * Get available tools
   */
  getAvailableTools() {
    return this.availableTools;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.tools) {
      this.availableTools = config.tools;
    }
  }
  /**
   * Get supported execution modes
   */
  getSupportedExecutionModes() {
    return ["synchronous" /* SYNCHRONOUS */];
  }
  /**
   * Check if protocol supports a specific capability
   */
  supportsCapability(capability) {
    return this.config.capabilities.includes(capability);
  }
  /**
   * Get current protocol configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    const workingDir = this.config.workingDir;
    try {
      const files = await fs3.readdir(workingDir);
      for (const file of files) {
        await fs3.unlink(path4.join(workingDir, file));
      }
    } catch (error) {
      log(`Error cleaning up working directory: ${error}`, "agent");
    }
    this.codeHistory = [];
    this.initialized = false;
    return Promise.resolve();
  }
};

// server/services/agent/protocols/ArchonProtocol.ts
import Anthropic8 from "@anthropic-ai/sdk";
var DEFAULT_MODEL6 = "claude-3-7-sonnet-20250219";
var ArchonProtocol = class {
  config = {
    systemPrompt: "You are a self-healing agent that can detect, diagnose, and recover from errors during task execution.",
    tools: [],
    modelName: DEFAULT_MODEL6,
    temperature: 0.5,
    maxTokens: 2048,
    capabilities: [
      "multi_step" /* MULTI_STEP */,
      "tool_use" /* TOOL_USE */,
      "self_correction" /* SELF_CORRECTION */
    ],
    maxRecoveryAttempts: 3,
    // Maximum number of recovery attempts per step
    errorRules: [
      {
        errorType: "tool_error",
        strategy: "retry" /* RETRY */,
        maxAttempts: 2,
        description: "Retry tool execution with same parameters"
      },
      {
        errorType: "tool_error",
        strategy: "adapt" /* ADAPT */,
        maxAttempts: 2,
        description: "Adapt tool parameters and retry"
      },
      {
        errorType: "knowledge_gap",
        strategy: "rethink" /* RETHINK */,
        maxAttempts: 1,
        description: "Rethink approach with available information"
      },
      {
        errorType: "reasoning_error",
        strategy: "decompose" /* DECOMPOSE */,
        maxAttempts: 2,
        description: "Break down into smaller steps and solve incrementally"
      },
      {
        errorType: "any",
        strategy: "tool_switch" /* TOOL_SWITCH */,
        maxAttempts: 1,
        description: "Try an alternative tool"
      }
    ],
    timeoutMs: 6e4
    // Timeout for the entire execution (1 minute)
  };
  anthropicClient = null;
  availableTools = [];
  initialized = false;
  executionSteps = [];
  currentStepIndex = 0;
  errorLogs = [];
  /**
   * Get metadata about this protocol
   */
  getMetadata() {
    return {
      name: "Archon",
      version: "1.0.0",
      description: "Protocol for self-healing, error-correcting agent framework",
      capabilities: [
        "multi_step" /* MULTI_STEP */,
        "tool_use" /* TOOL_USE */,
        "self_correction" /* SELF_CORRECTION */
      ],
      requiresAuthentication: true,
      supportedModels: [
        "claude-3-7-sonnet-20250219",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "gpt-4o",
        "gpt-4-turbo",
        "gpt-4"
      ]
    };
  }
  /**
   * Initialize the protocol with configuration
   */
  async init(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (this.config.modelName?.includes("claude")) {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY environment variable is required for Claude models");
      }
      this.anthropicClient = new Anthropic8({
        apiKey: process.env.ANTHROPIC_API_KEY
      });
    }
    this.availableTools = this.config.tools || [];
    this.executionSteps = [];
    this.currentStepIndex = 0;
    this.errorLogs = [];
    this.initialized = true;
  }
  /**
   * Execute a task using this protocol
   */
  async execute(options2) {
    if (!this.initialized) {
      throw new Error("Protocol not initialized. Call init() first.");
    }
    const startTime2 = Date.now();
    const timeoutMs = this.config.timeoutMs;
    try {
      if (options2.callbacks?.onStart) {
        options2.callbacks.onStart();
      }
      await this.generatePlan(options2.task, options2);
      const executionResult = await this.executePlanWithRecovery(options2, startTime2, timeoutMs);
      const agentResponse = {
        response: executionResult.finalSummary,
        usedTools: executionResult.toolExecutions,
        thinking: this.getExecutionSummary(),
        executionTime: Date.now() - startTime2
      };
      if (options2.callbacks?.onComplete) {
        options2.callbacks.onComplete(agentResponse);
      }
      return agentResponse;
    } catch (error) {
      log(`Archon Protocol execution error: ${error}`, "agent");
      if (options2.callbacks?.onError) {
        options2.callbacks.onError(error);
      }
      throw error;
    }
  }
  /**
   * Generate a plan for executing the task
   */
  async generatePlan(task, options2) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    if (options2.callbacks?.onStep) {
      options2.callbacks.onStep({
        name: "Plan Generation",
        description: "Generating execution plan with error recovery",
        status: "started"
      });
    }
    const planningPrompt = `${this.config.systemPrompt}

You are a self-healing agent that specializes in robust task execution with error recovery. Your job is to:

1. Break down a task into logical steps
2. For each step, consider potential errors that might occur
3. Define error recovery strategies for each step
4. Organize steps in a sequence that allows for the most robust execution

${this.getToolsInstructionsString()}

For the given task, create a plan with 3-7 well-defined steps. For each step:
- Provide a clear name and description
- Identify which tool (if any) should be used
- Define the expected inputs and outputs
- Consider dependencies between steps

Respond with a JSON object in the following format:
{
  "reasoning": "Your step-by-step reasoning about the task and potential challenges",
  "steps": [
    {
      "id": "step_1",
      "name": "Short step name",
      "description": "Detailed step description",
      "tool": "tool_name" (if applicable),
      "input": { param1: "value1", ... } (if applicable),
      "dependencies": [] (IDs of steps this depends on)
    },
    ...
  ]
}`;
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: planningPrompt,
      messages: [{ role: "user", content: `Task: ${task}` }]
    });
    const content2 = response.content[0].text;
    this.executionSteps = await this.parsePlanFromResponse(content2);
    this.currentStepIndex = 0;
    if (options2.callbacks?.onStep) {
      options2.callbacks.onStep({
        name: "Plan Generation",
        description: "Generated execution plan with error recovery",
        output: this.executionSteps.map((step) => step.name).join(", "),
        status: "completed"
      });
    }
  }
  /**
   * Parse the plan from the LLM response
   */
  async parsePlanFromResponse(content2) {
    try {
      const jsonMatch = content2.match(/```json\n([\s\S]*?)\n```/) || content2.match(/```([\s\S]*?)```/) || content2.match(/{[\s\S]*?}/);
      if (!jsonMatch) {
        throw new Error("Could not extract JSON plan from response");
      }
      let planJson;
      try {
        planJson = JSON.parse(jsonMatch[0].replace(/```json\n|```/g, ""));
      } catch (e) {
        planJson = JSON.parse(jsonMatch[1].trim());
      }
      if (!planJson || !Array.isArray(planJson.steps)) {
        throw new Error("Invalid plan format in response");
      }
      return planJson.steps.map((step) => ({
        id: step.id || `step_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
        name: step.name || "Unnamed Step",
        description: step.description || "",
        status: "pending",
        tool: step.tool,
        input: step.input,
        dependencies: step.dependencies || []
      }));
    } catch (error) {
      log(`Error parsing plan from response: ${error}`, "agent");
      return [{
        id: `step_${Date.now()}`,
        name: "Execute Task",
        description: "Execute the requested task directly",
        status: "pending"
      }];
    }
  }
  /**
   * Execute the plan with error recovery
   */
  async executePlanWithRecovery(options2, startTime2, timeoutMs) {
    const tools2 = options2.tools || this.availableTools;
    const toolExecutions = [];
    while (this.hasRemainingSteps()) {
      if (Date.now() - startTime2 > timeoutMs) {
        throw new Error(`Execution timed out after ${timeoutMs}ms`);
      }
      const nextStep = this.getNextExecutableStep();
      if (!nextStep) {
        break;
      }
      nextStep.status = "in_progress";
      nextStep.startTime = /* @__PURE__ */ new Date();
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: nextStep.name,
          description: nextStep.description,
          status: "started"
        });
      }
      try {
        const stepResult = await this.executeStep(nextStep, options2.task, tools2, options2);
        nextStep.status = "completed";
        nextStep.output = stepResult.output;
        nextStep.endTime = /* @__PURE__ */ new Date();
        if (stepResult.toolExecution) {
          toolExecutions.push(stepResult.toolExecution);
        }
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: nextStep.name,
            description: nextStep.description,
            output: typeof stepResult.output === "object" ? JSON.stringify(stepResult.output) : String(stepResult.output),
            status: "completed"
          });
        }
      } catch (error) {
        const errorMessage = error.message;
        const errorType = this.classifyError(error);
        nextStep.status = "failed";
        nextStep.error = {
          type: errorType,
          message: errorMessage,
          details: error
        };
        this.errorLogs.push({
          timestamp: /* @__PURE__ */ new Date(),
          step: nextStep.id,
          error
        });
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: nextStep.name,
            description: nextStep.description,
            error: errorMessage,
            status: "failed"
          });
        }
        const recoveryResult = await this.attemptRecovery(nextStep, options2.task, error, tools2, options2);
        if (recoveryResult.success) {
          nextStep.status = "recovered";
          nextStep.output = recoveryResult.output;
          nextStep.recovery = {
            strategy: recoveryResult.strategy,
            attempts: recoveryResult.attempts,
            success: true,
            notes: recoveryResult.notes
          };
          nextStep.endTime = /* @__PURE__ */ new Date();
          if (recoveryResult.toolExecution) {
            toolExecutions.push(recoveryResult.toolExecution);
          }
          this.errorLogs[this.errorLogs.length - 1].recovery = {
            strategy: recoveryResult.strategy,
            success: true
          };
          if (options2.callbacks?.onStep) {
            options2.callbacks.onStep({
              name: `${nextStep.name} (Recovered)`,
              description: `${nextStep.description} - Recovery succeeded using ${recoveryResult.strategy}`,
              output: typeof recoveryResult.output === "object" ? JSON.stringify(recoveryResult.output) : String(recoveryResult.output),
              status: "completed"
            });
          }
        } else {
          nextStep.recovery = {
            strategy: recoveryResult.strategy,
            attempts: recoveryResult.attempts,
            success: false,
            notes: recoveryResult.notes
          };
          nextStep.endTime = /* @__PURE__ */ new Date();
          this.errorLogs[this.errorLogs.length - 1].recovery = {
            strategy: recoveryResult.strategy,
            success: false
          };
          if (options2.callbacks?.onStep) {
            options2.callbacks.onStep({
              name: `${nextStep.name} (Recovery Failed)`,
              description: `${nextStep.description} - Recovery failed after ${recoveryResult.attempts} attempts`,
              error: recoveryResult.notes,
              status: "failed"
            });
          }
        }
      }
      this.currentStepIndex++;
    }
    const finalSummary = await this.generateExecutionSummary(options2.task);
    if (options2.callbacks?.onStep) {
      options2.callbacks.onStep({
        name: "Execution Summary",
        description: "Generated summary of execution with error recovery",
        output: finalSummary,
        status: "completed"
      });
    }
    return {
      finalSummary,
      toolExecutions
    };
  }
  /**
   * Execute a single step
   */
  async executeStep(step, task, tools2, options2) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    if (step.tool && step.input) {
      const tool = tools2.find((t) => t.name === step.tool);
      if (!tool) {
        throw new Error(`Tool '${step.tool}' specified in step '${step.name}' not found`);
      }
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: step.tool,
          input: step.input,
          output: void 0,
          error: void 0
        });
      }
      try {
        const result2 = await tool.execute(step.input);
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName: step.tool,
            input: step.input,
            output: result2,
            error: void 0
          });
        }
        return {
          output: result2,
          toolExecution: {
            tool: step.tool,
            input: step.input,
            output: result2
          }
        };
      } catch (error) {
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName: step.tool,
            input: step.input,
            output: void 0,
            error: error.message
          });
        }
        throw error;
      }
    }
    const context = this.getStepContext(step.id);
    const stepPrompt = `${this.config.systemPrompt}

You are executing a specific step in a task execution plan with error recovery.

Task: ${task}

Current step: ${step.name}
Description: ${step.description}

Context from previously completed steps:
${JSON.stringify(context, null, 2)}

Your goal is to complete this specific step successfully. Provide a clear, concise response that represents the output of this step.

Respond with a JSON object in the following format:
{
  "reasoning": "Your step-by-step reasoning about how to complete this step",
  "output": "The output of this step"
}`;
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: stepPrompt,
      messages: [{ role: "user", content: `Execute step: ${step.name}` }]
    });
    const content2 = response.content[0].text;
    try {
      const jsonMatch = content2.match(/```json\n([\s\S]*?)\n```/) || content2.match(/```([\s\S]*?)```/) || content2.match(/{[\s\S]*?}/);
      if (!jsonMatch) {
        return { output: content2 };
      }
      let responseJson;
      try {
        responseJson = JSON.parse(jsonMatch[0].replace(/```json\n|```/g, ""));
      } catch (e) {
        responseJson = JSON.parse(jsonMatch[1].trim());
      }
      return { output: responseJson.output || content2 };
    } catch (error) {
      return { output: content2 };
    }
  }
  /**
   * Attempt to recover from an error
   */
  async attemptRecovery(step, task, error, tools2, options2) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const errorType = step.error?.type || this.classifyError(error);
    const rules = this.getErrorRules(errorType, step.tool);
    const maxAttempts = this.config.maxRecoveryAttempts;
    for (const rule of rules) {
      const strategy = rule.strategy;
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Recovery: ${step.name}`,
          description: `Attempting recovery with strategy: ${strategy}`,
          status: "started"
        });
      }
      try {
        switch (strategy) {
          case "retry" /* RETRY */:
            if (!step.tool || !step.input) {
              continue;
            }
            const retryResult = await this.retryWithSameParameters(step, tools2, options2);
            if (retryResult.success) {
              return {
                success: true,
                strategy,
                attempts: 1,
                output: retryResult.output,
                toolExecution: retryResult.toolExecution,
                notes: "Retry with same parameters succeeded"
              };
            }
            break;
          case "adapt" /* ADAPT */:
            if (!step.tool || !step.input) {
              continue;
            }
            const adaptResult = await this.adaptParameters(step, task, error, tools2, options2);
            if (adaptResult.success) {
              return {
                success: true,
                strategy,
                attempts: adaptResult.attempts,
                output: adaptResult.output,
                toolExecution: adaptResult.toolExecution,
                notes: `Parameter adaptation succeeded after ${adaptResult.attempts} attempts`
              };
            }
            break;
          case "rethink" /* RETHINK */:
            const rethinkResult = await this.rethinkApproach(step, task, error, tools2, options2);
            if (rethinkResult.success) {
              return {
                success: true,
                strategy,
                attempts: 1,
                output: rethinkResult.output,
                toolExecution: rethinkResult.toolExecution,
                notes: "Approach rethinking succeeded"
              };
            }
            break;
          case "decompose" /* DECOMPOSE */:
            const decomposeResult = await this.decomposeProblem(step, task, error, tools2, options2);
            if (decomposeResult.success) {
              return {
                success: true,
                strategy,
                attempts: decomposeResult.subSteps.length,
                output: decomposeResult.output,
                notes: `Problem decomposition succeeded with ${decomposeResult.subSteps.length} sub-steps`
              };
            }
            break;
          case "tool_switch" /* TOOL_SWITCH */:
            if (tools2.length <= 1) {
              continue;
            }
            const toolSwitchResult = await this.switchTool(step, task, error, tools2, options2);
            if (toolSwitchResult.success) {
              return {
                success: true,
                strategy,
                attempts: 1,
                output: toolSwitchResult.output,
                toolExecution: toolSwitchResult.toolExecution,
                notes: `Switched to tool: ${toolSwitchResult.toolExecution.tool}`
              };
            }
            break;
          case "delegate" /* DELEGATE */:
            break;
          default:
            continue;
        }
      } catch (recoveryError) {
        log(`Error in recovery strategy ${strategy}: ${recoveryError}`, "agent");
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: `Recovery: ${step.name}`,
            description: `Recovery attempt with strategy ${strategy} failed`,
            error: recoveryError.message,
            status: "failed"
          });
        }
      }
    }
    return {
      success: false,
      strategy: rules.length > 0 ? rules[0].strategy : "retry" /* RETRY */,
      attempts: rules.length,
      notes: `All ${rules.length} recovery strategies failed`
    };
  }
  /**
   * Retry with the same parameters
   */
  async retryWithSameParameters(step, tools2, options2) {
    if (!step.tool || !step.input) {
      return { success: false };
    }
    const tool = tools2.find((t) => t.name === step.tool);
    if (!tool) {
      return { success: false };
    }
    try {
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: step.tool,
          input: step.input,
          output: void 0,
          error: void 0
        });
      }
      const result2 = await tool.execute(step.input);
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: step.tool,
          input: step.input,
          output: result2,
          error: void 0
        });
      }
      return {
        success: true,
        output: result2,
        toolExecution: {
          tool: step.tool,
          input: step.input,
          output: result2
        }
      };
    } catch (error) {
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: step.tool,
          input: step.input,
          output: void 0,
          error: error.message
        });
      }
      return { success: false };
    }
  }
  /**
   * Adapt parameters and retry
   */
  async adaptParameters(step, task, error, tools2, options2) {
    if (!this.anthropicClient || !step.tool || !step.input) {
      return { success: false, attempts: 0 };
    }
    const tool = tools2.find((t) => t.name === step.tool);
    if (!tool) {
      return { success: false, attempts: 0 };
    }
    const maxAttempts = 2;
    let attempts = 0;
    const adaptPrompt = `${this.config.systemPrompt}

You are adapting parameters for a failed tool execution to recover from an error. Your goal is to analyze the error and modify the parameters to make the tool execution succeed.

Task: ${task}

Step: ${step.name}
Description: ${step.description}

Tool: ${step.tool}
Tool description: ${tool.description}
Tool parameters:
${Object.entries(tool.parameters).map(([paramName, paramInfo]) => {
      return `- ${paramName} (${paramInfo.type}${paramInfo.required ? ", required" : ""}): ${paramInfo.description}`;
    }).join("\n")}

Original parameters:
${JSON.stringify(step.input, null, 2)}

Error:
${error.message}

Analyze the error carefully and determine how to modify the parameters to fix the issue. Respond with a JSON object in the following format:
{
  "reasoning": "Your step-by-step reasoning about what went wrong and how to fix it",
  "adaptedParameters": { ... modified parameters ... }
}`;
    while (attempts < maxAttempts) {
      attempts++;
      try {
        const response = await this.anthropicClient.messages.create({
          model: this.config.modelName,
          max_tokens: this.config.maxTokens,
          temperature: this.config.temperature,
          system: adaptPrompt,
          messages: [{
            role: "user",
            content: `Adapt parameters for failed tool execution. Attempt ${attempts}/${maxAttempts}.`
          }]
        });
        const content2 = response.content[0].text;
        const jsonMatch = content2.match(/```json\n([\s\S]*?)\n```/) || content2.match(/```([\s\S]*?)```/) || content2.match(/{[\s\S]*?}/);
        if (!jsonMatch) {
          continue;
        }
        let adaptedParams;
        try {
          adaptedParams = JSON.parse(jsonMatch[0].replace(/```json\n|```/g, "")).adaptedParameters;
        } catch (e) {
          try {
            adaptedParams = JSON.parse(jsonMatch[1].trim()).adaptedParameters;
          } catch (e2) {
            continue;
          }
        }
        if (!adaptedParams) {
          continue;
        }
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName: step.tool,
            input: adaptedParams,
            output: void 0,
            error: void 0
          });
        }
        try {
          const result2 = await tool.execute(adaptedParams);
          if (options2.callbacks?.onToolUse) {
            options2.callbacks.onToolUse({
              toolName: step.tool,
              input: adaptedParams,
              output: result2,
              error: void 0
            });
          }
          return {
            success: true,
            attempts,
            output: result2,
            toolExecution: {
              tool: step.tool,
              input: adaptedParams,
              output: result2
            }
          };
        } catch (execError) {
          if (options2.callbacks?.onToolUse) {
            options2.callbacks.onToolUse({
              toolName: step.tool,
              input: adaptedParams,
              output: void 0,
              error: execError.message
            });
          }
        }
      } catch (adaptError) {
        log(`Error in parameter adaptation attempt ${attempts}: ${adaptError}`, "agent");
      }
    }
    return { success: false, attempts };
  }
  /**
   * Rethink the approach for the step
   */
  async rethinkApproach(step, task, error, tools2, options2) {
    if (!this.anthropicClient) {
      return { success: false };
    }
    const rethinkPrompt = `${this.config.systemPrompt}

You are rethinking the approach for a failed step in a task execution. Your goal is to develop an alternative approach that avoids the error encountered.

Task: ${task}

Step: ${step.name}
Description: ${step.description}

Original approach:
${step.tool ? `Tool: ${step.tool}
Parameters: ${JSON.stringify(step.input, null, 2)}` : "No specific tool was used."}

Error:
${error.message}

${this.getToolsInstructionsString()}

Rethink the approach completely. You can:
1. Use a different methodology
2. Use a different tool (if appropriate)
3. Break the problem down differently
4. Make different assumptions

Respond with a JSON object in the following format:
{
  "reasoning": "Your step-by-step reasoning about the new approach",
  "newApproach": {
    "tool": "tool_name" (if using a tool),
    "input": { ... parameters ... } (if using a tool),
    "directOutput": "..." (if not using a tool)
  }
}`;
    try {
      const response = await this.anthropicClient.messages.create({
        model: this.config.modelName,
        max_tokens: this.config.maxTokens,
        temperature: this.config.temperature,
        system: rethinkPrompt,
        messages: [{
          role: "user",
          content: `Rethink approach for failed step: ${step.name}`
        }]
      });
      const content2 = response.content[0].text;
      const jsonMatch = content2.match(/```json\n([\s\S]*?)\n```/) || content2.match(/```([\s\S]*?)```/) || content2.match(/{[\s\S]*?}/);
      if (!jsonMatch) {
        return { success: false };
      }
      let newApproach;
      try {
        newApproach = JSON.parse(jsonMatch[0].replace(/```json\n|```/g, "")).newApproach;
      } catch (e) {
        try {
          newApproach = JSON.parse(jsonMatch[1].trim()).newApproach;
        } catch (e2) {
          return { success: false };
        }
      }
      if (!newApproach) {
        return { success: false };
      }
      if (newApproach.tool && newApproach.input) {
        const tool = tools2.find((t) => t.name === newApproach.tool);
        if (!tool) {
          return { success: false };
        }
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName: newApproach.tool,
            input: newApproach.input,
            output: void 0,
            error: void 0
          });
        }
        try {
          const result2 = await tool.execute(newApproach.input);
          if (options2.callbacks?.onToolUse) {
            options2.callbacks.onToolUse({
              toolName: newApproach.tool,
              input: newApproach.input,
              output: result2,
              error: void 0
            });
          }
          return {
            success: true,
            output: result2,
            toolExecution: {
              tool: newApproach.tool,
              input: newApproach.input,
              output: result2
            }
          };
        } catch (execError) {
          if (options2.callbacks?.onToolUse) {
            options2.callbacks.onToolUse({
              toolName: newApproach.tool,
              input: newApproach.input,
              output: void 0,
              error: execError.message
            });
          }
          return { success: false };
        }
      } else if (newApproach.directOutput) {
        return {
          success: true,
          output: newApproach.directOutput
        };
      }
      return { success: false };
    } catch (rethinkError) {
      log(`Error in rethinking approach: ${rethinkError}`, "agent");
      return { success: false };
    }
  }
  /**
   * Decompose the problem into smaller sub-steps
   */
  async decomposeProblem(step, task, error, tools2, options2) {
    if (!this.anthropicClient) {
      return { success: false, subSteps: [] };
    }
    const decomposePrompt = `${this.config.systemPrompt}

You are decomposing a failed step into smaller, more manageable sub-steps. Your goal is to break down the problem into parts that can be solved incrementally.

Task: ${task}

Step that failed: ${step.name}
Description: ${step.description}

Error:
${error.message}

${this.getToolsInstructionsString()}

Break down this step into 2-4 smaller sub-steps that together accomplish the original goal. Each sub-step should be:
1. Simpler than the original step
2. Focused on a specific aspect of the problem
3. More likely to succeed on its own
4. Clear and actionable

Respond with a JSON object in the following format:
{
  "reasoning": "Your step-by-step reasoning about how to decompose the problem",
  "subSteps": [
    {
      "name": "Sub-step 1 name",
      "description": "Detailed description",
      "tool": "tool_name" (if applicable),
      "input": { ... parameters ... } (if applicable)
    },
    ...
  ]
}`;
    try {
      const response = await this.anthropicClient.messages.create({
        model: this.config.modelName,
        max_tokens: this.config.maxTokens,
        temperature: this.config.temperature,
        system: decomposePrompt,
        messages: [{
          role: "user",
          content: `Decompose failed step: ${step.name}`
        }]
      });
      const content2 = response.content[0].text;
      const jsonMatch = content2.match(/```json\n([\s\S]*?)\n```/) || content2.match(/```([\s\S]*?)```/) || content2.match(/{[\s\S]*?}/);
      if (!jsonMatch) {
        return { success: false, subSteps: [] };
      }
      let subStepsData;
      try {
        subStepsData = JSON.parse(jsonMatch[0].replace(/```json\n|```/g, "")).subSteps;
      } catch (e) {
        try {
          subStepsData = JSON.parse(jsonMatch[1].trim()).subSteps;
        } catch (e2) {
          return { success: false, subSteps: [] };
        }
      }
      if (!Array.isArray(subStepsData) || subStepsData.length === 0) {
        return { success: false, subSteps: [] };
      }
      const subSteps = subStepsData.map((subStep, index2) => ({
        id: `substep_${step.id}_${index2}`,
        name: subStep.name || `Sub-step ${index2 + 1}`,
        description: subStep.description || "",
        status: "pending",
        tool: subStep.tool,
        input: subStep.input
      }));
      const subStepOutputs = [];
      for (const subStep of subSteps) {
        try {
          if (options2.callbacks?.onStep) {
            options2.callbacks.onStep({
              name: subStep.name,
              description: subStep.description,
              status: "started"
            });
          }
          const subStepResult = await this.executeStep(subStep, task, tools2, options2);
          subStep.status = "completed";
          subStep.output = subStepResult.output;
          subStepOutputs.push(subStepResult.output);
          if (options2.callbacks?.onStep) {
            options2.callbacks.onStep({
              name: subStep.name,
              description: subStep.description,
              output: typeof subStepResult.output === "object" ? JSON.stringify(subStepResult.output) : String(subStepResult.output),
              status: "completed"
            });
          }
        } catch (subStepError) {
          subStep.status = "failed";
          subStep.error = {
            type: this.classifyError(subStepError),
            message: subStepError.message,
            details: subStepError
          };
          if (options2.callbacks?.onStep) {
            options2.callbacks.onStep({
              name: subStep.name,
              description: subStep.description,
              error: subStepError.message,
              status: "failed"
            });
          }
        }
      }
      const completedSubSteps = subSteps.filter((s) => s.status === "completed");
      if (completedSubSteps.length > 0) {
        const synthesisResult = await this.synthesizeResults(step, completedSubSteps, task);
        return {
          success: true,
          subSteps,
          output: synthesisResult
        };
      }
      return { success: false, subSteps };
    } catch (decomposeError) {
      log(`Error in problem decomposition: ${decomposeError}`, "agent");
      return { success: false, subSteps: [] };
    }
  }
  /**
   * Synthesize results from sub-steps
   */
  async synthesizeResults(originalStep, subSteps, task) {
    if (!this.anthropicClient) {
      return "Failed to synthesize results";
    }
    const synthesisPrompt = `${this.config.systemPrompt}

You are synthesizing results from multiple sub-steps to create a cohesive output for the original step that was decomposed.

Original task: ${task}

Original step: ${originalStep.name}
Description: ${originalStep.description}

Results from sub-steps:
${subSteps.map((s) => `
Sub-step: ${s.name}
Description: ${s.description}
Result: ${typeof s.output === "object" ? JSON.stringify(s.output, null, 2) : s.output}`).join("\n")}

Your goal is to integrate these results into a single, coherent output that fulfills the original step's purpose. The synthesis should:
1. Combine the most important information from each sub-step
2. Resolve any conflicts or inconsistencies
3. Present a unified result that directly addresses the original step

Provide your synthesized result in a clear, well-structured format.`;
    try {
      const response = await this.anthropicClient.messages.create({
        model: this.config.modelName,
        max_tokens: this.config.maxTokens,
        temperature: 0.5,
        // Lower temperature for more focused synthesis
        system: synthesisPrompt,
        messages: [{
          role: "user",
          content: `Synthesize results from ${subSteps.length} sub-steps for: ${originalStep.name}`
        }]
      });
      return response.content[0].text;
    } catch (error) {
      log(`Error in result synthesis: ${error}`, "agent");
      return subSteps.filter((s) => s.status === "completed").map((s) => `[${s.name}]: ${typeof s.output === "object" ? JSON.stringify(s.output) : s.output}`).join("\n\n");
    }
  }
  /**
   * Switch to a different tool
   */
  async switchTool(step, task, error, tools2, options2) {
    if (!this.anthropicClient) {
      return { success: false };
    }
    if (!step.tool) {
      return { success: false };
    }
    const alternativeTools = tools2.filter((t) => t.name !== step.tool);
    if (alternativeTools.length === 0) {
      return { success: false };
    }
    const switchPrompt = `${this.config.systemPrompt}

You are switching to a different tool after a tool execution failed. Your goal is to select an alternative tool that can accomplish the same task.

Task: ${task}

Step: ${step.name}
Description: ${step.description}

Original tool: ${step.tool}
Original parameters: ${JSON.stringify(step.input, null, 2)}

Error:
${error.message}

Alternative tools available:
${alternativeTools.map((tool) => {
      return `- ${tool.name}: ${tool.description}
  Parameters:
${Object.entries(tool.parameters).map(([paramName, paramInfo]) => {
        return `    - ${paramName} (${paramInfo.type}${paramInfo.required ? ", required" : ""}): ${paramInfo.description}`;
      }).join("\n")}`;
    }).join("\n\n")}

Select the most appropriate alternative tool and provide the parameters needed. Respond with a JSON object in the following format:
{
  "reasoning": "Your step-by-step reasoning about which tool to select and why",
  "selectedTool": "tool_name",
  "parameters": { ... tool parameters ... }
}`;
    try {
      const response = await this.anthropicClient.messages.create({
        model: this.config.modelName,
        max_tokens: this.config.maxTokens,
        temperature: this.config.temperature,
        system: switchPrompt,
        messages: [{
          role: "user",
          content: `Select an alternative tool for: ${step.name}`
        }]
      });
      const content2 = response.content[0].text;
      const jsonMatch = content2.match(/```json\n([\s\S]*?)\n```/) || content2.match(/```([\s\S]*?)```/) || content2.match(/{[\s\S]*?}/);
      if (!jsonMatch) {
        return { success: false };
      }
      let toolSelection;
      try {
        toolSelection = JSON.parse(jsonMatch[0].replace(/```json\n|```/g, ""));
      } catch (e) {
        try {
          toolSelection = JSON.parse(jsonMatch[1].trim());
        } catch (e2) {
          return { success: false };
        }
      }
      if (!toolSelection.selectedTool || !toolSelection.parameters) {
        return { success: false };
      }
      const selectedTool = tools2.find((t) => t.name === toolSelection.selectedTool);
      if (!selectedTool) {
        return { success: false };
      }
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: toolSelection.selectedTool,
          input: toolSelection.parameters,
          output: void 0,
          error: void 0
        });
      }
      try {
        const result2 = await selectedTool.execute(toolSelection.parameters);
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName: toolSelection.selectedTool,
            input: toolSelection.parameters,
            output: result2,
            error: void 0
          });
        }
        return {
          success: true,
          output: result2,
          toolExecution: {
            tool: toolSelection.selectedTool,
            input: toolSelection.parameters,
            output: result2
          }
        };
      } catch (execError) {
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName: toolSelection.selectedTool,
            input: toolSelection.parameters,
            output: void 0,
            error: execError.message
          });
        }
        return { success: false };
      }
    } catch (switchError) {
      log(`Error in tool switching: ${switchError}`, "agent");
      return { success: false };
    }
  }
  /**
   * Classify the error type
   */
  classifyError(error) {
    const errorMessage = error.message || "";
    if (errorMessage.includes("permission") || errorMessage.includes("access") || errorMessage.includes("unauthorized")) {
      return "permission_error" /* PERMISSION_ERROR */;
    } else if (errorMessage.includes("not found") || errorMessage.includes("404") || errorMessage.includes("does not exist")) {
      return "knowledge_gap" /* KNOWLEDGE_GAP */;
    } else if (errorMessage.includes("invalid") || errorMessage.includes("format") || errorMessage.includes("malformed")) {
      return "data_error" /* DATA_ERROR */;
    } else if (errorMessage.includes("server") || errorMessage.includes("503") || errorMessage.includes("502")) {
      return "api_error" /* API_ERROR */;
    } else if (errorMessage.includes("timeout") || errorMessage.includes("memory") || errorMessage.includes("resource")) {
      return "system_error" /* SYSTEM_ERROR */;
    } else if (errorMessage.includes("tool") || errorMessage.includes("execution")) {
      return "tool_error" /* TOOL_ERROR */;
    } else if (errorMessage.includes("reasoning") || errorMessage.includes("logic") || errorMessage.includes("inference")) {
      return "reasoning_error" /* REASONING_ERROR */;
    }
    return "unknown" /* UNKNOWN */;
  }
  /**
   * Get error handling rules applicable to an error
   */
  getErrorRules(errorType, toolName) {
    const rules = this.config.errorRules;
    const specificRules = rules.filter(
      (rule) => rule.errorType === errorType && (rule.toolName === toolName || !rule.toolName)
    );
    if (specificRules.length > 0) {
      return specificRules;
    }
    const errorTypeRules = rules.filter((rule) => rule.errorType === errorType);
    if (errorTypeRules.length > 0) {
      return errorTypeRules;
    }
    const genericRules = rules.filter((rule) => rule.errorType === "any");
    if (genericRules.length > 0) {
      return genericRules;
    }
    return [{
      errorType: "any",
      strategy: "retry" /* RETRY */,
      maxAttempts: 1,
      description: "Default retry strategy"
    }];
  }
  /**
   * Check if there are remaining steps to execute
   */
  hasRemainingSteps() {
    return this.executionSteps.some((step) => step.status === "pending");
  }
  /**
   * Get the next executable step (one with no pending dependencies)
   */
  getNextExecutableStep() {
    const pendingSteps = this.executionSteps.filter((step) => step.status === "pending");
    if (pendingSteps.length === 0) {
      return null;
    }
    return pendingSteps.find((step) => {
      if (!step.dependencies || step.dependencies.length === 0) {
        return true;
      }
      const dependencies = this.executionSteps.filter((s) => step.dependencies.includes(s.id));
      return dependencies.every((d) => d.status === "completed" || d.status === "recovered");
    }) || null;
  }
  /**
   * Get context from completed steps for a specific step
   */
  getStepContext(stepId) {
    const step = this.executionSteps.find((s) => s.id === stepId);
    if (!step) {
      return {};
    }
    if (step.dependencies && step.dependencies.length > 0) {
      const dependencySteps = this.executionSteps.filter(
        (s) => step.dependencies.includes(s.id) && (s.status === "completed" || s.status === "recovered")
      );
      return {
        dependencyOutputs: dependencySteps.map((d) => ({
          stepId: d.id,
          stepName: d.name,
          output: d.output
        }))
      };
    }
    const currentStepIndex = this.executionSteps.findIndex((s) => s.id === stepId);
    const previousSteps = this.executionSteps.slice(0, currentStepIndex).filter((s) => s.status === "completed" || s.status === "recovered");
    return {
      previousOutputs: previousSteps.map((s) => ({
        stepId: s.id,
        stepName: s.name,
        output: s.output
      }))
    };
  }
  /**
   * Generate a summary of the execution
   */
  async generateExecutionSummary(task) {
    if (!this.anthropicClient) {
      return "Failed to generate execution summary";
    }
    const completedSteps = this.executionSteps.filter(
      (step) => step.status === "completed" || step.status === "recovered"
    );
    const failedSteps = this.executionSteps.filter(
      (step) => step.status === "failed"
    );
    const summaryPrompt = `${this.config.systemPrompt}

You are generating a summary of a task execution with error recovery. Your goal is to create a comprehensive overview of what happened, what succeeded, what failed, and how errors were handled.

Task: ${task}

Execution summary:
- Total steps: ${this.executionSteps.length}
- Completed steps: ${completedSteps.filter((s) => s.status === "completed").length}
- Recovered steps: ${completedSteps.filter((s) => s.status === "recovered").length}
- Failed steps: ${failedSteps.length}

Completed steps:
${completedSteps.map((step) => {
      const stepStatus = step.status === "recovered" ? " (Recovered)" : "";
      return `- ${step.name}${stepStatus}: ${typeof step.output === "object" ? JSON.stringify(step.output) : step.output}`;
    }).join("\n")}

${failedSteps.length > 0 ? `Failed steps:
${failedSteps.map((step) => {
      return `- ${step.name}: ${step.error?.message || "Unknown error"}`;
    }).join("\n")}` : ""}

${this.errorLogs.length > 0 ? `Error recovery summary:
${this.errorLogs.map((log2) => {
      const step = this.executionSteps.find((s) => s.id === log2.step);
      const recoveryStatus = log2.recovery ? log2.recovery.success ? `Recovery succeeded using ${log2.recovery.strategy}` : `Recovery failed using ${log2.recovery.strategy}` : "No recovery attempted";
      return `- ${step?.name || "Unknown step"}: ${recoveryStatus}`;
    }).join("\n")}` : ""}

Generate a comprehensive summary that:
1. Explains what the task was trying to accomplish
2. Summarizes the execution process, highlighting key steps
3. Explains any errors encountered and how they were handled
4. Provides the final outcome or result
5. Includes any relevant insights or recommendations

The summary should be clear, informative, and focus on the most important aspects of the execution.`;
    try {
      const response = await this.anthropicClient.messages.create({
        model: this.config.modelName,
        max_tokens: this.config.maxTokens,
        temperature: 0.5,
        // Lower temperature for more focused summary
        system: summaryPrompt,
        messages: [{
          role: "user",
          content: `Generate execution summary for: ${task}`
        }]
      });
      return response.content[0].text;
    } catch (error) {
      log(`Error generating execution summary: ${error}`, "agent");
      return `Task: ${task}

Execution Summary:
- ${completedSteps.length} of ${this.executionSteps.length} steps completed successfully
${failedSteps.length > 0 ? `- ${failedSteps.length} steps failed` : ""}
${completedSteps.filter((s) => s.status === "recovered").length > 0 ? `- ${completedSteps.filter((s) => s.status === "recovered").length} errors were successfully recovered from` : ""}

Results:
${completedSteps.map((step) => `- ${step.name}: ${typeof step.output === "object" ? JSON.stringify(step.output) : step.output}`).join("\n")}`;
    }
  }
  /**
   * Get a formatted execution summary for the response
   */
  getExecutionSummary() {
    const completedSteps = this.executionSteps.filter(
      (step) => step.status === "completed" || step.status === "recovered"
    );
    const failedSteps = this.executionSteps.filter(
      (step) => step.status === "failed"
    );
    let summary = `# Execution Summary

`;
    summary += `- Total steps: ${this.executionSteps.length}
`;
    summary += `- Completed steps: ${completedSteps.filter((s) => s.status === "completed").length}
`;
    summary += `- Recovered steps: ${completedSteps.filter((s) => s.status === "recovered").length}
`;
    summary += `- Failed steps: ${failedSteps.length}

`;
    summary += `## Steps Detail

`;
    this.executionSteps.forEach((step) => {
      const statusEmoji = step.status === "completed" ? "\u2705" : step.status === "recovered" ? "\u{1F504}" : step.status === "failed" ? "\u274C" : "\u23F3";
      summary += `### ${statusEmoji} ${step.name}

`;
      summary += `${step.description}

`;
      if (step.tool) {
        summary += `**Tool:** ${step.tool}

`;
        summary += `**Input:**
\`\`\`json
${JSON.stringify(step.input, null, 2)}
\`\`\`

`;
      }
      if (step.status === "completed" || step.status === "recovered") {
        summary += `**Output:**
\`\`\`
${typeof step.output === "object" ? JSON.stringify(step.output, null, 2) : step.output}
\`\`\`

`;
      }
      if (step.status === "failed") {
        summary += `**Error:**
\`\`\`
${step.error?.message || "Unknown error"}
\`\`\`

`;
      }
      if (step.status === "recovered") {
        summary += `**Recovery:**
`;
        summary += `- Strategy: ${step.recovery?.strategy}
`;
        summary += `- Attempts: ${step.recovery?.attempts}
`;
        summary += `- Notes: ${step.recovery?.notes}

`;
      }
      if (step.startTime && step.endTime) {
        const duration = (step.endTime.getTime() - step.startTime.getTime()) / 1e3;
        summary += `**Duration:** ${duration.toFixed(2)}s

`;
      }
      summary += `---

`;
    });
    if (this.errorLogs.length > 0) {
      summary += `## Error Recovery Report

`;
      this.errorLogs.forEach((log2, index2) => {
        const step = this.executionSteps.find((s) => s.id === log2.step);
        summary += `### Error ${index2 + 1}: ${step?.name || "Unknown step"}

`;
        summary += `**Error Type:** ${step?.error?.type || "Unknown"}
`;
        summary += `**Message:** ${step?.error?.message || "Unknown error"}

`;
        if (log2.recovery) {
          const statusEmoji = log2.recovery.success ? "\u2705" : "\u274C";
          summary += `**Recovery ${statusEmoji}:**
`;
          summary += `- Strategy: ${log2.recovery.strategy}
`;
          summary += `- Result: ${log2.recovery.success ? "Succeeded" : "Failed"}

`;
        } else {
          summary += `**Recovery:** Not attempted

`;
        }
        summary += `---

`;
      });
    }
    return summary;
  }
  /**
   * Get tools instructions string
   */
  getToolsInstructionsString() {
    const tools2 = this.availableTools;
    if (tools2.length === 0) {
      return "No tools are available for this task.";
    }
    let toolsString = "Available tools:\n";
    tools2.forEach((tool) => {
      toolsString += `- ${tool.name}: ${tool.description}
`;
      toolsString += "  Parameters:\n";
      Object.entries(tool.parameters).forEach(([paramName, paramInfo]) => {
        toolsString += `    - ${paramName} (${paramInfo.type}${paramInfo.required ? ", required" : ""}): ${paramInfo.description}
`;
      });
    });
    return toolsString;
  }
  /**
   * Get available tools
   */
  getAvailableTools() {
    return this.availableTools;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.tools) {
      this.availableTools = config.tools;
    }
  }
  /**
   * Get supported execution modes
   */
  getSupportedExecutionModes() {
    return ["synchronous" /* SYNCHRONOUS */, "asynchronous" /* ASYNCHRONOUS */];
  }
  /**
   * Check if protocol supports a specific capability
   */
  supportsCapability(capability) {
    return this.config.capabilities.includes(capability);
  }
  /**
   * Get current protocol configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    this.executionSteps = [];
    this.currentStepIndex = 0;
    this.errorLogs = [];
    this.initialized = false;
    return Promise.resolve();
  }
};

// server/services/agent/protocols/BabyAGIProtocol.ts
import Anthropic9 from "@anthropic-ai/sdk";
import OpenAI from "openai";
var DEFAULT_MODEL7 = "claude-3-7-sonnet-20250219";
var BabyAGIProtocol = class {
  config = {
    systemPrompt: `You are BabyAGI, a lightweight recursive task planner. Your goal is to:
1. Break down complex tasks into simpler subtasks
2. Execute each subtask in a logical order
3. Learn from previous task results to improve future planning
4. Use available tools when needed to accomplish subtasks
5. Maintain a structured task list with dependencies and priorities`,
    tools: [],
    modelName: DEFAULT_MODEL7,
    temperature: 0.7,
    maxTokens: 1024,
    capabilities: [
      "multi_step" /* MULTI_STEP */,
      "tool_use" /* TOOL_USE */,
      "recursive_planning" /* RECURSIVE_PLANNING */
    ]
  };
  anthropicClient = null;
  openaiClient = null;
  availableTools = [];
  initialized = false;
  tasks = [];
  taskIdCounter = 1;
  taskHistory = [];
  /**
   * Get metadata about this protocol
   */
  getMetadata() {
    return {
      name: "BabyAGI",
      version: "1.0.0",
      description: "Lightweight recursive task planner",
      capabilities: [
        "multi_step" /* MULTI_STEP */,
        "tool_use" /* TOOL_USE */,
        "recursive_planning" /* RECURSIVE_PLANNING */
      ],
      requiresAuthentication: true,
      supportedModels: [
        "claude-3-7-sonnet-20250219",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "gpt-4o",
        "gpt-4-turbo",
        "gpt-4"
      ]
    };
  }
  /**
   * Initialize the protocol with configuration
   */
  async init(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (this.config.modelName?.includes("claude")) {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY environment variable is required for Claude models");
      }
      this.anthropicClient = new Anthropic9({
        apiKey: process.env.ANTHROPIC_API_KEY
      });
    } else if (this.config.modelName?.includes("gpt")) {
      if (!process.env.OPENAI_API_KEY) {
        throw new Error("OPENAI_API_KEY environment variable is required for OpenAI models");
      }
      this.openaiClient = new OpenAI({
        apiKey: process.env.OPENAI_API_KEY
      });
    }
    this.availableTools = this.config.tools || [];
    this.tasks = [];
    this.taskIdCounter = 1;
    this.taskHistory = [];
    this.initialized = true;
  }
  /**
   * Execute a task using this protocol
   */
  async execute(options2) {
    if (!this.initialized) {
      throw new Error("Protocol not initialized. Call init() first.");
    }
    const startTime2 = Date.now();
    try {
      if (options2.callbacks?.onStart) {
        options2.callbacks.onStart();
      }
      const initialTask = {
        id: this.taskIdCounter++,
        name: "Initial Task",
        description: options2.task,
        status: "pending"
      };
      this.tasks.push(initialTask);
      await this.planTasks(initialTask, options2);
      await this.executeTasks(options2);
      const finalResponse = this.generateFinalResponse();
      const agentResponse = {
        response: {
          content: finalResponse,
          toolCalls: this.getToolCallHistory()
        },
        executionTime: Date.now() - startTime2,
        protocol: "babyagi",
        metadata: {
          tasks: this.tasks,
          taskHistory: this.taskHistory
        }
      };
      if (options2.callbacks?.onComplete) {
        options2.callbacks.onComplete(agentResponse);
      }
      return agentResponse;
    } catch (error) {
      log(`BabyAGI Protocol execution error: ${error}`, "agent");
      if (options2.callbacks?.onError) {
        options2.callbacks.onError(error);
      }
      throw error;
    }
  }
  /**
   * Plan and create subtasks for a given task
   */
  async planTasks(task, options2) {
    task.status = "in-progress";
    const planningPrompt = this.generatePlanningPrompt(task, options2);
    const planningResponse = await this.getResponseFromLLM(planningPrompt, "Create a structured plan to solve this task");
    const subtasks = this.parseSubtasksFromResponse(planningResponse, task.id);
    this.tasks.push(...subtasks);
    task.status = "completed";
    task.result = "Task broken down into subtasks";
    this.taskHistory.push(`Task ${task.id} planned: ${subtasks.length} subtasks created`);
    if (options2.callbacks?.onStep) {
      options2.callbacks.onStep({
        name: "Plan Tasks",
        description: `Created ${subtasks.length} subtasks for task ${task.id}`,
        output: subtasks,
        status: "completed"
      });
    }
  }
  /**
   * Execute all tasks in order of dependencies
   */
  async executeTasks(options2) {
    while (true) {
      const executableTasks = this.getExecutableTasks();
      if (executableTasks.length === 0) {
        const pendingTasks = this.tasks.filter((t) => t.status === "pending");
        if (pendingTasks.length > 0) {
          log("WARNING: Pending tasks with unsatisfied dependencies - possible circular dependency", "agent");
          break;
        } else {
          break;
        }
      }
      const taskPromises = executableTasks.slice(0, 3).map((task) => this.executeTask(task, options2));
      await Promise.all(taskPromises);
    }
  }
  /**
   * Execute a single task
   */
  async executeTask(task, options2) {
    try {
      task.status = "in-progress";
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Task ${task.id}`,
          description: task.description,
          status: "started"
        });
      }
      const toolToUse = this.identifyToolForTask(task);
      if (toolToUse) {
        await this.executeTaskWithTool(task, toolToUse, options2);
      } else {
        await this.executeTaskWithLLM(task, options2);
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Task ${task.id}`,
          description: task.description,
          output: task.result,
          status: "completed"
        });
      }
    } catch (error) {
      task.status = "failed";
      task.error = error.message;
      this.taskHistory.push(`Task ${task.id} failed: ${error.message}`);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Task ${task.id}`,
          description: task.description,
          error: error.message,
          status: "failed"
        });
      }
      log(`Task execution error: ${error}`, "agent");
    }
  }
  /**
   * Execute a task using a tool
   */
  async executeTaskWithTool(task, toolName, options2) {
    const tool = this.availableTools.find((t) => t.name === toolName);
    if (!tool) {
      throw new Error(`Tool ${toolName} not found`);
    }
    const toolInputParams = await this.generateToolInputParams(task, tool, options2);
    try {
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName,
          input: toolInputParams,
          output: void 0,
          error: void 0
        });
      }
      const result2 = await tool.execute(toolInputParams);
      task.status = "completed";
      task.result = typeof result2 === "object" ? JSON.stringify(result2) : String(result2);
      this.taskHistory.push(`Task ${task.id} completed using tool ${toolName}`);
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName,
          input: toolInputParams,
          output: result2,
          error: void 0
        });
      }
    } catch (error) {
      task.status = "failed";
      task.error = error.message;
      this.taskHistory.push(`Task ${task.id} failed using tool ${toolName}: ${error.message}`);
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName,
          input: toolInputParams,
          output: void 0,
          error: error.message
        });
      }
      throw error;
    }
  }
  /**
   * Execute a task using the LLM
   */
  async executeTaskWithLLM(task, options2) {
    const executionPrompt = this.generateExecutionPrompt(task, options2);
    const executionResponse = await this.getResponseFromLLM(
      executionPrompt,
      `Execute task ${task.id}: ${task.description}`
    );
    task.status = "completed";
    task.result = executionResponse;
    this.taskHistory.push(`Task ${task.id} completed with LLM`);
  }
  /**
   * Get executable tasks (pending tasks with satisfied dependencies)
   */
  getExecutableTasks() {
    return this.tasks.filter((task) => {
      if (task.status !== "pending") {
        return false;
      }
      if (!task.dependencies || task.dependencies.length === 0) {
        return true;
      }
      return task.dependencies.every((depId) => {
        const depTask = this.tasks.find((t) => t.id === depId);
        return depTask && depTask.status === "completed";
      });
    });
  }
  /**
   * Generate the planning prompt for creating subtasks
   */
  generatePlanningPrompt(task, options2) {
    let prompt = `${this.config.systemPrompt}

`;
    prompt += `Your task is: ${task.description}

`;
    const tools2 = options2.tools || this.availableTools;
    if (tools2.length > 0) {
      prompt += "You have access to the following tools to help you complete subtasks:\n";
      tools2.forEach((tool) => {
        prompt += `- ${tool.name}: ${tool.description}
`;
      });
    }
    prompt += `
Break this task down into logical subtasks. For each subtask, provide:
1. A short but descriptive name
2. A detailed description explaining what needs to be done
3. Any dependencies on other subtasks (by name)
4. If a tool should be used, mention which one

Respond with a JSON array of subtasks in the following format:
[
  {
    "name": "Subtask name",
    "description": "Detailed description of what needs to be done",
    "dependencies": ["Dependent subtask name 1", "Dependent subtask name 2"],
    "tool": "tool_name_if_applicable"
  },
  ...
]`;
    return prompt;
  }
  /**
   * Generate the execution prompt for a task
   */
  generateExecutionPrompt(task, options2) {
    let prompt = `${this.config.systemPrompt}

`;
    prompt += `Your task is: ${task.description}

`;
    if (task.dependencies && task.dependencies.length > 0) {
      prompt += "Context from previous completed tasks:\n";
      task.dependencies.forEach((depId) => {
        const depTask = this.tasks.find((t) => t.id === depId);
        if (depTask && depTask.status === "completed" && depTask.result) {
          prompt += `- Task "${depTask.name}": ${depTask.result}
`;
        }
      });
      prompt += "\n";
    }
    prompt += "Please execute this task and provide the result.";
    return prompt;
  }
  /**
   * Generate tool input parameters for a task
   */
  async generateToolInputParams(task, tool, options2) {
    let promptText = `Task: ${task.description}

You need to use the ${tool.name} tool to complete this task.
The tool requires the following parameters:
`;
    Object.entries(tool.parameters).forEach(([paramName, paramInfo]) => {
      promptText += `- ${paramName} (${paramInfo.type}${paramInfo.required ? ", required" : ""}): ${paramInfo.description}
`;
    });
    promptText += `
Based on the task description, generate appropriate values for these parameters. Respond with a JSON object containing the parameter values:
{
  "param1": "value1",
  "param2": "value2",
  ...
}`;
    const response = await this.getResponseFromLLM(promptText, `Generate parameters for ${tool.name} tool`);
    try {
      const jsonMatch = response.match(/{[\s\S]*?}/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      }
    } catch (error) {
      log(`Error parsing tool parameters: ${error}`, "agent");
    }
    const fallbackParams = {};
    Object.entries(tool.parameters).forEach(([paramName, paramInfo]) => {
      if (paramInfo.required) {
        const paramValueMatch = new RegExp(`${paramName}[:\\s]+(\\S+)`, "i").exec(task.description);
        if (paramValueMatch) {
          fallbackParams[paramName] = paramValueMatch[1];
        } else {
          switch (paramInfo.type) {
            case "string":
              fallbackParams[paramName] = "";
              break;
            case "number":
              fallbackParams[paramName] = 0;
              break;
            case "boolean":
              fallbackParams[paramName] = false;
              break;
            default:
              fallbackParams[paramName] = "";
          }
        }
      }
    });
    return fallbackParams;
  }
  /**
   * Parse subtasks from the LLM response
   */
  parseSubtasksFromResponse(response, parentTaskId) {
    try {
      const jsonMatch = response.match(/\[[\s\S]*?\]/);
      if (jsonMatch) {
        const parsedArray = JSON.parse(jsonMatch[0]);
        if (Array.isArray(parsedArray)) {
          return parsedArray.map((item, index2) => {
            const taskId = this.taskIdCounter++;
            const dependencies = [];
            if (item.dependencies && Array.isArray(item.dependencies)) {
              item.dependencies.forEach((depName) => {
                const depTask = this.tasks.find((t) => t.name === depName);
                if (depTask) {
                  dependencies.push(depTask.id);
                }
              });
            }
            return {
              id: taskId,
              name: item.name || `Subtask ${index2 + 1}`,
              description: item.description || "",
              status: "pending",
              dependencies: dependencies.length > 0 ? dependencies : [parentTaskId],
              toolSuggestion: item.tool
            };
          });
        }
      }
      const subtaskMatches = response.match(/(\d+\.\s+|[-*]\s+)(.*?)(?=\n\d+\.\s+|\n[-*]\s+|\n\n|$)/g);
      if (subtaskMatches) {
        return subtaskMatches.map((match, index2) => {
          const cleanedMatch = match.replace(/^\d+\.\s+|^[-*]\s+/, "").trim();
          return {
            id: this.taskIdCounter++,
            name: `Subtask ${index2 + 1}`,
            description: cleanedMatch,
            status: "pending",
            dependencies: [parentTaskId]
          };
        });
      }
      return [{
        id: this.taskIdCounter++,
        name: "Execute Task Directly",
        description: `Execute the original task: ${this.tasks.find((t) => t.id === parentTaskId)?.description}`,
        status: "pending",
        dependencies: [parentTaskId]
      }];
    } catch (error) {
      log(`Error parsing subtasks: ${error}`, "agent");
      return [{
        id: this.taskIdCounter++,
        name: "Execute Task Directly",
        description: `Execute the original task: ${this.tasks.find((t) => t.id === parentTaskId)?.description}`,
        status: "pending",
        dependencies: [parentTaskId]
      }];
    }
  }
  /**
   * Identify if a tool should be used for a task
   */
  identifyToolForTask(task) {
    if (task.toolSuggestion) {
      return task.toolSuggestion;
    }
    const toolMentions = this.availableTools.filter((tool) => {
      const toolPattern = new RegExp(`\\b${tool.name}\\b`, "i");
      return toolPattern.test(task.description);
    });
    if (toolMentions.length > 0) {
      return toolMentions[0].name;
    }
    return null;
  }
  /**
   * Get response from the appropriate LLM based on model name
   */
  async getResponseFromLLM(prompt, purpose) {
    try {
      if (this.config.modelName?.includes("claude")) {
        return await this.getResponseFromClaude(prompt);
      } else if (this.config.modelName?.includes("gpt")) {
        return await this.getResponseFromOpenAI(prompt);
      } else {
        return await this.getResponseFromClaude(prompt);
      }
    } catch (error) {
      log(`Error getting LLM response for ${purpose}: ${error}`, "agent");
      throw error;
    }
  }
  /**
   * Get response from Claude
   */
  async getResponseFromClaude(prompt) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: this.config.systemPrompt,
      messages: [{ role: "user", content: prompt }]
    });
    return response.content[0].text;
  }
  /**
   * Get response from OpenAI
   */
  async getResponseFromOpenAI(prompt) {
    if (!this.openaiClient) {
      throw new Error("OpenAI client not initialized");
    }
    const response = await this.openaiClient.chat.completions.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      messages: [
        { role: "system", content: this.config.systemPrompt },
        { role: "user", content: prompt }
      ]
    });
    return response.choices[0].message.content || "";
  }
  /**
   * Generate the final response summarizing all task results
   */
  generateFinalResponse() {
    const completedTasks = this.tasks.filter((t) => t.status === "completed");
    const failedTasks = this.tasks.filter((t) => t.status === "failed");
    let response = `# BabyAGI Task Execution Summary

`;
    response += `Total tasks: ${this.tasks.length}
`;
    response += `Completed: ${completedTasks.length}
`;
    response += `Failed: ${failedTasks.length}

`;
    response += `## Results

`;
    completedTasks.filter((t) => t.id !== 1).forEach((task) => {
      response += `### ${task.name}
`;
      response += `${task.result || "No result"}

`;
    });
    if (failedTasks.length > 0) {
      response += `## Errors

`;
      failedTasks.forEach((task) => {
        response += `### ${task.name}
`;
        response += `Error: ${task.error || "Unknown error"}

`;
      });
    }
    return response;
  }
  /**
   * Get the tool call history
   */
  getToolCallHistory() {
    const toolCalls = [];
    this.tasks.forEach((task) => {
      if (task.status === "completed" && task.toolName && task.toolInput) {
        toolCalls.push({
          name: task.toolName,
          input: task.toolInput,
          output: task.result
        });
      }
    });
    return toolCalls;
  }
  /**
   * Get available tools
   */
  getAvailableTools() {
    return this.availableTools;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.tools) {
      this.availableTools = config.tools;
    }
  }
  /**
   * Get supported execution modes
   */
  getSupportedExecutionModes() {
    return ["synchronous" /* SYNCHRONOUS */, "asynchronous" /* ASYNCHRONOUS */];
  }
  /**
   * Check if protocol supports a specific capability
   */
  supportsCapability(capability) {
    return this.config.capabilities.includes(capability);
  }
  /**
   * Get current protocol configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    this.tasks = [];
    this.taskIdCounter = 1;
    this.taskHistory = [];
    this.initialized = false;
    return Promise.resolve();
  }
};

// server/services/agent/protocols/KUSHAIProtocol.ts
import Anthropic10 from "@anthropic-ai/sdk";
import OpenAI2 from "openai";
var DEFAULT_MODEL8 = "claude-3-7-sonnet-20250219";
var KUSHAIProtocol = class {
  config = {
    systemPrompt: `You are KUSH AI, an expert content marketing agent specializing in creating high-quality, SEO-optimized content for blogs, social media, and marketing campaigns. 
    
You excel at:
1. Analyzing target audiences to create personalized content
2. Crafting compelling headlines and hooks
3. Creating content strategies aligned with business goals
4. Optimizing content for search engines
5. Maintaining consistent brand voice
6. Creating conversion-focused calls to action`,
    tools: [],
    modelName: DEFAULT_MODEL8,
    temperature: 0.7,
    maxTokens: 2048,
    capabilities: [
      "single_shot" /* SINGLE_SHOT */,
      "tool_use" /* TOOL_USE */,
      "role_playing" /* ROLE_PLAYING */
    ]
  };
  anthropicClient = null;
  openaiClient = null;
  availableTools = [];
  initialized = false;
  // Content strategy properties
  contentStrategy = null;
  contentOutline = null;
  /**
   * Get metadata about this protocol
   */
  getMetadata() {
    return {
      name: "KUSH AI",
      version: "1.0.0",
      description: "Blog writer & content marketer agent",
      capabilities: [
        "single_shot" /* SINGLE_SHOT */,
        "tool_use" /* TOOL_USE */,
        "role_playing" /* ROLE_PLAYING */
      ],
      requiresAuthentication: true,
      supportedModels: [
        "claude-3-7-sonnet-20250219",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "gpt-4o",
        "gpt-4-turbo",
        "gpt-4"
      ]
    };
  }
  /**
   * Initialize the protocol with configuration
   */
  async init(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (this.config.modelName?.includes("claude")) {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY environment variable is required for Claude models");
      }
      this.anthropicClient = new Anthropic10({
        apiKey: process.env.ANTHROPIC_API_KEY
      });
    } else if (this.config.modelName?.includes("gpt")) {
      if (!process.env.OPENAI_API_KEY) {
        throw new Error("OPENAI_API_KEY environment variable is required for OpenAI models");
      }
      this.openaiClient = new OpenAI2({
        apiKey: process.env.OPENAI_API_KEY
      });
    }
    this.availableTools = this.config.tools || [];
    this.contentStrategy = null;
    this.contentOutline = null;
    this.initialized = true;
  }
  /**
   * Execute a task using this protocol
   */
  async execute(options2) {
    if (!this.initialized) {
      throw new Error("Protocol not initialized. Call init() first.");
    }
    const startTime2 = Date.now();
    try {
      if (options2.callbacks?.onStart) {
        options2.callbacks.onStart();
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Content Strategy",
          description: "Developing content strategy",
          status: "started"
        });
      }
      this.contentStrategy = await this.createContentStrategy(options2.task, options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Content Strategy",
          description: "Content strategy developed",
          output: this.contentStrategy,
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Content Outline",
          description: "Creating content outline",
          status: "started"
        });
      }
      this.contentOutline = await this.createContentOutline(this.contentStrategy, options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Content Outline",
          description: "Content outline created",
          output: this.contentOutline,
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Content Creation",
          description: "Writing content based on outline",
          status: "started"
        });
      }
      const content2 = await this.generateContent(this.contentStrategy, this.contentOutline, options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Content Creation",
          description: "Content created successfully",
          status: "completed"
        });
      }
      const toolResults = await this.useContentTools(content2, options2);
      const agentResponse = {
        response: {
          content: content2,
          toolCalls: toolResults
        },
        executionTime: Date.now() - startTime2,
        protocol: "kushai",
        metadata: {
          contentStrategy: this.contentStrategy,
          contentOutline: this.contentOutline
        }
      };
      if (options2.callbacks?.onComplete) {
        options2.callbacks.onComplete(agentResponse);
      }
      return agentResponse;
    } catch (error) {
      log(`KUSH AI Protocol execution error: ${error}`, "agent");
      if (options2.callbacks?.onError) {
        options2.callbacks.onError(error);
      }
      throw error;
    }
  }
  /**
   * Create content strategy from task description
   */
  async createContentStrategy(task, options2) {
    const strategyPrompt = `As KUSH AI, analyze the following content request and develop a comprehensive content strategy:

Content Request: ${task}

Create a content strategy that includes:
1. Target audience (demographics, interests, pain points)
2. Brand voice and tone
3. Key messages to communicate
4. Primary and secondary keywords for SEO
5. Call to action
6. Recommended content format
7. Ideal content length

Respond with a JSON object in this format:
{
  "targetAudience": "detailed description of target audience",
  "brandVoice": "description of brand voice and tone",
  "keyMessages": ["message 1", "message 2", "message 3"],
  "keywords": ["primary keyword", "secondary keyword 1", "secondary keyword 2"],
  "cta": "specific call to action",
  "format": "one of: blog_post, social_media, email_campaign, product_description, landing_page, newsletter",
  "length": "short, medium, or long"
}`;
    const strategyResponse = await this.getResponseFromLLM(strategyPrompt);
    try {
      const jsonMatch = strategyResponse.match(/{[\s\S]*?}/);
      if (jsonMatch) {
        const strategy = JSON.parse(jsonMatch[0]);
        if (!strategy.targetAudience || !strategy.brandVoice || !Array.isArray(strategy.keyMessages) || !Array.isArray(strategy.keywords) || !strategy.cta || !strategy.format || !strategy.length) {
          throw new Error("Invalid content strategy format");
        }
        return strategy;
      }
      throw new Error("Could not parse content strategy JSON");
    } catch (error) {
      log(`Error creating content strategy: ${error}`, "agent");
      return {
        targetAudience: "General audience interested in the topic",
        brandVoice: "Professional, informative, and friendly",
        keyMessages: ["Provide valuable information on the topic", "Establish expertise in the field"],
        keywords: [task.split(" ").slice(0, 2).join(" ")],
        cta: "Learn more about the topic",
        format: "blog_post" /* BLOG_POST */,
        length: "medium"
      };
    }
  }
  /**
   * Create content outline based on strategy
   */
  async createContentOutline(strategy, options2) {
    const outlinePrompt = `As KUSH AI, create a detailed content outline based on the following content strategy:

Content Strategy:
- Target Audience: ${strategy.targetAudience}
- Brand Voice: ${strategy.brandVoice}
- Key Messages: ${strategy.keyMessages.join(", ")}
- Keywords: ${strategy.keywords.join(", ")}
- Call to Action: ${strategy.cta}
- Format: ${strategy.format}
- Length: ${strategy.length}

Create a comprehensive outline that includes:
1. An attention-grabbing title incorporating primary keywords
2. A compelling hook/introduction
3. Main content sections with headings and key points
4. A conclusion that reinforces key messages and includes the call to action

Respond with a JSON object in this format:
{
  "title": "Attention-grabbing title",
  "hook": "Compelling introduction paragraph",
  "sections": [
    {
      "heading": "Section heading 1",
      "keyPoints": ["key point 1", "key point 2", "key point 3"]
    },
    {
      "heading": "Section heading 2",
      "keyPoints": ["key point 1", "key point 2", "key point 3"]
    }
  ],
  "conclusion": "Conclusion paragraph with call to action"
}`;
    const outlineResponse = await this.getResponseFromLLM(outlinePrompt);
    try {
      const jsonMatch = outlineResponse.match(/{[\s\S]*?}/);
      if (jsonMatch) {
        const outline = JSON.parse(jsonMatch[0]);
        if (!outline.title || !outline.hook || !Array.isArray(outline.sections) || !outline.conclusion) {
          throw new Error("Invalid content outline format");
        }
        for (const section of outline.sections) {
          if (!section.heading || !Array.isArray(section.keyPoints)) {
            throw new Error("Invalid section format in content outline");
          }
        }
        return outline;
      }
      throw new Error("Could not parse content outline JSON");
    } catch (error) {
      log(`Error creating content outline: ${error}`, "agent");
      return {
        title: `Guide to ${strategy.keywords[0] || "the topic"}`,
        hook: "An engaging introduction to the topic.",
        sections: [
          {
            heading: "Introduction to the Topic",
            keyPoints: ["What the topic is about", "Why it matters", "Who should care"]
          },
          {
            heading: "Key Aspects to Consider",
            keyPoints: ["First important aspect", "Second important aspect", "Third important aspect"]
          },
          {
            heading: "Best Practices",
            keyPoints: ["Best practice 1", "Best practice 2", "Best practice 3"]
          }
        ],
        conclusion: `Recap of the key points covered and a reminder to ${strategy.cta}.`
      };
    }
  }
  /**
   * Generate content based on strategy and outline
   */
  async generateContent(strategy, outline, options2) {
    const contentPrompt = `As KUSH AI, generate complete ${strategy.format} content based on the following strategy and outline:

Content Strategy:
- Target Audience: ${strategy.targetAudience}
- Brand Voice: ${strategy.brandVoice}
- Key Messages: ${strategy.keyMessages.join(", ")}
- Keywords: ${strategy.keywords.join(", ")}
- Call to Action: ${strategy.cta}
- Format: ${strategy.format}
- Length: ${strategy.length}

Content Outline:
- Title: ${outline.title}
- Hook: ${outline.hook}
- Sections:
${outline.sections.map((section) => `  - ${section.heading}
${section.keyPoints.map((point) => `    * ${point}`).join("\n")}`).join("\n")}
- Conclusion: ${outline.conclusion}

Guidelines for content creation:
1. Naturally incorporate primary and secondary keywords throughout the content
2. Maintain the specified brand voice and tone
3. Address the target audience's needs and pain points
4. Include statistics, examples, or case studies where appropriate
5. Ensure all key messages are effectively communicated
6. End with the specified call to action
7. Format the content appropriately for ${strategy.format}
8. Ensure the length is appropriate (${strategy.length})

Generate the complete content now:`;
    return await this.getResponseFromLLM(contentPrompt);
  }
  /**
   * Use content tools (e.g., SEO analysis, image suggestions)
   */
  async useContentTools(content2, options2) {
    const tools2 = options2.tools || this.availableTools;
    if (tools2.length === 0) {
      return void 0;
    }
    const toolResults = [];
    const seoTool = tools2.find((tool) => tool.name.includes("seo") || tool.name.includes("keyword"));
    if (seoTool && this.contentStrategy) {
      try {
        const seoParams = {
          content: content2,
          keywords: this.contentStrategy.keywords,
          title: this.contentOutline?.title || "",
          url: options2.context?.url || ""
        };
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName: seoTool.name,
            input: seoParams,
            output: void 0,
            error: void 0
          });
        }
        const seoResult = await seoTool.execute(seoParams);
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName: seoTool.name,
            input: seoParams,
            output: seoResult,
            error: void 0
          });
        }
        toolResults.push({
          name: seoTool.name,
          input: seoParams,
          output: seoResult
        });
      } catch (error) {
        log(`SEO tool execution error: ${error}`, "agent");
      }
    }
    const imageTool = tools2.find((tool) => tool.name.includes("image") || tool.name.includes("media"));
    if (imageTool && this.contentStrategy) {
      try {
        const imageParams = {
          topic: this.contentOutline?.title || "",
          keywords: this.contentStrategy.keywords,
          style: this.contentStrategy.brandVoice,
          count: 3
        };
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName: imageTool.name,
            input: imageParams,
            output: void 0,
            error: void 0
          });
        }
        const imageResult = await imageTool.execute(imageParams);
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName: imageTool.name,
            input: imageParams,
            output: imageResult,
            error: void 0
          });
        }
        toolResults.push({
          name: imageTool.name,
          input: imageParams,
          output: imageResult
        });
      } catch (error) {
        log(`Image tool execution error: ${error}`, "agent");
      }
    }
    return toolResults.length > 0 ? toolResults : void 0;
  }
  /**
   * Get response from the appropriate LLM based on model name
   */
  async getResponseFromLLM(prompt) {
    try {
      if (this.config.modelName?.includes("claude")) {
        return await this.getResponseFromClaude(prompt);
      } else if (this.config.modelName?.includes("gpt")) {
        return await this.getResponseFromOpenAI(prompt);
      } else {
        return await this.getResponseFromClaude(prompt);
      }
    } catch (error) {
      log(`Error getting LLM response: ${error}`, "agent");
      throw error;
    }
  }
  /**
   * Get response from Claude
   */
  async getResponseFromClaude(prompt) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: this.config.systemPrompt,
      messages: [{ role: "user", content: prompt }]
    });
    return response.content[0].text;
  }
  /**
   * Get response from OpenAI
   */
  async getResponseFromOpenAI(prompt) {
    if (!this.openaiClient) {
      throw new Error("OpenAI client not initialized");
    }
    const response = await this.openaiClient.chat.completions.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      messages: [
        { role: "system", content: this.config.systemPrompt },
        { role: "user", content: prompt }
      ]
    });
    return response.choices[0].message.content || "";
  }
  /**
   * Get available tools
   */
  getAvailableTools() {
    return this.availableTools;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.tools) {
      this.availableTools = config.tools;
    }
  }
  /**
   * Get supported execution modes
   */
  getSupportedExecutionModes() {
    return ["synchronous" /* SYNCHRONOUS */];
  }
  /**
   * Check if protocol supports a specific capability
   */
  supportsCapability(capability) {
    return this.config.capabilities.includes(capability);
  }
  /**
   * Get current protocol configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    this.contentStrategy = null;
    this.contentOutline = null;
    this.initialized = false;
    return Promise.resolve();
  }
};

// server/services/agent/protocols/InstagramAgentProtocol.ts
import Anthropic11 from "@anthropic-ai/sdk";
import OpenAI3 from "openai";
var DEFAULT_MODEL9 = "claude-3-7-sonnet-20250219";
var InstagramAgentProtocol = class {
  config = {
    systemPrompt: `You are an Instagram AI Agent, specialized in creating, optimizing, and scheduling Instagram content. 
    
You excel at:
1. Crafting engaging Instagram captions that drive engagement
2. Selecting optimal hashtags for maximum reach
3. Creating visual content descriptions for posts, stories, reels, and carousels
4. Analyzing audience demographics and preferences
5. Planning optimal posting schedules based on engagement data
6. Creating Instagram content strategies aligned with business goals`,
    tools: [],
    modelName: DEFAULT_MODEL9,
    temperature: 0.7,
    maxTokens: 1024,
    capabilities: [
      "single_shot" /* SINGLE_SHOT */,
      "tool_use" /* TOOL_USE */
    ]
  };
  anthropicClient = null;
  openaiClient = null;
  availableTools = [];
  initialized = false;
  instagramContent = null;
  /**
   * Get metadata about this protocol
   */
  getMetadata() {
    return {
      name: "Instagram AI Agent",
      version: "1.0.0",
      description: "Instagram media posting automation",
      capabilities: [
        "single_shot" /* SINGLE_SHOT */,
        "tool_use" /* TOOL_USE */
      ],
      requiresAuthentication: true,
      supportedModels: [
        "claude-3-7-sonnet-20250219",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "gpt-4o",
        "gpt-4-turbo",
        "gpt-4"
      ]
    };
  }
  /**
   * Initialize the protocol with configuration
   */
  async init(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (this.config.modelName?.includes("claude")) {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY environment variable is required for Claude models");
      }
      this.anthropicClient = new Anthropic11({
        apiKey: process.env.ANTHROPIC_API_KEY
      });
    } else if (this.config.modelName?.includes("gpt")) {
      if (!process.env.OPENAI_API_KEY) {
        throw new Error("OPENAI_API_KEY environment variable is required for OpenAI models");
      }
      this.openaiClient = new OpenAI3({
        apiKey: process.env.OPENAI_API_KEY
      });
    }
    this.availableTools = this.config.tools || [];
    this.instagramContent = null;
    this.initialized = true;
  }
  /**
   * Execute a task using this protocol
   */
  async execute(options2) {
    if (!this.initialized) {
      throw new Error("Protocol not initialized. Call init() first.");
    }
    const startTime2 = Date.now();
    try {
      if (options2.callbacks?.onStart) {
        options2.callbacks.onStart();
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Instagram Content Analysis",
          description: "Analyzing request and determining optimal content type",
          status: "started"
        });
      }
      const contentType = await this.determineContentType(options2.task, options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Instagram Content Analysis",
          description: `Determined optimal content type: ${contentType}`,
          output: { contentType },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Caption & Hashtag Generation",
          description: "Creating engaging caption and relevant hashtags",
          status: "started"
        });
      }
      const content2 = await this.generateContent(options2.task, contentType, options2);
      this.instagramContent = content2;
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Caption & Hashtag Generation",
          description: "Created engaging caption and hashtags",
          output: {
            caption: content2.caption,
            hashtags: content2.hashtags
          },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Media Description",
          description: "Creating visual media descriptions",
          status: "started"
        });
      }
      const mediaDescriptions = await this.generateMediaDescriptions(content2, options2);
      content2.mediaDescriptions = mediaDescriptions;
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Media Description",
          description: "Created visual media descriptions",
          output: { mediaDescriptions },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Posting Schedule",
          description: "Determining optimal posting schedule",
          status: "started"
        });
      }
      const postingTime = await this.determinePostingSchedule(content2, options2);
      content2.postTime = postingTime;
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Posting Schedule",
          description: "Determined optimal posting time",
          output: { postingTime },
          status: "completed"
        });
      }
      const toolResults = await this.useInstagramTools(content2, options2);
      const finalResponse = this.formatInstagramContentResponse(content2);
      const agentResponse = {
        response: {
          content: finalResponse,
          toolCalls: toolResults
        },
        executionTime: Date.now() - startTime2,
        protocol: "instagram",
        metadata: {
          contentType: content2.type,
          hashtags: content2.hashtags,
          scheduledTime: content2.postTime
        }
      };
      if (options2.callbacks?.onComplete) {
        options2.callbacks.onComplete(agentResponse);
      }
      return agentResponse;
    } catch (error) {
      log(`Instagram Agent Protocol execution error: ${error}`, "agent");
      if (options2.callbacks?.onError) {
        options2.callbacks.onError(error);
      }
      throw error;
    }
  }
  /**
   * Determine the appropriate Instagram content type
   */
  async determineContentType(task, options2) {
    if (/reels?|video|videos/i.test(task)) {
      return "reel" /* REEL */;
    } else if (/stor(y|ies)/i.test(task)) {
      return "story" /* STORY */;
    } else if (/carousel|multiple|slides?|images?/i.test(task)) {
      return "carousel" /* CAROUSEL */;
    } else if (/post|feed/i.test(task)) {
      return "post" /* POST */;
    }
    const contentTypePrompt = `As an Instagram AI Agent, analyze the following content request and determine the BEST Instagram content type:

Content Request: ${task}

Based on this request, which Instagram content type would be most effective?
- POST (single image in the feed)
- STORY (ephemeral 24-hour content)
- REEL (short-form video content)
- CAROUSEL (multiple images in one post)

Consider factors like:
- The type of content being described
- The goal of the content (awareness, engagement, etc.)
- Visual storytelling capabilities
- Typical audience engagement patterns

Respond with the best content type as a single word: POST, STORY, REEL, or CAROUSEL.`;
    const contentTypeResponse = await this.getResponseFromLLM(contentTypePrompt);
    if (/carousel/i.test(contentTypeResponse)) {
      return "carousel" /* CAROUSEL */;
    } else if (/reel/i.test(contentTypeResponse)) {
      return "reel" /* REEL */;
    } else if (/story/i.test(contentTypeResponse)) {
      return "story" /* STORY */;
    } else {
      return "post" /* POST */;
    }
  }
  /**
   * Generate Instagram content (caption, hashtags)
   */
  async generateContent(task, contentType, options2) {
    const contentPrompt = `As an Instagram AI Agent, create engaging caption and hashtags for the following Instagram ${contentType}:

Content Request: ${task}

Create:
1. An engaging, persuasive caption (aim for 1-3 sentences for optimal engagement)
2. A set of relevant hashtags (5-10 hashtags, mix of popular and niche)
3. Target audience description

Respond with a JSON object in this format:
{
  "caption": "Your engaging Instagram caption here",
  "hashtags": ["hashtag1", "hashtag2", "hashtag3"],
  "targetAudience": "Description of the target audience"
}`;
    const contentResponse = await this.getResponseFromLLM(contentPrompt);
    try {
      const jsonMatch = contentResponse.match(/{[\s\S]*?}/);
      if (jsonMatch) {
        const parsedContent = JSON.parse(jsonMatch[0]);
        if (!parsedContent.caption || !Array.isArray(parsedContent.hashtags) || !parsedContent.targetAudience) {
          throw new Error("Invalid content format");
        }
        return {
          type: contentType,
          caption: parsedContent.caption,
          hashtags: parsedContent.hashtags,
          mediaDescriptions: [],
          targetAudience: parsedContent.targetAudience
        };
      }
      throw new Error("Could not parse content JSON");
    } catch (error) {
      log(`Error generating Instagram content: ${error}`, "agent");
      const captionMatch = /caption["']?\s*:[\s\S]*?["']([\s\S]*?)["']/i.exec(contentResponse);
      const hashtagMatch = contentResponse.match(/#[a-zA-Z0-9]+/g);
      return {
        type: contentType,
        caption: captionMatch ? captionMatch[1] : `Check out this amazing ${contentType}!`,
        hashtags: hashtagMatch ? hashtagMatch.map((h) => h.substring(1)) : ["instagram", "social", "content"],
        mediaDescriptions: [],
        targetAudience: "Instagram users interested in this content"
      };
    }
  }
  /**
   * Generate media descriptions for the Instagram content
   */
  async generateMediaDescriptions(content2, options2) {
    let mediaCount = 1;
    if (content2.type === "carousel" /* CAROUSEL */) {
      mediaCount = 3;
    }
    const mediaPrompt = `As an Instagram AI Agent, create detailed visual descriptions for an Instagram ${content2.type} with the following caption:

Caption: ${content2.caption}
Target Audience: ${content2.targetAudience}

Create ${mediaCount} detailed visual description${mediaCount > 1 ? "s" : ""} for the media that would accompany this Instagram ${content2.type}. 
${content2.type === "carousel" /* CAROUSEL */ ? "Each carousel slide should build upon the previous one to tell a cohesive visual story." : ""}
${content2.type === "reel" /* REEL */ ? "Describe a short video sequence with key visual elements and transitions." : ""}

Each description should include:
1. Main visual elements and composition
2. Color scheme and mood
3. Text overlay (if any)
4. Props or setting

Respond with a JSON array of descriptions:
[
  "Detailed description of image/video 1",
  ${mediaCount > 1 ? '"Detailed description of image/video 2",' : ""}
  ${mediaCount > 2 ? '"Detailed description of image/video 3"' : ""}
]`;
    const mediaResponse = await this.getResponseFromLLM(mediaPrompt);
    try {
      const jsonMatch = mediaResponse.match(/\[[\s\S]*?\]/);
      if (jsonMatch) {
        const parsedMedia = JSON.parse(jsonMatch[0]);
        if (!Array.isArray(parsedMedia)) {
          throw new Error("Invalid media descriptions format");
        }
        return parsedMedia;
      }
      throw new Error("Could not parse media descriptions JSON");
    } catch (error) {
      log(`Error generating media descriptions: ${error}`, "agent");
      const defaultDescriptions = [];
      for (let i = 0; i < mediaCount; i++) {
        defaultDescriptions.push(`Visual ${i + 1}: Engaging image related to the caption, with appealing composition and on-brand colors.`);
      }
      return defaultDescriptions;
    }
  }
  /**
   * Determine optimal posting schedule
   */
  async determinePostingSchedule(content2, options2) {
    const task = options2.task;
    const timeRegex = /post(?:ed)?\s+(?:at|on)\s+([a-zA-Z0-9\s,:]+)/i;
    const timeMatch = timeRegex.exec(task);
    if (timeMatch) {
      return timeMatch[1];
    }
    const schedulePrompt = `As an Instagram AI Agent, determine the optimal posting time for an Instagram ${content2.type} targeted at the following audience:

Target Audience: ${content2.targetAudience}

Consider:
1. Typical online behavior of this audience
2. Time zone considerations (default to Eastern Time if not specified)
3. Day of the week that would get maximum engagement
4. Optimal time of day for this content type

Respond with a single specific date and time for posting (e.g., "Monday, May 5th at 6:30 PM ET").`;
    const scheduleResponse = await this.getResponseFromLLM(schedulePrompt);
    const cleanedResponse = scheduleResponse.trim().replace(/^\"|\"$/g, "");
    if (/^[A-Za-z]+day|[0-9]{1,2}:[0-9]{2}|AM|PM/i.test(cleanedResponse)) {
      return cleanedResponse;
    }
    return "Next Monday at 6:00 PM ET";
  }
  /**
   * Use Instagram tools if available
   */
  async useInstagramTools(content2, options2) {
    const tools2 = options2.tools || this.availableTools;
    if (tools2.length === 0) {
      return void 0;
    }
    const toolResults = [];
    const instagramTool = tools2.find(
      (tool) => tool.name.includes("instagram") || tool.name.includes("social") || tool.name.includes("post")
    );
    if (instagramTool) {
      try {
        const instagramParams = {
          contentType: content2.type,
          caption: `${content2.caption}

${content2.hashtags.map((h) => `#${h}`).join(" ")}`,
          mediaDescriptions: content2.mediaDescriptions,
          scheduledTime: content2.postTime
        };
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName: instagramTool.name,
            input: instagramParams,
            output: void 0,
            error: void 0
          });
        }
        const instagramResult = await instagramTool.execute(instagramParams);
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName: instagramTool.name,
            input: instagramParams,
            output: instagramResult,
            error: void 0
          });
        }
        toolResults.push({
          name: instagramTool.name,
          input: instagramParams,
          output: instagramResult
        });
      } catch (error) {
        log(`Instagram tool execution error: ${error}`, "agent");
      }
    }
    return toolResults.length > 0 ? toolResults : void 0;
  }
  /**
   * Format the Instagram content response
   */
  formatInstagramContentResponse(content2) {
    let response = `# Instagram ${content2.type.charAt(0).toUpperCase() + content2.type.slice(1)} Content

`;
    response += `## Caption
${content2.caption}

`;
    response += `## Hashtags
${content2.hashtags.map((h) => `#${h}`).join(" ")}

`;
    response += `## Media Description${content2.mediaDescriptions.length > 1 ? "s" : ""}
`;
    content2.mediaDescriptions.forEach((desc13, idx) => {
      response += `### Media ${idx + 1}
${desc13}

`;
    });
    response += `## Target Audience
${content2.targetAudience}

`;
    if (content2.postTime) {
      response += `## Recommended Posting Time
${content2.postTime}

`;
    }
    response += `## Best Practices
`;
    response += `1. Review the caption for tone and alignment with brand voice
`;
    response += `2. Ensure the visual content matches the description provided
`;
    response += `3. Consider adding location tags for increased visibility
`;
    response += `4. Respond to comments within 1 hour of posting for maximum engagement
`;
    return response;
  }
  /**
   * Get response from the appropriate LLM based on model name
   */
  async getResponseFromLLM(prompt) {
    try {
      if (this.config.modelName?.includes("claude")) {
        return await this.getResponseFromClaude(prompt);
      } else if (this.config.modelName?.includes("gpt")) {
        return await this.getResponseFromOpenAI(prompt);
      } else {
        return await this.getResponseFromClaude(prompt);
      }
    } catch (error) {
      log(`Error getting LLM response: ${error}`, "agent");
      throw error;
    }
  }
  /**
   * Get response from Claude
   */
  async getResponseFromClaude(prompt) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: this.config.systemPrompt,
      messages: [{ role: "user", content: prompt }]
    });
    return response.content[0].text;
  }
  /**
   * Get response from OpenAI
   */
  async getResponseFromOpenAI(prompt) {
    if (!this.openaiClient) {
      throw new Error("OpenAI client not initialized");
    }
    const response = await this.openaiClient.chat.completions.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      messages: [
        { role: "system", content: this.config.systemPrompt },
        { role: "user", content: prompt }
      ]
    });
    return response.choices[0].message.content || "";
  }
  /**
   * Get available tools
   */
  getAvailableTools() {
    return this.availableTools;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.tools) {
      this.availableTools = config.tools;
    }
  }
  /**
   * Get supported execution modes
   */
  getSupportedExecutionModes() {
    return ["synchronous" /* SYNCHRONOUS */];
  }
  /**
   * Check if protocol supports a specific capability
   */
  supportsCapability(capability) {
    return this.config.capabilities.includes(capability);
  }
  /**
   * Get current protocol configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    this.instagramContent = null;
    this.initialized = false;
    return Promise.resolve();
  }
};

// server/services/agent/protocols/RionaAIProtocol.ts
import Anthropic12 from "@anthropic-ai/sdk";
import OpenAI4 from "openai";
var DEFAULT_MODEL10 = "claude-3-7-sonnet-20250219";
var RionaAIProtocol = class {
  config = {
    systemPrompt: `You are Riona AI, a specialized agent for monitoring Twitter and GitHub activities and generating appropriate responses. 
    
You excel at:
1. Monitoring Twitter for mentions, keywords, and relevant conversations
2. Tracking GitHub activities including issues, PRs, and discussions
3. Analyzing social content for sentiment and intent
4. Crafting contextually appropriate responses in the right tone
5. Prioritizing interactions based on urgency and importance
6. Maintaining a consistent brand voice across platforms`,
    tools: [],
    modelName: DEFAULT_MODEL10,
    temperature: 0.7,
    maxTokens: 1024,
    capabilities: [
      "multi_step" /* MULTI_STEP */,
      "tool_use" /* TOOL_USE */,
      "long_term_memory" /* LONG_TERM_MEMORY */
    ]
  };
  anthropicClient = null;
  openaiClient = null;
  availableTools = [];
  initialized = false;
  // Monitoring state
  monitoringParams = null;
  responseParams = null;
  monitoredItems = [];
  /**
   * Get metadata about this protocol
   */
  getMetadata() {
    return {
      name: "Riona AI Agent",
      version: "1.0.0",
      description: "Twitter + GitHub monitoring and reply agent",
      capabilities: [
        "multi_step" /* MULTI_STEP */,
        "tool_use" /* TOOL_USE */,
        "long_term_memory" /* LONG_TERM_MEMORY */
      ],
      requiresAuthentication: true,
      supportedModels: [
        "claude-3-7-sonnet-20250219",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "gpt-4o",
        "gpt-4-turbo",
        "gpt-4"
      ]
    };
  }
  /**
   * Initialize the protocol with configuration
   */
  async init(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (this.config.modelName?.includes("claude")) {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY environment variable is required for Claude models");
      }
      this.anthropicClient = new Anthropic12({
        apiKey: process.env.ANTHROPIC_API_KEY
      });
    } else if (this.config.modelName?.includes("gpt")) {
      if (!process.env.OPENAI_API_KEY) {
        throw new Error("OPENAI_API_KEY environment variable is required for OpenAI models");
      }
      this.openaiClient = new OpenAI4({
        apiKey: process.env.OPENAI_API_KEY
      });
    }
    this.availableTools = this.config.tools || [];
    this.monitoringParams = null;
    this.responseParams = null;
    this.monitoredItems = [];
    this.initialized = true;
  }
  /**
   * Execute a task using this protocol
   */
  async execute(options2) {
    if (!this.initialized) {
      throw new Error("Protocol not initialized. Call init() first.");
    }
    const startTime2 = Date.now();
    try {
      if (options2.callbacks?.onStart) {
        options2.callbacks.onStart();
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Monitoring Configuration",
          description: "Setting up monitoring parameters",
          status: "started"
        });
      }
      this.monitoringParams = await this.setupMonitoringParams(options2.task, options2);
      this.responseParams = await this.setupResponseParams(options2.task, options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Monitoring Configuration",
          description: "Monitoring parameters configured",
          output: {
            monitoring: this.monitoringParams,
            response: this.responseParams
          },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Platform Monitoring",
          description: "Fetching data from platforms",
          status: "started"
        });
      }
      await this.monitorPlatforms(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Platform Monitoring",
          description: "Platform data fetched successfully",
          output: {
            itemsCount: this.monitoredItems.length
          },
          status: "completed"
        });
      }
      if (this.monitoredItems.length > 0) {
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: "Response Generation",
            description: "Generating appropriate responses",
            status: "started"
          });
        }
        await this.generateResponses(options2);
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: "Response Generation",
            description: "Responses generated successfully",
            status: "completed"
          });
        }
        if (this.responseParams?.autoRespond) {
          if (options2.callbacks?.onStep) {
            options2.callbacks.onStep({
              name: "Auto-Responding",
              description: "Sending auto-approved responses",
              status: "started"
            });
          }
          await this.sendResponses(options2);
          if (options2.callbacks?.onStep) {
            options2.callbacks.onStep({
              name: "Auto-Responding",
              description: "Auto-responses sent successfully",
              status: "completed"
            });
          }
        }
      }
      const finalResponse = this.formatMonitoringReport();
      const agentResponse = {
        response: {
          content: finalResponse,
          toolCalls: this.getToolCallsHistory()
        },
        executionTime: Date.now() - startTime2,
        protocol: "riona",
        metadata: {
          monitoring: this.monitoringParams,
          response: this.responseParams,
          itemsCount: this.monitoredItems.length
        }
      };
      if (options2.callbacks?.onComplete) {
        options2.callbacks.onComplete(agentResponse);
      }
      return agentResponse;
    } catch (error) {
      log(`Riona AI Protocol execution error: ${error}`, "agent");
      if (options2.callbacks?.onError) {
        options2.callbacks.onError(error);
      }
      throw error;
    }
  }
  /**
   * Setup monitoring parameters
   */
  async setupMonitoringParams(task, options2) {
    const setupPrompt = `As Riona AI, analyze the following monitoring request and set up appropriate monitoring parameters:

Monitoring Request: ${task}

Determine the following monitoring parameters:
1. Which platform(s) to monitor (Twitter, GitHub, or both)
2. Keywords to track
3. Specific accounts to monitor
4. For GitHub monitoring, specific repositories (if applicable)
5. Whether to focus only on direct mentions or broader conversations
6. Check frequency (high = every 5 minutes, medium = hourly, low = daily)

Respond with a JSON object in this format:
{
  "platform": "twitter", "github", or "both",
  "keywords": ["keyword1", "keyword2", ...],
  "accounts": ["account1", "account2", ...],
  "repositories": ["owner/repo1", "owner/repo2", ...],
  "mentionsOnly": true or false,
  "checkFrequency": "high", "medium", or "low"
}`;
    const setupResponse = await this.getResponseFromLLM(setupPrompt);
    try {
      const jsonMatch = setupResponse.match(/{[\s\S]*?}/);
      if (jsonMatch) {
        const params2 = JSON.parse(jsonMatch[0]);
        if (!params2.platform || !Array.isArray(params2.keywords) || !Array.isArray(params2.accounts)) {
          throw new Error("Invalid monitoring parameters format");
        }
        return params2;
      }
      throw new Error("Could not parse monitoring parameters JSON");
    } catch (error) {
      log(`Error setting up monitoring parameters: ${error}`, "agent");
      let platform = "both" /* BOTH */;
      if (/twitter|tweet/i.test(task) && !/github/i.test(task)) {
        platform = "twitter" /* TWITTER */;
      } else if (/github/i.test(task) && !/twitter|tweet/i.test(task)) {
        platform = "github" /* GITHUB */;
      }
      const keywords = task.match(/\b\w{4,}\b/g) || ["product", "service"];
      return {
        platform,
        keywords: keywords.slice(0, 5),
        accounts: ["company"],
        repositories: platform !== "twitter" /* TWITTER */ ? ["owner/repo"] : void 0,
        mentionsOnly: true,
        checkFrequency: "medium"
      };
    }
  }
  /**
   * Setup response parameters
   */
  async setupResponseParams(task, options2) {
    const setupPrompt = `As Riona AI, analyze the following monitoring request and set up appropriate response parameters:

Monitoring Request: ${task}

Determine the following response parameters:
1. A template for responses (if applicable)
2. The appropriate tone for responses
3. Whether to auto-respond or just track mentions
4. Maximum responses per day (if applicable)
5. Whether responses require human approval before sending

Respond with a JSON object in this format:
{
  "responseTemplate": "optional template with {placeholders}",
  "tone": "description of the tone (professional, friendly, etc.)",
  "autoRespond": true or false,
  "maxResponsesPerDay": number or null,
  "requireApproval": true or false
}`;
    const setupResponse = await this.getResponseFromLLM(setupPrompt);
    try {
      const jsonMatch = setupResponse.match(/{[\s\S]*?}/);
      if (jsonMatch) {
        const params2 = JSON.parse(jsonMatch[0]);
        if (typeof params2.tone !== "string" || typeof params2.autoRespond !== "boolean" || typeof params2.requireApproval !== "boolean") {
          throw new Error("Invalid response parameters format");
        }
        return params2;
      }
      throw new Error("Could not parse response parameters JSON");
    } catch (error) {
      log(`Error setting up response parameters: ${error}`, "agent");
      return {
        responseTemplate: "Thanks for reaching out about {topic}. We appreciate your {sentiment} and will look into this!",
        tone: "professional and friendly",
        autoRespond: false,
        maxResponsesPerDay: 10,
        requireApproval: true
      };
    }
  }
  /**
   * Monitor platforms based on parameters
   */
  async monitorPlatforms(options2) {
    if (!this.monitoringParams) {
      throw new Error("Monitoring parameters not set");
    }
    const tools2 = options2.tools || this.availableTools;
    if (this.monitoringParams.platform !== "github" /* GITHUB */) {
      const twitterTool = tools2.find(
        (tool) => tool.name.includes("twitter") || tool.name.includes("tweet") || tool.name.includes("social")
      );
      if (twitterTool) {
        await this.monitorTwitter(twitterTool, options2);
      } else {
        log("No Twitter monitoring tool available", "agent");
        this.monitoredItems.push({
          platform: "twitter",
          id: "tweet123456",
          content: `I'm having trouble with ${this.monitoringParams.keywords[0] || "your product"}. Can anyone help?`,
          author: "user123",
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
    }
    if (this.monitoringParams.platform !== "twitter" /* TWITTER */) {
      const githubTool = tools2.find(
        (tool) => tool.name.includes("github") || tool.name.includes("git") || tool.name.includes("repo")
      );
      if (githubTool) {
        await this.monitorGitHub(githubTool, options2);
      } else {
        log("No GitHub monitoring tool available", "agent");
        this.monitoredItems.push({
          platform: "github",
          id: "issue789",
          content: `Found a bug in the ${this.monitoringParams.repositories?.[0] || "main"} repository related to ${this.monitoringParams.keywords[0] || "functionality"}`,
          author: "developer456",
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
    }
  }
  /**
   * Monitor Twitter using tool
   */
  async monitorTwitter(twitterTool, options2) {
    if (!this.monitoringParams) return;
    try {
      const twitterParams = {
        keywords: this.monitoringParams.keywords,
        accounts: this.monitoringParams.accounts,
        mentionsOnly: this.monitoringParams.mentionsOnly,
        limit: 10
      };
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: twitterTool.name,
          input: twitterParams,
          output: void 0,
          error: void 0
        });
      }
      const twitterResults = await twitterTool.execute(twitterParams);
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: twitterTool.name,
          input: twitterParams,
          output: twitterResults,
          error: void 0
        });
      }
      if (Array.isArray(twitterResults)) {
        twitterResults.forEach((tweet) => {
          this.monitoredItems.push({
            platform: "twitter",
            id: tweet.id,
            content: tweet.text,
            author: tweet.author,
            timestamp: tweet.timestamp
          });
        });
      }
    } catch (error) {
      log(`Twitter monitoring error: ${error}`, "agent");
      throw error;
    }
  }
  /**
   * Monitor GitHub using tool
   */
  async monitorGitHub(githubTool, options2) {
    if (!this.monitoringParams) return;
    try {
      const githubParams = {
        keywords: this.monitoringParams.keywords,
        repositories: this.monitoringParams.repositories || [],
        limit: 10
      };
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: githubTool.name,
          input: githubParams,
          output: void 0,
          error: void 0
        });
      }
      const githubResults = await githubTool.execute(githubParams);
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: githubTool.name,
          input: githubParams,
          output: githubResults,
          error: void 0
        });
      }
      if (Array.isArray(githubResults)) {
        githubResults.forEach((item) => {
          this.monitoredItems.push({
            platform: "github",
            id: item.id,
            content: item.content || item.title,
            author: item.author,
            timestamp: item.timestamp
          });
        });
      }
    } catch (error) {
      log(`GitHub monitoring error: ${error}`, "agent");
      throw error;
    }
  }
  /**
   * Generate responses for monitored items
   */
  async generateResponses(options2) {
    if (!this.responseParams) return;
    for (const item of this.monitoredItems) {
      if (item.responseStatus) continue;
      const responsePrompt = `As Riona AI, craft an appropriate response to the following ${item.platform} content:

Content: "${item.content}"
Author: ${item.author}
Platform: ${item.platform}

Response guidelines:
- Tone: ${this.responseParams.tone}
- Template (if applicable): ${this.responseParams.responseTemplate || "No template specified"}
- Be helpful and address the specific content
- Maintain brand voice
- Keep responses concise (1-3 sentences for Twitter, 2-4 sentences for GitHub)

Generate a single response that would be appropriate to post as a reply:`;
      const generatedResponse = await this.getResponseFromLLM(responsePrompt);
      const cleanedResponse = generatedResponse.replace(/^["']|["']$/g, "").trim();
      item.response = cleanedResponse;
      item.responseStatus = this.responseParams.requireApproval ? "pending" : "approved";
    }
  }
  /**
   * Send approved responses
   */
  async sendResponses(options2) {
    if (!this.responseParams || !this.responseParams.autoRespond) return;
    const tools2 = options2.tools || this.availableTools;
    const approvedItems = this.monitoredItems.filter(
      (item) => item.responseStatus === "approved" && item.response
    );
    const itemsToRespond = this.responseParams.maxResponsesPerDay ? approvedItems.slice(0, this.responseParams.maxResponsesPerDay) : approvedItems;
    for (const item of itemsToRespond) {
      if (item.platform === "twitter") {
        await this.sendTwitterResponse(item, tools2, options2);
      } else if (item.platform === "github") {
        await this.sendGitHubResponse(item, tools2, options2);
      }
    }
  }
  /**
   * Send a Twitter response
   */
  async sendTwitterResponse(item, tools2, options2) {
    const twitterTool = tools2.find(
      (tool) => tool.name.includes("twitter") || tool.name.includes("tweet") || tool.name.includes("social_reply")
    );
    if (!twitterTool) {
      log("No Twitter reply tool available", "agent");
      item.responseStatus = "sent";
      return;
    }
    try {
      const twitterParams = {
        reply_to_id: item.id,
        content: item.response
      };
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: twitterTool.name,
          input: twitterParams,
          output: void 0,
          error: void 0
        });
      }
      const twitterResult = await twitterTool.execute(twitterParams);
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: twitterTool.name,
          input: twitterParams,
          output: twitterResult,
          error: void 0
        });
      }
      item.responseStatus = "sent";
    } catch (error) {
      log(`Twitter reply error: ${error}`, "agent");
    }
  }
  /**
   * Send a GitHub response
   */
  async sendGitHubResponse(item, tools2, options2) {
    const githubTool = tools2.find(
      (tool) => tool.name.includes("github") || tool.name.includes("git_comment") || tool.name.includes("repo_reply")
    );
    if (!githubTool) {
      log("No GitHub reply tool available", "agent");
      item.responseStatus = "sent";
      return;
    }
    try {
      const githubParams = {
        item_id: item.id,
        content: item.response
      };
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: githubTool.name,
          input: githubParams,
          output: void 0,
          error: void 0
        });
      }
      const githubResult = await githubTool.execute(githubParams);
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: githubTool.name,
          input: githubParams,
          output: githubResult,
          error: void 0
        });
      }
      item.responseStatus = "sent";
    } catch (error) {
      log(`GitHub reply error: ${error}`, "agent");
    }
  }
  /**
   * Format the monitoring report
   */
  formatMonitoringReport() {
    let report = `# Riona AI Monitoring Report

`;
    report += `## Monitoring Parameters
`;
    if (this.monitoringParams) {
      report += `- Platforms: ${this.monitoringParams.platform}
`;
      report += `- Keywords: ${this.monitoringParams.keywords.join(", ")}
`;
      report += `- Accounts: ${this.monitoringParams.accounts.join(", ")}
`;
      if (this.monitoringParams.repositories) {
        report += `- Repositories: ${this.monitoringParams.repositories.join(", ")}
`;
      }
      report += `- Mentions Only: ${this.monitoringParams.mentionsOnly ? "Yes" : "No"}
`;
      report += `- Check Frequency: ${this.monitoringParams.checkFrequency}

`;
    }
    report += `## Response Parameters
`;
    if (this.responseParams) {
      report += `- Tone: ${this.responseParams.tone}
`;
      report += `- Auto-Respond: ${this.responseParams.autoRespond ? "Yes" : "No"}
`;
      if (this.responseParams.maxResponsesPerDay) {
        report += `- Max Responses Per Day: ${this.responseParams.maxResponsesPerDay}
`;
      }
      report += `- Require Approval: ${this.responseParams.requireApproval ? "Yes" : "No"}

`;
    }
    report += `## Monitored Items
`;
    if (this.monitoredItems.length === 0) {
      report += `No items found matching the monitoring criteria.

`;
    } else {
      this.monitoredItems.forEach((item, idx) => {
        report += `### Item ${idx + 1}: ${item.platform.toUpperCase()} - ${item.author}
`;
        report += `**Content:** ${item.content}
`;
        report += `**Time:** ${item.timestamp}
`;
        if (item.response) {
          report += `**Generated Response:** ${item.response}
`;
          report += `**Status:** ${item.responseStatus}
`;
        }
        report += `
`;
      });
    }
    report += `## Summary
`;
    const itemsByPlatform = {};
    this.monitoredItems.forEach((item) => {
      itemsByPlatform[item.platform] = (itemsByPlatform[item.platform] || 0) + 1;
    });
    Object.entries(itemsByPlatform).forEach(([platform, count2]) => {
      report += `- ${platform.toUpperCase()}: ${count2} items
`;
    });
    const responseCount = this.monitoredItems.filter((item) => item.responseStatus === "sent").length;
    report += `- Responses Sent: ${responseCount}
`;
    const pendingCount = this.monitoredItems.filter((item) => item.responseStatus === "pending").length;
    report += `- Pending Approval: ${pendingCount}
`;
    return report;
  }
  /**
   * Get the tool calls history
   */
  getToolCallsHistory() {
    return void 0;
  }
  /**
   * Get response from the appropriate LLM based on model name
   */
  async getResponseFromLLM(prompt) {
    try {
      if (this.config.modelName?.includes("claude")) {
        return await this.getResponseFromClaude(prompt);
      } else if (this.config.modelName?.includes("gpt")) {
        return await this.getResponseFromOpenAI(prompt);
      } else {
        return await this.getResponseFromClaude(prompt);
      }
    } catch (error) {
      log(`Error getting LLM response: ${error}`, "agent");
      throw error;
    }
  }
  /**
   * Get response from Claude
   */
  async getResponseFromClaude(prompt) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: this.config.systemPrompt,
      messages: [{ role: "user", content: prompt }]
    });
    return response.content[0].text;
  }
  /**
   * Get response from OpenAI
   */
  async getResponseFromOpenAI(prompt) {
    if (!this.openaiClient) {
      throw new Error("OpenAI client not initialized");
    }
    const response = await this.openaiClient.chat.completions.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      messages: [
        { role: "system", content: this.config.systemPrompt },
        { role: "user", content: prompt }
      ]
    });
    return response.choices[0].message.content || "";
  }
  /**
   * Get available tools
   */
  getAvailableTools() {
    return this.availableTools;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.tools) {
      this.availableTools = config.tools;
    }
  }
  /**
   * Get supported execution modes
   */
  getSupportedExecutionModes() {
    return ["synchronous" /* SYNCHRONOUS */, "asynchronous" /* ASYNCHRONOUS */];
  }
  /**
   * Check if protocol supports a specific capability
   */
  supportsCapability(capability) {
    return this.config.capabilities.includes(capability);
  }
  /**
   * Get current protocol configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    this.monitoringParams = null;
    this.responseParams = null;
    this.monitoredItems = [];
    this.initialized = false;
    return Promise.resolve();
  }
};

// server/services/agent/protocols/KyroProtocol.ts
import Anthropic13 from "@anthropic-ai/sdk";
import OpenAI5 from "openai";
var DEFAULT_MODEL11 = "claude-3-7-sonnet-20250219";
var KyroProtocol = class {
  config = {
    systemPrompt: `You are Kyro, a lightweight serverless automation agent. You excel at:
1. Breaking down tasks into serverless-friendly operations
2. Efficient resource utilization in constrained environments
3. Handling asynchronous workflows with minimal state management
4. API integrations and data transformations
5. Self-contained task execution with minimal dependencies
6. Serverless-optimized error handling and retry strategies`,
    tools: [],
    modelName: DEFAULT_MODEL11,
    temperature: 0.7,
    maxTokens: 1024,
    capabilities: [
      "serverless" /* SERVERLESS */,
      "tool_use" /* TOOL_USE */,
      "multi_step" /* MULTI_STEP */
    ]
  };
  anthropicClient = null;
  openaiClient = null;
  availableTools = [];
  initialized = false;
  // Task state
  tasks = [];
  currentTaskIndex = 0;
  /**
   * Get metadata about this protocol
   */
  getMetadata() {
    return {
      name: "Kyro",
      version: "1.0.0",
      description: "Lightweight serverless automation agent",
      capabilities: [
        "serverless" /* SERVERLESS */,
        "tool_use" /* TOOL_USE */,
        "multi_step" /* MULTI_STEP */
      ],
      requiresAuthentication: true,
      supportedModels: [
        "claude-3-7-sonnet-20250219",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "gpt-4o",
        "gpt-4-turbo",
        "gpt-4"
      ]
    };
  }
  /**
   * Initialize the protocol with configuration
   */
  async init(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (this.config.modelName?.includes("claude")) {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY environment variable is required for Claude models");
      }
      this.anthropicClient = new Anthropic13({
        apiKey: process.env.ANTHROPIC_API_KEY
      });
    } else if (this.config.modelName?.includes("gpt")) {
      if (!process.env.OPENAI_API_KEY) {
        throw new Error("OPENAI_API_KEY environment variable is required for OpenAI models");
      }
      this.openaiClient = new OpenAI5({
        apiKey: process.env.OPENAI_API_KEY
      });
    }
    this.availableTools = this.config.tools || [];
    this.tasks = [];
    this.currentTaskIndex = 0;
    this.initialized = true;
  }
  /**
   * Execute a task using this protocol
   */
  async execute(options2) {
    if (!this.initialized) {
      throw new Error("Protocol not initialized. Call init() first.");
    }
    const startTime2 = Date.now();
    try {
      if (options2.callbacks?.onStart) {
        options2.callbacks.onStart();
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Planning",
          description: "Analyzing task and creating execution plan",
          status: "started"
        });
      }
      await this.parseTasks(options2.task, options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Planning",
          description: `Created execution plan with ${this.tasks.length} tasks`,
          status: "completed"
        });
      }
      await this.executeTasks(options2);
      const finalResponse = this.generateExecutionSummary();
      const agentResponse = {
        response: {
          content: finalResponse,
          toolCalls: this.getToolCallsHistory()
        },
        executionTime: Date.now() - startTime2,
        protocol: "kyro",
        metadata: {
          taskCount: this.tasks.length,
          completedTaskCount: this.tasks.filter((t) => t.status === "completed").length,
          failedTaskCount: this.tasks.filter((t) => t.status === "failed").length
        }
      };
      if (options2.callbacks?.onComplete) {
        options2.callbacks.onComplete(agentResponse);
      }
      return agentResponse;
    } catch (error) {
      log(`Kyro Protocol execution error: ${error}`, "agent");
      if (options2.callbacks?.onError) {
        options2.callbacks.onError(error);
      }
      throw error;
    }
  }
  /**
   * Parse the task and create execution plan
   */
  async parseTasks(task, options2) {
    const planningPrompt = `As Kyro, a serverless automation agent, analyze the following task request and break it down into discrete, serverless-friendly tasks:

Task Request: ${task}

Create a plan with sequential tasks that can be executed in a serverless environment. Consider:
1. Breaking the process into small, stateless steps
2. Minimizing resource usage and execution time
3. Utilizing available tools effectively
4. Managing data between tasks efficiently
5. Error handling and recovery strategies

For each task, provide:
- Task type (data_processing, api_integration, workflow_automation, content_generation, notification)
- A descriptive name
- A detailed description of what the task does
- The required inputs

Respond with a JSON array of tasks in the following format:
[
  {
    "id": "task1",
    "type": "task_type",
    "name": "Task Name",
    "description": "Detailed description of what this task does",
    "inputs": {
      "param1": "value1",
      "param2": "value2"
    }
  },
  ...
]`;
    const planningResponse = await this.getResponseFromLLM(planningPrompt);
    try {
      const jsonMatch = planningResponse.match(/\[[\s\S]*?\]/);
      if (jsonMatch) {
        const tasks = JSON.parse(jsonMatch[0]);
        if (Array.isArray(tasks) && tasks.length > 0) {
          this.tasks = tasks.map((task2) => ({
            ...task2,
            status: "pending"
          }));
          return;
        }
      }
      throw new Error("Could not parse tasks from planning response");
    } catch (error) {
      log(`Error parsing tasks: ${error}`, "agent");
      const defaultTaskTypes = [
        "data_processing" /* DATA_PROCESSING */,
        "api_integration" /* API_INTEGRATION */,
        "content_generation" /* CONTENT_GENERATION */
      ];
      const words = task.split(/\s+/);
      const keywords = words.filter((word) => word.length > 5);
      this.tasks = [
        {
          id: "task1",
          type: "data_processing" /* DATA_PROCESSING */,
          name: "Process Input Data",
          description: `Process and validate the input data for ${keywords[0] || "the task"}`,
          inputs: { raw_input: task },
          status: "pending"
        },
        {
          id: "task2",
          type: defaultTaskTypes[1],
          name: "Execute Primary Operation",
          description: `Perform the main operation required for ${keywords[0] || "the task"}`,
          inputs: { processed_data: "from_task1" },
          status: "pending"
        },
        {
          id: "task3",
          type: defaultTaskTypes[2],
          name: "Generate Result",
          description: "Format and prepare the final result",
          inputs: { operation_result: "from_task2" },
          status: "pending"
        }
      ];
    }
  }
  /**
   * Execute the planned tasks
   */
  async executeTasks(options2) {
    for (let i = 0; i < this.tasks.length; i++) {
      this.currentTaskIndex = i;
      const task = this.tasks[i];
      if (task.status !== "pending") continue;
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Task ${i + 1}: ${task.name}`,
          description: task.description,
          status: "started"
        });
      }
      task.status = "in-progress";
      task.startTime = (/* @__PURE__ */ new Date()).toISOString();
      try {
        const result2 = await this.executeTask(task, options2);
        task.status = "completed";
        task.outputs = result2;
        task.endTime = (/* @__PURE__ */ new Date()).toISOString();
        task.executionTime = new Date(task.endTime).getTime() - new Date(task.startTime).getTime();
        this.updateDependentTaskInputs(i, result2);
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: `Task ${i + 1}: ${task.name}`,
            description: task.description,
            output: result2,
            status: "completed"
          });
        }
      } catch (error) {
        task.status = "failed";
        task.error = error.message;
        task.endTime = (/* @__PURE__ */ new Date()).toISOString();
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: `Task ${i + 1}: ${task.name}`,
            description: task.description,
            error: error.message,
            status: "failed"
          });
        }
        log(`Task execution error (continuing): ${error}`, "agent");
      }
    }
  }
  /**
   * Execute a single task
   */
  async executeTask(task, options2) {
    const requiredTool = this.findAppropriateToolForTask(task);
    if (requiredTool) {
      return await this.executeTaskWithTool(task, requiredTool, options2);
    } else {
      return await this.executeTaskWithLLM(task, options2);
    }
  }
  /**
   * Find an appropriate tool for a task
   */
  findAppropriateToolForTask(task) {
    const tools2 = this.availableTools;
    if (tools2.length === 0) {
      return null;
    }
    let matchingTools = [];
    switch (task.type) {
      case "data_processing" /* DATA_PROCESSING */:
        matchingTools = tools2.filter(
          (tool) => tool.name.includes("data") || tool.name.includes("process") || tool.name.includes("transform")
        );
        break;
      case "api_integration" /* API_INTEGRATION */:
        matchingTools = tools2.filter(
          (tool) => tool.name.includes("api") || tool.name.includes("request") || tool.name.includes("http")
        );
        break;
      case "workflow_automation" /* WORKFLOW_AUTOMATION */:
        matchingTools = tools2.filter(
          (tool) => tool.name.includes("workflow") || tool.name.includes("automate") || tool.name.includes("schedule")
        );
        break;
      case "content_generation" /* CONTENT_GENERATION */:
        matchingTools = tools2.filter(
          (tool) => tool.name.includes("content") || tool.name.includes("generate") || tool.name.includes("create")
        );
        break;
      case "notification" /* NOTIFICATION */:
        matchingTools = tools2.filter(
          (tool) => tool.name.includes("notify") || tool.name.includes("alert") || tool.name.includes("email") || tool.name.includes("message")
        );
        break;
    }
    if (matchingTools.length === 0) {
      const taskWords = task.description.toLowerCase().split(/\s+/);
      for (const tool of tools2) {
        const toolWords = tool.name.toLowerCase().split(/[_-]/);
        for (const toolWord of toolWords) {
          if (taskWords.includes(toolWord) && toolWord.length > 3) {
            matchingTools.push(tool);
            break;
          }
        }
      }
    }
    return matchingTools.length > 0 ? matchingTools[0] : null;
  }
  /**
   * Execute a task using a tool
   */
  async executeTaskWithTool(task, tool, options2) {
    const toolInputs = await this.prepareToolInputs(task, tool, options2);
    try {
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: tool.name,
          input: toolInputs,
          output: void 0,
          error: void 0
        });
      }
      const toolResult = await tool.execute(toolInputs);
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: tool.name,
          input: toolInputs,
          output: toolResult,
          error: void 0
        });
      }
      const structuredResult = typeof toolResult === "object" ? toolResult : { result: toolResult };
      return structuredResult;
    } catch (error) {
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: tool.name,
          input: toolInputs,
          output: void 0,
          error: error.message
        });
      }
      throw error;
    }
  }
  /**
   * Prepare inputs for tool execution
   */
  async prepareToolInputs(task, tool, options2) {
    const baseInputs = { ...task.inputs };
    const requiredToolParams = Object.entries(tool.parameters).filter(([_, paramInfo]) => paramInfo.required).map(([paramName, _]) => paramName);
    const missingParams = requiredToolParams.filter((param) => !baseInputs[param]);
    if (missingParams.length > 0) {
      const paramPrompt = `As Kyro, map the following task to the required parameters for the "${tool.name}" tool:

Task: ${task.description}
Task Inputs: ${JSON.stringify(baseInputs)}

The tool "${tool.name}" requires the following parameters:
${requiredToolParams.map((param) => `- ${param}: ${tool.parameters[param].description}`).join("\n")}

Based on the task description and inputs, create values for these parameters.
Respond with a JSON object mapping the parameters:
{
  ${missingParams.map((param) => `"${param}": "value"`).join(",\n  ")}
}`;
      const paramResponse = await this.getResponseFromLLM(paramPrompt);
      try {
        const jsonMatch = paramResponse.match(/{[\s\S]*?}/);
        if (jsonMatch) {
          const paramMap = JSON.parse(jsonMatch[0]);
          return { ...baseInputs, ...paramMap };
        }
      } catch (error) {
        log(`Error parsing parameter mapping: ${error}`, "agent");
      }
    }
    return baseInputs;
  }
  /**
   * Execute a task using the LLM
   */
  async executeTaskWithLLM(task, options2) {
    const taskPrompt = `As Kyro, execute the following serverless task:

Task: ${task.name}
Description: ${task.description}
Type: ${task.type}
Inputs: ${JSON.stringify(task.inputs)}

Execute this task and provide the results. Format your response as JSON with appropriate output fields based on the task type.
For a ${task.type} task, your output should include: 
${this.getExpectedOutputFieldsForTaskType(task.type)}

Respond with a JSON object containing your results:
{
  "key1": "value1",
  "key2": "value2",
  ...
}`;
    const taskResponse = await this.getResponseFromLLM(taskPrompt);
    try {
      const jsonMatch = taskResponse.match(/{[\s\S]*?}/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      }
      return { result: taskResponse.trim() };
    } catch (error) {
      log(`Error parsing task result: ${error}`, "agent");
      return { result: taskResponse.trim() };
    }
  }
  /**
   * Get expected output fields for a task type
   */
  getExpectedOutputFieldsForTaskType(taskType) {
    switch (taskType) {
      case "data_processing" /* DATA_PROCESSING */:
        return "processed_data, validation_results, statistics";
      case "api_integration" /* API_INTEGRATION */:
        return "response_data, status_code, headers";
      case "workflow_automation" /* WORKFLOW_AUTOMATION */:
        return "workflow_status, next_steps, trigger_results";
      case "content_generation" /* CONTENT_GENERATION */:
        return "content, metadata, format_info";
      case "notification" /* NOTIFICATION */:
        return "notification_status, recipients, delivery_time";
      default:
        return "result, status, metadata";
    }
  }
  /**
   * Update dependent task inputs with outputs from completed tasks
   */
  updateDependentTaskInputs(completedTaskIndex, result2) {
    const completedTask = this.tasks[completedTaskIndex];
    for (let i = completedTaskIndex + 1; i < this.tasks.length; i++) {
      const task = this.tasks[i];
      Object.entries(task.inputs).forEach(([key, value]) => {
        if (typeof value === "string") {
          if (value === `from_${completedTask.id}` || value === `${completedTask.id}`) {
            task.inputs[key] = result2;
          } else if (value.startsWith(`${completedTask.id}.`)) {
            const field = value.split(".")[1];
            if (result2[field] !== void 0) {
              task.inputs[key] = result2[field];
            }
          }
        }
      });
    }
  }
  /**
   * Generate execution summary
   */
  generateExecutionSummary() {
    let summary = `# Kyro Serverless Execution Summary

`;
    const completedTasks = this.tasks.filter((t) => t.status === "completed");
    const failedTasks = this.tasks.filter((t) => t.status === "failed");
    summary += `## Execution Statistics
`;
    summary += `- Total Tasks: ${this.tasks.length}
`;
    summary += `- Completed: ${completedTasks.length}
`;
    summary += `- Failed: ${failedTasks.length}

`;
    const totalExecutionTime = completedTasks.reduce((total, task) => total + (task.executionTime || 0), 0);
    summary += `- Total Execution Time: ${totalExecutionTime}ms

`;
    summary += `## Task Execution Details

`;
    this.tasks.forEach((task, index2) => {
      summary += `### ${index2 + 1}. ${task.name} (${task.id})
`;
      summary += `**Type:** ${task.type}
`;
      summary += `**Status:** ${task.status}
`;
      summary += `**Description:** ${task.description}
`;
      if (task.executionTime) {
        summary += `**Execution Time:** ${task.executionTime}ms
`;
      }
      summary += `**Inputs:**
\`\`\`json
${JSON.stringify(task.inputs, null, 2)}
\`\`\`
`;
      if (task.outputs) {
        summary += `**Outputs:**
\`\`\`json
${JSON.stringify(task.outputs, null, 2)}
\`\`\`
`;
      }
      if (task.error) {
        summary += `**Error:** ${task.error}
`;
      }
      summary += `
`;
    });
    if (completedTasks.length === this.tasks.length) {
      summary += `## Final Results
`;
      const finalTask = this.tasks[this.tasks.length - 1];
      if (finalTask.outputs) {
        summary += `\`\`\`json
${JSON.stringify(finalTask.outputs, null, 2)}
\`\`\`
`;
      }
    } else if (failedTasks.length > 0) {
      summary += `## Execution Incomplete
`;
      summary += `The automation workflow encountered ${failedTasks.length} error(s) during execution.
`;
      summary += `
**Errors:**
`;
      failedTasks.forEach((task) => {
        summary += `- ${task.name}: ${task.error}
`;
      });
    }
    return summary;
  }
  /**
   * Get the tool calls history
   */
  getToolCallsHistory() {
    return void 0;
  }
  /**
   * Get response from the appropriate LLM based on model name
   */
  async getResponseFromLLM(prompt) {
    try {
      if (this.config.modelName?.includes("claude")) {
        return await this.getResponseFromClaude(prompt);
      } else if (this.config.modelName?.includes("gpt")) {
        return await this.getResponseFromOpenAI(prompt);
      } else {
        return await this.getResponseFromClaude(prompt);
      }
    } catch (error) {
      log(`Error getting LLM response: ${error}`, "agent");
      throw error;
    }
  }
  /**
   * Get response from Claude
   */
  async getResponseFromClaude(prompt) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: this.config.systemPrompt,
      messages: [{ role: "user", content: prompt }]
    });
    return response.content[0].text;
  }
  /**
   * Get response from OpenAI
   */
  async getResponseFromOpenAI(prompt) {
    if (!this.openaiClient) {
      throw new Error("OpenAI client not initialized");
    }
    const response = await this.openaiClient.chat.completions.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      messages: [
        { role: "system", content: this.config.systemPrompt },
        { role: "user", content: prompt }
      ]
    });
    return response.choices[0].message.content || "";
  }
  /**
   * Get available tools
   */
  getAvailableTools() {
    return this.availableTools;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.tools) {
      this.availableTools = config.tools;
    }
  }
  /**
   * Get supported execution modes
   */
  getSupportedExecutionModes() {
    return ["synchronous" /* SYNCHRONOUS */, "asynchronous" /* ASYNCHRONOUS */];
  }
  /**
   * Check if protocol supports a specific capability
   */
  supportsCapability(capability) {
    return this.config.capabilities.includes(capability);
  }
  /**
   * Get current protocol configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    this.tasks = [];
    this.currentTaskIndex = 0;
    this.initialized = false;
    return Promise.resolve();
  }
};

// server/services/agent/protocols/CamelAIProtocol.ts
import Anthropic14 from "@anthropic-ai/sdk";
import OpenAI6 from "openai";
var DEFAULT_MODEL12 = "claude-3-7-sonnet-20250219";
var CamelAIProtocol = class {
  config = {
    systemPrompt: `You are Camel-AI, a collaborative agent framework specialized in agent-agent roleplaying for creative problem solving. 
    
You excel at:
1. Creating natural agent-agent dialogues with distinct personalities
2. Facilitating collaborative problem-solving between specialized agents
3. Maintaining coherent conversations with knowledge sharing
4. Creating complementary agent roles for specific tasks
5. Leveraging roleplay to generate creative solutions`,
    tools: [],
    modelName: DEFAULT_MODEL12,
    temperature: 0.7,
    maxTokens: 2048,
    capabilities: [
      "collaboration" /* COLLABORATION */,
      "role_playing" /* ROLE_PLAYING */,
      "tool_use" /* TOOL_USE */
    ]
  };
  anthropicClient = null;
  openaiClient = null;
  availableTools = [];
  initialized = false;
  // Collaboration state
  agent1 = null;
  agent2 = null;
  conversation = [];
  taskDescription = "";
  solutionState = {
    inProgress: true
  };
  /**
   * Get metadata about this protocol
   */
  getMetadata() {
    return {
      name: "Camel-AI",
      version: "1.0.0",
      description: "Two-agent collaboration roleplay (for creative tasks)",
      capabilities: [
        "collaboration" /* COLLABORATION */,
        "role_playing" /* ROLE_PLAYING */,
        "tool_use" /* TOOL_USE */
      ],
      requiresAuthentication: true,
      supportedModels: [
        "claude-3-7-sonnet-20250219",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "gpt-4o",
        "gpt-4-turbo",
        "gpt-4"
      ]
    };
  }
  /**
   * Initialize the protocol with configuration
   */
  async init(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (this.config.modelName?.includes("claude")) {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY environment variable is required for Claude models");
      }
      this.anthropicClient = new Anthropic14({
        apiKey: process.env.ANTHROPIC_API_KEY
      });
    } else if (this.config.modelName?.includes("gpt")) {
      if (!process.env.OPENAI_API_KEY) {
        throw new Error("OPENAI_API_KEY environment variable is required for OpenAI models");
      }
      this.openaiClient = new OpenAI6({
        apiKey: process.env.OPENAI_API_KEY
      });
    }
    this.availableTools = this.config.tools || [];
    this.agent1 = null;
    this.agent2 = null;
    this.conversation = [];
    this.taskDescription = "";
    this.solutionState = { inProgress: true };
    this.initialized = true;
  }
  /**
   * Execute a task using this protocol
   */
  async execute(options2) {
    if (!this.initialized) {
      throw new Error("Protocol not initialized. Call init() first.");
    }
    const startTime2 = Date.now();
    try {
      if (options2.callbacks?.onStart) {
        options2.callbacks.onStart();
      }
      this.taskDescription = options2.task;
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Agent Role Creation",
          description: "Designing complementary agent roles for the task",
          status: "started"
        });
      }
      const roles = await this.createAgentRoles(options2.task, options2);
      this.agent1 = roles.agent1;
      this.agent2 = roles.agent2;
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Agent Role Creation",
          description: "Agent roles designed successfully",
          output: roles,
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Collaborative Dialogue",
          description: "Starting agent-agent conversation",
          status: "started"
        });
      }
      await this.runConversation(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Collaborative Dialogue",
          description: "Agent conversation completed",
          output: {
            messageCount: this.conversation.length,
            solutionFound: !this.solutionState.inProgress
          },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Solution Synthesis",
          description: "Synthesizing final solution from conversation",
          status: "started"
        });
      }
      const solution = await this.extractSolution(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Solution Synthesis",
          description: "Final solution synthesized",
          status: "completed"
        });
      }
      const finalResponse = this.formatFinalResponse(solution);
      const agentResponse = {
        response: {
          content: finalResponse,
          toolCalls: this.getToolCallsHistory()
        },
        executionTime: Date.now() - startTime2,
        protocol: "camelai",
        metadata: {
          agent1: this.agent1,
          agent2: this.agent2,
          messageCount: this.conversation.length,
          solution
        }
      };
      if (options2.callbacks?.onComplete) {
        options2.callbacks.onComplete(agentResponse);
      }
      return agentResponse;
    } catch (error) {
      log(`Camel-AI Protocol execution error: ${error}`, "agent");
      if (options2.callbacks?.onError) {
        options2.callbacks.onError(error);
      }
      throw error;
    }
  }
  /**
   * Create complementary agent roles based on the task
   */
  async createAgentRoles(task, options2) {
    const rolePrompt = `As Camel-AI, design two complementary agent roles for collaborative problem solving on the following task:

Task: ${task}

Create two agent roles with different expertise, perspectives, and capabilities that can work together effectively to solve this task.

For each agent role, provide:
1. A role name (e.g., "Financial Analyst", "UX Designer")
2. A brief description of the role
3. Key areas of expertise (3-5 areas)
4. Optional constraints or limitations

Respond with a JSON object in this format:
{
  "agent1": {
    "name": "Role Name 1",
    "description": "Brief description of role 1",
    "expertise": ["expertise1", "expertise2", "expertise3"]
  },
  "agent2": {
    "name": "Role Name 2",
    "description": "Brief description of role 2",
    "expertise": ["expertise1", "expertise2", "expertise3"]
  }
}`;
    const roleResponse = await this.getResponseFromLLM(rolePrompt);
    try {
      const jsonMatch = roleResponse.match(/{[\s\S]*?}/);
      if (jsonMatch) {
        const roles = JSON.parse(jsonMatch[0]);
        if (!roles.agent1 || !roles.agent2 || !roles.agent1.name || !roles.agent2.name || !Array.isArray(roles.agent1.expertise) || !Array.isArray(roles.agent2.expertise)) {
          throw new Error("Invalid agent roles format");
        }
        return {
          agent1: roles.agent1,
          agent2: roles.agent2
        };
      }
      throw new Error("Could not parse agent roles from response");
    } catch (error) {
      log(`Error creating agent roles: ${error}`, "agent");
      const taskWords = task.toLowerCase().split(/\s+/);
      const domainWords = taskWords.filter((word) => word.length > 5);
      return {
        agent1: {
          name: `${domainWords[0] || "Domain"} Expert`,
          description: `Expert in ${domainWords[0] || "the specific domain"} with deep technical knowledge`,
          expertise: ["Technical knowledge", "Domain expertise", "Analytical thinking"]
        },
        agent2: {
          name: "Creative Problem Solver",
          description: "Innovative thinker who excels at finding novel solutions",
          expertise: ["Creative thinking", "Lateral thinking", "User perspective"]
        }
      };
    }
  }
  /**
   * Run the conversation between the two agents
   */
  async runConversation(options2) {
    if (!this.agent1 || !this.agent2) {
      throw new Error("Agent roles not defined");
    }
    const maxTurns = 10;
    this.addSystemMessage(`Task: ${this.taskDescription}

The two agents will now collaborate to solve this task.`);
    await this.generateAgentMessage(this.agent1, options2);
    for (let turn = 1; turn < maxTurns; turn++) {
      const currentAgent = turn % 2 === 0 ? this.agent1 : this.agent2;
      await this.generateAgentMessage(currentAgent, options2);
      if (!this.solutionState.inProgress) {
        break;
      }
    }
    if (this.solutionState.inProgress) {
      this.addSystemMessage("The conversation has reached its maximum length. Let's extract the best solution so far.");
    }
  }
  /**
   * Generate a message from an agent
   */
  async generateAgentMessage(agent2, options2) {
    const agentPrompt = this.generateAgentPrompt(agent2);
    const requiresTool = this.checkIfMessageRequiresTool(
      this.conversation.length > 0 ? this.conversation[this.conversation.length - 1].content : this.taskDescription
    );
    let message;
    if (requiresTool && this.availableTools.length > 0) {
      message = await this.generateMessageWithTool(agent2, agentPrompt, options2);
    } else {
      message = await this.getResponseFromLLM(agentPrompt);
    }
    this.addAgentMessage(agent2.name, message);
    if (this.checkForSolution(message)) {
      this.solutionState.inProgress = false;
    }
  }
  /**
   * Generate a prompt for an agent
   */
  generateAgentPrompt(agent2) {
    let prompt = `You are playing the role of ${agent2.name}, who is ${agent2.description}.

`;
    prompt += `Your areas of expertise are: ${agent2.expertise.join(", ")}.

`;
    if (agent2.constraints && agent2.constraints.length > 0) {
      prompt += `Your limitations or constraints are: ${agent2.constraints.join(", ")}.

`;
    }
    prompt += `You are collaborating with ${this.conversation.length % 2 === 0 ? this.agent2.name : this.agent1.name} to solve this task: ${this.taskDescription}

`;
    prompt += `Here is the conversation so far:

`;
    for (const message of this.conversation) {
      prompt += `${message.role}: ${message.content}

`;
    }
    prompt += `As ${agent2.name}, generate your next response in the conversation. 
    
- Stay in character as ${agent2.name}
- Build on the previous messages
- If a solution is becoming clear, work towards finalizing it
- Respond as if you are speaking directly to the other agent
- Be concise but thorough`;
    return prompt;
  }
  /**
   * Check if the message suggests a need for a tool
   */
  checkIfMessageRequiresTool(message) {
    const toolKeywords = [
      "calculate",
      "compute",
      "analyze",
      "data",
      "search",
      "find information",
      "look up",
      "research",
      "fetch",
      "gather data",
      "collect information"
    ];
    return toolKeywords.some((keyword) => message.toLowerCase().includes(keyword));
  }
  /**
   * Generate a message that uses a tool
   */
  async generateMessageWithTool(agent2, basePrompt, options2) {
    let toolPromptText = `${basePrompt}

You have access to the following tools that can help with this task:

`;
    const tools2 = this.availableTools;
    tools2.forEach((tool) => {
      toolPromptText += `- ${tool.name}: ${tool.description}
`;
    });
    toolPromptText += `
If appropriate for your response, you can suggest using one of these tools to help solve the task. Format your tool usage suggestion like this: "I suggest we use the [tool name] to [purpose]". Do not try to execute the tool directly.`;
    const toolResponse = await this.getResponseFromLLM(toolPromptText);
    const toolMatch = /use the (\w+) tool|use (\w+) to|using (\w+) for/i.exec(toolResponse);
    if (toolMatch) {
      const suggestedToolName = (toolMatch[1] || toolMatch[2] || toolMatch[3]).toLowerCase();
      const matchingTool = tools2.find(
        (tool) => tool.name.toLowerCase().includes(suggestedToolName) || suggestedToolName.includes(tool.name.toLowerCase())
      );
      if (matchingTool) {
        const toolInputs = await this.generateToolInputs(agent2, matchingTool, options2);
        try {
          if (options2.callbacks?.onToolUse) {
            options2.callbacks.onToolUse({
              toolName: matchingTool.name,
              input: toolInputs,
              output: void 0,
              error: void 0
            });
          }
          const toolResult = await matchingTool.execute(toolInputs);
          if (options2.callbacks?.onToolUse) {
            options2.callbacks.onToolUse({
              toolName: matchingTool.name,
              input: toolInputs,
              output: toolResult,
              error: void 0
            });
          }
          const resultPrompt = `${basePrompt}

You used the ${matchingTool.name} tool with the following inputs:
${JSON.stringify(toolInputs, null, 2)}

The tool returned this result:
${JSON.stringify(toolResult, null, 2)}

Incorporate this information into your response as ${agent2.name}, making sure to interpret the tool results and explain their significance to the other agent in the context of solving the task.`;
          return await this.getResponseFromLLM(resultPrompt);
        } catch (error) {
          log(`Tool execution error: ${error}`, "agent");
          if (options2.callbacks?.onToolUse) {
            options2.callbacks.onToolUse({
              toolName: matchingTool.name,
              input: toolInputs,
              output: void 0,
              error: error.message
            });
          }
          const errorPrompt = `${basePrompt}

You attempted to use the ${matchingTool.name} tool, but encountered an error: ${error.message}

As ${agent2.name}, acknowledge this issue in your response and suggest an alternative approach that doesn't rely on this tool.`;
          return await this.getResponseFromLLM(errorPrompt);
        }
      }
    }
    return toolResponse;
  }
  /**
   * Generate inputs for a tool
   */
  async generateToolInputs(agent2, tool, options2) {
    const inputPrompt = `As ${agent2.name}, you need to use the "${tool.name}" tool to help solve this task: "${this.taskDescription}".

The tool requires the following parameters:
${Object.entries(tool.parameters).map(
      ([name, info]) => `- ${name} (${info.type}${info.required ? ", required" : ""}): ${info.description}`
    ).join("\n")}

Based on the conversation so far and the current state of the task, generate appropriate values for these parameters.
Respond with a JSON object containing only the parameter values:
{
  ${Object.keys(tool.parameters).map((param) => `"${param}": "value"`).join(",\n  ")}
}`;
    const inputResponse = await this.getResponseFromLLM(inputPrompt);
    try {
      const jsonMatch = inputResponse.match(/{[\s\S]*?}/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      }
      throw new Error("Could not parse tool inputs JSON");
    } catch (error) {
      log(`Error generating tool inputs: ${error}`, "agent");
      const defaultParams = {};
      Object.entries(tool.parameters).forEach(([name, info]) => {
        if (info.required) {
          switch (info.type) {
            case "string":
              defaultParams[name] = "";
              break;
            case "number":
              defaultParams[name] = 0;
              break;
            case "boolean":
              defaultParams[name] = false;
              break;
            case "object":
              defaultParams[name] = {};
              break;
            case "array":
              defaultParams[name] = [];
              break;
            default:
              defaultParams[name] = "";
          }
        }
      });
      return defaultParams;
    }
  }
  /**
   * Add a system message to the conversation
   */
  addSystemMessage(content2) {
    this.conversation.push({
      role: "System",
      content: content2,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  /**
   * Add an agent message to the conversation
   */
  addAgentMessage(agentName, content2) {
    this.conversation.push({
      role: agentName,
      content: content2,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  /**
   * Check if a message contains a solution
   */
  checkForSolution(message) {
    const solutionIndicators = [
      "here's our solution",
      "our final solution",
      "proposed solution",
      "I believe we have solved",
      "our answer is",
      "we've come up with",
      "our joint solution"
    ];
    for (const indicator of solutionIndicators) {
      if (message.toLowerCase().includes(indicator)) {
        const solutionMatch = new RegExp(`${indicator}[:\\s]+(.*?)(?=\\n\\n|$)`, "i").exec(message);
        if (solutionMatch) {
          this.solutionState.solution = solutionMatch[1].trim();
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Extract the final solution from the conversation
   */
  async extractSolution(options2) {
    if (this.solutionState.solution) {
      const reasoningPrompt = `Based on the collaborative conversation between ${this.agent1.name} and ${this.agent2.name}, a solution has been identified:

${this.solutionState.solution}

Analyze this solution for the task: "${this.taskDescription}"

Provide a concise explanation of:
1. Why this solution effectively addresses the task
2. How the collaboration between the agents contributed to this solution
3. Any key insights or innovations from the conversation

Format your response as a concise paragraph (3-5 sentences) that explains the reasoning behind this solution.`;
      const reasoning = await this.getResponseFromLLM(reasoningPrompt);
      return {
        solution: this.solutionState.solution,
        reasoning
      };
    } else {
      const extractPrompt = `Review the following conversation between ${this.agent1.name} and ${this.agent2.name} collaborating on this task:

"${this.taskDescription}"

Conversation:
${this.conversation.map((msg) => `${msg.role}: ${msg.content}`).join("\n\n")}

Extract and synthesize the best solution from this conversation, even if it wasn't explicitly stated as a final solution.

Respond with a JSON object in this format:
{
  "solution": "Clear description of the solution",
  "reasoning": "Explanation of why this is the best solution and how it addresses the task"
}`;
      const extractionResponse = await this.getResponseFromLLM(extractPrompt);
      try {
        const jsonMatch = extractionResponse.match(/{[\s\S]*?}/);
        if (jsonMatch) {
          const extraction = JSON.parse(jsonMatch[0]);
          if (!extraction.solution || !extraction.reasoning) {
            throw new Error("Invalid solution extraction format");
          }
          return {
            solution: extraction.solution,
            reasoning: extraction.reasoning
          };
        }
        throw new Error("Could not parse solution extraction JSON");
      } catch (error) {
        log(`Error extracting solution: ${error}`, "agent");
        return {
          solution: "A solution could not be properly extracted from the conversation.",
          reasoning: "The agent dialogue explored various aspects of the problem but did not converge on a clear solution."
        };
      }
    }
  }
  /**
   * Format the final response
   */
  formatFinalResponse(solution) {
    let response = `# Camel-AI Collaborative Solution

`;
    response += `## Task
${this.taskDescription}

`;
    response += `## Collaborating Agents
`;
    if (this.agent1) {
      response += `### ${this.agent1.name}
`;
      response += `${this.agent1.description}
`;
      response += `**Expertise:** ${this.agent1.expertise.join(", ")}

`;
    }
    if (this.agent2) {
      response += `### ${this.agent2.name}
`;
      response += `${this.agent2.description}
`;
      response += `**Expertise:** ${this.agent2.expertise.join(", ")}

`;
    }
    response += `## Solution
${solution.solution}

`;
    response += `## Reasoning
${solution.reasoning}

`;
    response += `## Conversation Highlights
`;
    const highlights = this.extractConversationHighlights();
    highlights.forEach((msg, idx) => {
      response += `### Exchange ${idx + 1}
`;
      response += `**${msg.role}:** ${msg.content}

`;
    });
    return response;
  }
  /**
   * Extract highlights from the conversation
   */
  extractConversationHighlights() {
    const highlights = [];
    if (this.conversation[0]?.role === "System") {
      highlights.push(this.conversation[0]);
    }
    if (this.conversation.length > 1) {
      highlights.push(this.conversation[1]);
    }
    if (this.conversation.length > 2) {
      highlights.push(this.conversation[2]);
    }
    const midIdx = Math.floor(this.conversation.length / 2);
    if (this.conversation.length > 5 && midIdx > 2) {
      highlights.push(this.conversation[midIdx]);
      if (midIdx + 1 < this.conversation.length) {
        highlights.push(this.conversation[midIdx + 1]);
      }
    }
    if (this.conversation.length > 3) {
      highlights.push(this.conversation[this.conversation.length - 2]);
      highlights.push(this.conversation[this.conversation.length - 1]);
    }
    return highlights;
  }
  /**
   * Get the tool calls history
   */
  getToolCallsHistory() {
    return void 0;
  }
  /**
   * Get response from the appropriate LLM based on model name
   */
  async getResponseFromLLM(prompt) {
    try {
      if (this.config.modelName?.includes("claude")) {
        return await this.getResponseFromClaude(prompt);
      } else if (this.config.modelName?.includes("gpt")) {
        return await this.getResponseFromOpenAI(prompt);
      } else {
        return await this.getResponseFromClaude(prompt);
      }
    } catch (error) {
      log(`Error getting LLM response: ${error}`, "agent");
      throw error;
    }
  }
  /**
   * Get response from Claude
   */
  async getResponseFromClaude(prompt) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: this.config.systemPrompt,
      messages: [{ role: "user", content: prompt }]
    });
    return response.content[0].text;
  }
  /**
   * Get response from OpenAI
   */
  async getResponseFromOpenAI(prompt) {
    if (!this.openaiClient) {
      throw new Error("OpenAI client not initialized");
    }
    const response = await this.openaiClient.chat.completions.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      messages: [
        { role: "system", content: this.config.systemPrompt },
        { role: "user", content: prompt }
      ]
    });
    return response.choices[0].message.content || "";
  }
  /**
   * Get available tools
   */
  getAvailableTools() {
    return this.availableTools;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.tools) {
      this.availableTools = config.tools;
    }
  }
  /**
   * Get supported execution modes
   */
  getSupportedExecutionModes() {
    return ["synchronous" /* SYNCHRONOUS */];
  }
  /**
   * Check if protocol supports a specific capability
   */
  supportsCapability(capability) {
    return this.config.capabilities.includes(capability);
  }
  /**
   * Get current protocol configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    this.agent1 = null;
    this.agent2 = null;
    this.conversation = [];
    this.taskDescription = "";
    this.solutionState = { inProgress: true };
    this.initialized = false;
    return Promise.resolve();
  }
};

// server/services/agent/protocols/AutoGenProtocol.ts
import Anthropic15 from "@anthropic-ai/sdk";
import OpenAI7 from "openai";
var DEFAULT_MODEL13 = "claude-3-7-sonnet-20250219";
var AutoGenProtocol = class {
  config = {
    systemPrompt: `You are Microsoft's AutoGen, a collaborative multi-agent framework specialized in:
1. Coordinating multiple specialized agents to solve complex tasks
2. Effective tool use through planning and execution
3. Code generation and execution
4. Recursive task refinement and solving
5. Sophisticated planning and error handling`,
    tools: [],
    modelName: DEFAULT_MODEL13,
    temperature: 0.7,
    maxTokens: 2048,
    capabilities: [
      "collaboration" /* COLLABORATION */,
      "tool_use" /* TOOL_USE */,
      "code_execution" /* CODE_EXECUTION */,
      "multi_step" /* MULTI_STEP */
    ]
  };
  anthropicClient = null;
  openaiClient = null;
  availableTools = [];
  initialized = false;
  // AutoGen state
  agents = [];
  conversation = {
    messages: [],
    currentSpeaker: "",
    initiator: "",
    taskState: {
      status: "started"
    }
  };
  includeCodeExecutor = false;
  /**
   * Get metadata about this protocol
   */
  getMetadata() {
    return {
      name: "AutoGen",
      version: "1.0.0",
      description: "Microsoft's collaborative multi-agent planning and tool use",
      capabilities: [
        "collaboration" /* COLLABORATION */,
        "tool_use" /* TOOL_USE */,
        "code_execution" /* CODE_EXECUTION */,
        "multi_step" /* MULTI_STEP */
      ],
      requiresAuthentication: true,
      supportedModels: [
        "claude-3-7-sonnet-20250219",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "gpt-4o",
        "gpt-4-turbo",
        "gpt-4"
      ]
    };
  }
  /**
   * Initialize the protocol with configuration
   */
  async init(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (this.config.modelName?.includes("claude")) {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY environment variable is required for Claude models");
      }
      this.anthropicClient = new Anthropic15({
        apiKey: process.env.ANTHROPIC_API_KEY
      });
    } else if (this.config.modelName?.includes("gpt")) {
      if (!process.env.OPENAI_API_KEY) {
        throw new Error("OPENAI_API_KEY environment variable is required for OpenAI models");
      }
      this.openaiClient = new OpenAI7({
        apiKey: process.env.OPENAI_API_KEY
      });
    }
    this.availableTools = this.config.tools || [];
    this.agents = [];
    this.conversation = {
      messages: [],
      currentSpeaker: "",
      initiator: "",
      taskState: {
        status: "started"
      }
    };
    this.initialized = true;
  }
  /**
   * Execute a task using this protocol
   */
  async execute(options2) {
    if (!this.initialized) {
      throw new Error("Protocol not initialized. Call init() first.");
    }
    const startTime2 = Date.now();
    try {
      if (options2.callbacks?.onStart) {
        options2.callbacks.onStart();
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Agent Configuration",
          description: "Setting up agent group for the task",
          status: "started"
        });
      }
      await this.setupAgentGroup(options2.task, options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Agent Configuration",
          description: `Created agent group with ${this.agents.length} agents`,
          output: { agents: this.agents.map((a) => a.name) },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Planning Phase",
          description: "Initiating task planning with planner agent",
          status: "started"
        });
      }
      await this.runPlanningPhase(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Planning Phase",
          description: "Planning phase completed",
          output: { plan: this.conversation.taskState.currentPlan },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Execution Phase",
          description: "Executing plan with collaborative agents",
          status: "started"
        });
      }
      await this.runExecutionPhase(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Execution Phase",
          description: "Execution phase completed",
          output: {
            stepCount: this.conversation.taskState.currentStep,
            status: this.conversation.taskState.status
          },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Critique Phase",
          description: "Reviewing and refining results",
          status: "started"
        });
      }
      await this.runCritiquePhase(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Critique Phase",
          description: "Critique and refinement completed",
          status: "completed"
        });
      }
      const finalResponse = this.formatFinalResponse();
      const agentResponse = {
        response: {
          content: finalResponse,
          toolCalls: this.getToolCallsHistory()
        },
        executionTime: Date.now() - startTime2,
        protocol: "autogen",
        metadata: {
          agents: this.agents.map((a) => a.name),
          messageCount: this.conversation.messages.length,
          status: this.conversation.taskState.status
        }
      };
      if (options2.callbacks?.onComplete) {
        options2.callbacks.onComplete(agentResponse);
      }
      return agentResponse;
    } catch (error) {
      log(`AutoGen Protocol execution error: ${error}`, "agent");
      if (options2.callbacks?.onError) {
        options2.callbacks.onError(error);
      }
      throw error;
    }
  }
  /**
   * Setup the agent group for the task
   */
  async setupAgentGroup(task, options2) {
    this.includeCodeExecutor = this.taskRequiresCodeExecution(task);
    const assistantAgent = {
      id: "assistant",
      type: "assistant" /* ASSISTANT */,
      name: "Assistant",
      description: "Primary problem-solving agent that can plan and coordinate task execution",
      capabilities: ["Planning", "Problem solving", "Tool use", "Coordination"],
      systemPrompt: `You are an intelligent assistant AI that excels at solving complex problems through careful planning and execution. 
Your goal is to help solve the given task by collaborating with other specialized agents.
You can use tools, query information, and delegate subtasks to other agents.
Always be thorough, logical, and show your reasoning.`
    };
    const userProxyAgent = {
      id: "user_proxy",
      type: "user_proxy" /* USER_PROXY */,
      name: "UserProxy",
      description: "Represents the user and can execute tools, code, and verify outputs",
      capabilities: ["Tool execution", "Code execution", "Verification", "Feedback"],
      systemPrompt: `You are a User Proxy agent that can execute tools and code on behalf of the user.
Your primary responsibilities are:
1. Execute tools and code when requested by other agents
2. Verify and validate outputs
3. Provide feedback on results
4. Bridge communication between technical components and other agents`
    };
    const criticAgent = {
      id: "critic",
      type: "critic" /* CRITIC */,
      name: "Critic",
      description: "Evaluates plans, solutions, and execution results to ensure quality and correctness",
      capabilities: ["Evaluation", "Error detection", "Quality assessment", "Suggestions"],
      systemPrompt: `You are a Critic agent responsible for evaluating plans, solutions, and execution results.
Your primary responsibilities are:
1. Review plans for completeness, efficiency, and effectiveness
2. Identify potential issues, edge cases, or errors in proposed solutions
3. Suggest improvements to enhance the quality of the solution
4. Verify that the final solution fully addresses the original task`
    };
    this.agents.push(assistantAgent, userProxyAgent, criticAgent);
    if (this.includeCodeExecutor) {
      const codeExecutorAgent = {
        id: "code_executor",
        type: "code_executor" /* CODE_EXECUTOR */,
        name: "CodeExecutor",
        description: "Specializes in writing, editing, and executing code to solve problems",
        capabilities: ["Code generation", "Code execution", "Debugging", "Testing"],
        systemPrompt: `You are a Code Executor agent specialized in writing, testing, and debugging code.
Your primary responsibilities are:
1. Write clean, efficient, and well-documented code to solve problems
2. Execute code and interpret results
3. Debug errors and propose fixes
4. Test code to ensure it works as expected
When writing code, always consider edge cases, performance, and maintainability.`
      };
      this.agents.push(codeExecutorAgent);
    }
    const plannerAgent = {
      id: "planner",
      type: "planner" /* PLANNER */,
      name: "Planner",
      description: "Creates structured plans for solving complex tasks",
      capabilities: ["Task decomposition", "Planning", "Sequencing", "Resource allocation"],
      systemPrompt: `You are a Planner agent responsible for creating structured plans to solve complex tasks.
Your primary responsibilities are:
1. Break down complex tasks into manageable subtasks
2. Determine the optimal sequence of steps
3. Identify required resources and tools for each step
4. Adapt the plan based on feedback and changing circumstances
Always create clear, step-by-step plans with specific actions for each agent.`
    };
    this.agents.push(plannerAgent);
    if (this.taskInvolvesInformationRetrieval(task)) {
      const retrieverAgent = {
        id: "retriever",
        type: "retriever" /* RETRIEVER */,
        name: "Retriever",
        description: "Specialized in finding and retrieving relevant information",
        capabilities: ["Information search", "Data extraction", "Summarization", "Knowledge integration"],
        systemPrompt: `You are a Retriever agent specialized in finding and retrieving relevant information.
Your primary responsibilities are:
1. Search for specific information needed to solve the task
2. Extract relevant data from various sources
3. Summarize information in a clear and concise manner
4. Integrate knowledge from multiple sources
Always cite your sources and provide context for the information you retrieve.`
      };
      this.agents.push(retrieverAgent);
    }
    this.conversation.initiator = "user_proxy";
    this.conversation.currentSpeaker = "planner";
    this.addMessage({
      from: "user_proxy",
      to: "planner",
      content: `I need help with the following task: ${task}`,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      type: "text"
    });
  }
  /**
   * Check if a task requires code execution
   */
  taskRequiresCodeExecution(task) {
    const codeKeywords = [
      "code",
      "program",
      "script",
      "algorithm",
      "function",
      "automate",
      "develop",
      "implement",
      "programming",
      "software",
      "application",
      "python",
      "javascript",
      "java",
      "html",
      "css",
      "api"
    ];
    return codeKeywords.some((keyword) => task.toLowerCase().includes(keyword));
  }
  /**
   * Check if a task involves information retrieval
   */
  taskInvolvesInformationRetrieval(task) {
    const retrievalKeywords = [
      "find",
      "search",
      "lookup",
      "research",
      "retrieve",
      "information",
      "data",
      "knowledge",
      "article",
      "paper",
      "document",
      "source",
      "reference",
      "report",
      "statistics",
      "facts",
      "details"
    ];
    return retrievalKeywords.some((keyword) => task.toLowerCase().includes(keyword));
  }
  /**
   * Run the planning phase
   */
  async runPlanningPhase(options2) {
    const planner = this.agents.find((a) => a.type === "planner" /* PLANNER */);
    if (!planner) {
      throw new Error("Planner agent not found");
    }
    const plannerResponse = await this.generateAgentResponse(planner, options2);
    this.addMessage({
      from: planner.id,
      to: "assistant",
      content: plannerResponse,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      type: "text"
    });
    const plan = this.extractPlanFromResponse(plannerResponse);
    this.conversation.taskState.currentPlan = plan;
    this.conversation.taskState.currentStep = 0;
    this.conversation.taskState.status = "in_progress";
    await this.getCriticFeedbackOnPlan(options2);
  }
  /**
   * Extract a plan from the planner's response
   */
  extractPlanFromResponse(response) {
    const planRegex = /(\d+\.\s+.+?(?=\n\d+\.|$)|\n\s*-\s+.+?(?=\n\s*-|$))/g;
    const planMatches = response.match(planRegex);
    if (planMatches && planMatches.length > 0) {
      return planMatches.map(
        (step) => step.replace(/^\d+\.\s+|-\s+/, "").trim()
      );
    }
    const lines = response.split("\n").map((line) => line.trim()).filter((line) => line.length > 0 && !line.startsWith("#"));
    return lines;
  }
  /**
   * Get critic feedback on the plan
   */
  async getCriticFeedbackOnPlan(options2) {
    const critic = this.agents.find((a) => a.type === "critic" /* CRITIC */);
    if (!critic) {
      throw new Error("Critic agent not found");
    }
    this.conversation.currentSpeaker = critic.id;
    const criticResponse = await this.generateAgentResponse(critic, options2);
    this.addMessage({
      from: critic.id,
      to: "assistant",
      content: criticResponse,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      type: "feedback"
    });
    if (this.shouldUpdatePlan(criticResponse)) {
      this.conversation.currentSpeaker = "planner";
      const planner = this.agents.find((a) => a.type === "planner" /* PLANNER */);
      if (!planner) {
        throw new Error("Planner agent not found");
      }
      const revisedPlanResponse = await this.generateAgentResponse(planner, options2);
      this.addMessage({
        from: planner.id,
        to: "assistant",
        content: revisedPlanResponse,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        type: "text"
      });
      const revisedPlan = this.extractPlanFromResponse(revisedPlanResponse);
      this.conversation.taskState.currentPlan = revisedPlan;
    }
    this.conversation.currentSpeaker = "assistant";
  }
  /**
   * Check if the plan should be updated based on critic feedback
   */
  shouldUpdatePlan(criticResponse) {
    const revisionIndicators = [
      "revise",
      "update",
      "change",
      "modify",
      "improve",
      "issues",
      "problems",
      "concerns",
      "missing",
      "incomplete",
      "suggest",
      "recommend",
      "better approach",
      "alternative"
    ];
    const lowercaseResponse = criticResponse.toLowerCase();
    for (const indicator of revisionIndicators) {
      if (lowercaseResponse.includes(indicator)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Run the execution phase
   */
  async runExecutionPhase(options2) {
    const assistant = this.agents.find((a) => a.type === "assistant" /* ASSISTANT */);
    const userProxy = this.agents.find((a) => a.type === "user_proxy" /* USER_PROXY */);
    const codeExecutor = this.agents.find((a) => a.type === "code_executor" /* CODE_EXECUTOR */);
    if (!assistant || !userProxy) {
      throw new Error("Required agents not found");
    }
    const maxSteps = 15;
    let currentStep = 0;
    while (currentStep < maxSteps && this.conversation.taskState.status === "in_progress" && this.conversation.taskState.currentStep !== void 0 && this.conversation.taskState.currentStep < (this.conversation.taskState.currentPlan?.length || 0)) {
      const stepNumber = this.conversation.taskState.currentStep;
      const currentStepDescription = this.conversation.taskState.currentPlan[stepNumber];
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Execution Step ${stepNumber + 1}`,
          description: currentStepDescription,
          status: "started"
        });
      }
      let executingAgent = assistant;
      if (this.stepInvolvesCode(currentStepDescription) && codeExecutor) {
        executingAgent = codeExecutor;
      }
      this.conversation.currentSpeaker = executingAgent.id;
      const executingAgentResponse = await this.generateAgentResponse(executingAgent, options2);
      this.addMessage({
        from: executingAgent.id,
        to: "user_proxy",
        content: executingAgentResponse,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        type: this.determineMessageType(executingAgentResponse)
      });
      if (this.requestsToolExecution(executingAgentResponse)) {
        await this.handleToolExecution(executingAgentResponse, userProxy, options2);
      }
      if (this.isStepCompleted(executingAgentResponse)) {
        this.conversation.taskState.currentStep++;
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: `Execution Step ${stepNumber + 1}`,
            description: currentStepDescription,
            status: "completed"
          });
        }
      }
      if (this.conversation.taskState.currentStep >= (this.conversation.taskState.currentPlan?.length || 0)) {
        this.conversation.taskState.status = "completed";
        break;
      }
      currentStep++;
    }
    if (currentStep >= maxSteps && this.conversation.taskState.status !== "completed") {
      this.conversation.taskState.status = "failed";
      this.conversation.taskState.error = "Exceeded maximum number of execution steps";
    }
  }
  /**
   * Check if a step involves code
   */
  stepInvolvesCode(stepDescription) {
    const codeKeywords = [
      "code",
      "program",
      "script",
      "algorithm",
      "function",
      "implement",
      "develop",
      "write",
      "compile",
      "execute",
      "python",
      "javascript",
      "java",
      "html",
      "css"
    ];
    return codeKeywords.some((keyword) => stepDescription.toLowerCase().includes(keyword));
  }
  /**
   * Determine the type of message
   */
  determineMessageType(message) {
    if (message.includes("```") || message.includes("```python") || message.includes("```javascript")) {
      return "code";
    }
    if (this.requestsToolExecution(message)) {
      return "tool_request";
    }
    return "text";
  }
  /**
   * Check if a message requests tool execution
   */
  requestsToolExecution(message) {
    const toolRequestPatterns = [
      /use tool\s*:\s*(\w+)/i,
      /execute tool\s*:\s*(\w+)/i,
      /run tool\s*:\s*(\w+)/i,
      /I need to use the ([a-z_]+) tool/i,
      /please use the ([a-z_]+) tool/i
    ];
    for (const pattern of toolRequestPatterns) {
      if (pattern.test(message)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Handle tool execution
   */
  async handleToolExecution(message, userProxy, options2) {
    const toolInfo = this.extractToolInfo(message);
    if (!toolInfo) {
      return;
    }
    const { toolName, toolParams } = toolInfo;
    const tool = this.availableTools.find((t) => t.name.toLowerCase() === toolName.toLowerCase());
    if (!tool) {
      this.addMessage({
        from: userProxy.id,
        to: this.conversation.currentSpeaker,
        content: `Error: Tool "${toolName}" not found. Available tools are: ${this.availableTools.map((t) => t.name).join(", ")}`,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        type: "text"
      });
      return;
    }
    try {
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: tool.name,
          input: toolParams,
          output: void 0,
          error: void 0
        });
      }
      const toolResult = await tool.execute(toolParams);
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: tool.name,
          input: toolParams,
          output: toolResult,
          error: void 0
        });
      }
      this.addMessage({
        from: userProxy.id,
        to: this.conversation.currentSpeaker,
        content: typeof toolResult === "object" ? `Tool Result:
\`\`\`json
${JSON.stringify(toolResult, null, 2)}
\`\`\`
` : `Tool Result: ${toolResult}`,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        type: "tool_response",
        metadata: {
          tool: tool.name,
          params: toolParams,
          result: toolResult
        }
      });
    } catch (error) {
      log(`Tool execution error: ${error}`, "agent");
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: tool.name,
          input: toolParams,
          output: void 0,
          error: error.message
        });
      }
      this.addMessage({
        from: userProxy.id,
        to: this.conversation.currentSpeaker,
        content: `Error executing tool "${tool.name}": ${error.message}`,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        type: "text"
      });
    }
  }
  /**
   * Extract tool name and parameters from a message
   */
  extractToolInfo(message) {
    let toolName = "";
    const toolNamePatterns = [
      /use tool\s*:\s*(\w+)/i,
      /execute tool\s*:\s*(\w+)/i,
      /run tool\s*:\s*(\w+)/i,
      /I need to use the ([a-z_]+) tool/i,
      /please use the ([a-z_]+) tool/i
    ];
    for (const pattern of toolNamePatterns) {
      const match = pattern.exec(message);
      if (match) {
        toolName = match[1];
        break;
      }
    }
    if (!toolName) {
      return null;
    }
    let toolParams = {};
    const jsonMatch = message.match(/{[\s\S]*?}/);
    if (jsonMatch) {
      try {
        toolParams = JSON.parse(jsonMatch[0]);
      } catch (error) {
        log(`Failed to parse tool parameters: ${error}`, "agent");
      }
    }
    if (Object.keys(toolParams).length === 0) {
      const paramPattern = /([a-z_]+)\s*[:=]\s*['"]?([^'"\n,]+)['"]?/gi;
      let match;
      while ((match = paramPattern.exec(message)) !== null) {
        const [_, key, value] = match;
        toolParams[key.trim()] = value.trim();
      }
    }
    return { toolName, toolParams };
  }
  /**
   * Check if a step is completed
   */
  isStepCompleted(message) {
    const completionIndicators = [
      "step completed",
      "task completed",
      "finished",
      "done",
      "completed successfully",
      "step is now complete",
      "moving to the next step"
    ];
    return completionIndicators.some(
      (indicator) => message.toLowerCase().includes(indicator)
    );
  }
  /**
   * Run the critique phase
   */
  async runCritiquePhase(options2) {
    const critic = this.agents.find((a) => a.type === "critic" /* CRITIC */);
    if (!critic) {
      throw new Error("Critic agent not found");
    }
    this.conversation.currentSpeaker = critic.id;
    const criticReview = await this.generateAgentResponse(critic, options2);
    this.addMessage({
      from: critic.id,
      to: "assistant",
      content: criticReview,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      type: "feedback"
    });
    if (this.needsRefinement(criticReview)) {
      this.conversation.currentSpeaker = "assistant";
      const assistant = this.agents.find((a) => a.type === "assistant" /* ASSISTANT */);
      if (!assistant) {
        throw new Error("Assistant agent not found");
      }
      const refinementResponse = await this.generateAgentResponse(assistant, options2);
      this.addMessage({
        from: assistant.id,
        to: "user_proxy",
        content: refinementResponse,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        type: "text"
      });
    }
  }
  /**
   * Check if refinement is needed based on critic review
   */
  needsRefinement(criticReview) {
    const refinementIndicators = [
      "needs improvement",
      "refinement needed",
      "issues found",
      "problems with",
      "missing",
      "incorrect",
      "errors",
      "failed to",
      "didn't address",
      "incomplete"
    ];
    return refinementIndicators.some(
      (indicator) => criticReview.toLowerCase().includes(indicator)
    );
  }
  /**
   * Generate a response from an agent
   */
  async generateAgentResponse(agent2, options2) {
    const prompt = this.createAgentPrompt(agent2);
    const response = await this.getResponseFromLLM(prompt);
    return response;
  }
  /**
   * Create a prompt for an agent
   */
  createAgentPrompt(agent2) {
    let prompt = `${agent2.systemPrompt}

`;
    const taskMessage = this.conversation.messages.find((m) => m.from === "user_proxy" && m.to === "planner");
    if (taskMessage) {
      prompt += `Task: ${taskMessage.content.replace("I need help with the following task: ", "")}

`;
    }
    if (this.conversation.taskState.currentPlan && this.conversation.taskState.currentPlan.length > 0) {
      prompt += `Current Plan:
`;
      this.conversation.taskState.currentPlan.forEach((step, idx) => {
        const stepStatus = idx < (this.conversation.taskState.currentStep || 0) ? "\u2713" : idx === (this.conversation.taskState.currentStep || 0) ? "\u27F3" : "\u25CB";
        prompt += `${stepStatus} Step ${idx + 1}: ${step}
`;
      });
      prompt += `
`;
      if (this.conversation.taskState.currentStep !== void 0) {
        const currentStepNumber = this.conversation.taskState.currentStep;
        const currentStep = this.conversation.taskState.currentPlan[currentStepNumber];
        if (currentStep) {
          prompt += `Current Step: ${currentStepNumber + 1}. ${currentStep}

`;
        }
      }
    }
    if (this.availableTools.length > 0 && (agent2.type === "assistant" /* ASSISTANT */ || agent2.type === "code_executor" /* CODE_EXECUTOR */)) {
      prompt += `Available Tools:
`;
      this.availableTools.forEach((tool) => {
        prompt += `- ${tool.name}: ${tool.description}
`;
      });
      prompt += `
To use a tool, write "Use Tool: [tool name]" followed by the parameters as JSON.

`;
    }
    prompt += `Conversation History:
`;
    const relevantMessages = this.getRelevantMessages(agent2);
    relevantMessages.forEach((msg) => {
      prompt += `${msg.from}: ${msg.content}

`;
    });
    switch (agent2.type) {
      case "planner" /* PLANNER */:
        prompt += `As the Planner, create a detailed step-by-step plan to accomplish this task. Each step should be clear and actionable.`;
        break;
      case "critic" /* CRITIC */:
        if (this.conversation.taskState.status === "in_progress") {
          prompt += `As the Critic, review the proposed plan and provide feedback on its completeness, efficiency, and effectiveness. Identify any potential issues or suggest improvements.`;
        } else {
          prompt += `As the Critic, review the execution of the task and provide feedback on the solution. Evaluate whether the task was completed successfully and if the solution fully addresses the requirements.`;
        }
        break;
      case "assistant" /* ASSISTANT */:
        prompt += `As the Assistant, work on the current step of the plan. You can use available tools if needed. When the step is complete, indicate this clearly.`;
        break;
      case "code_executor" /* CODE_EXECUTOR */:
        prompt += `As the Code Executor, write code to accomplish the current step. Include comments to explain your approach. When finished, indicate the step is complete.`;
        break;
      default:
        prompt += `You are ${agent2.name}. Generate your next response based on the conversation history and your role.`;
    }
    return prompt;
  }
  /**
   * Get relevant messages for an agent
   */
  getRelevantMessages(agent2) {
    const agentMessages = this.conversation.messages.filter(
      (m) => m.from === agent2.id || m.to === agent2.id
    );
    if (agentMessages.length >= 5) {
      return agentMessages.slice(-10);
    }
    return this.conversation.messages.slice(-10);
  }
  /**
   * Add a message to the conversation
   */
  addMessage(message) {
    this.conversation.messages.push(message);
  }
  /**
   * Format the final response
   */
  formatFinalResponse() {
    let response = `# AutoGen Collaborative Task Execution

`;
    const taskMessage = this.conversation.messages.find((m) => m.from === "user_proxy" && m.to === "planner");
    if (taskMessage) {
      response += `## Task
${taskMessage.content.replace("I need help with the following task: ", "")}

`;
    }
    response += `## Execution Status
`;
    response += `Status: ${this.conversation.taskState.status}
`;
    if (this.conversation.taskState.error) {
      response += `Error: ${this.conversation.taskState.error}
`;
    }
    response += `
## Participating Agents
`;
    this.agents.forEach((agent2) => {
      response += `- **${agent2.name}** (${agent2.type}): ${agent2.description}
`;
    });
    if (this.conversation.taskState.currentPlan) {
      response += `
## Execution Plan
`;
      this.conversation.taskState.currentPlan.forEach((step, idx) => {
        const stepStatus = idx < (this.conversation.taskState.currentStep || 0) ? "\u2713" : idx === (this.conversation.taskState.currentStep || 0) ? "\u27F3" : "\u25CB";
        response += `${stepStatus} Step ${idx + 1}: ${step}
`;
      });
    }
    response += `
## Results
`;
    if (this.conversation.taskState.status === "completed") {
      const solution = this.extractFinalSolution();
      if (solution) {
        response += solution;
      } else {
        response += `Task completed successfully.
`;
      }
    } else if (this.conversation.taskState.status === "failed") {
      response += `Task execution failed: ${this.conversation.taskState.error || "Unknown error"}
`;
    } else {
      response += `Task execution is still in progress.
`;
    }
    const criticMessages = this.conversation.messages.filter(
      (m) => m.from === "critic" && m.type === "feedback"
    );
    if (criticMessages.length > 0) {
      response += `
## Critic Feedback
`;
      response += criticMessages[criticMessages.length - 1].content;
    }
    return response;
  }
  /**
   * Extract the final solution from the conversation
   */
  extractFinalSolution() {
    const recentMessages = this.conversation.messages.slice(-5);
    for (let i = recentMessages.length - 1; i >= 0; i--) {
      const msg = recentMessages[i];
      if ((msg.from === "assistant" || msg.from === "code_executor") && (msg.content.toLowerCase().includes("solution") || msg.content.toLowerCase().includes("result") || msg.content.toLowerCase().includes("final") || msg.content.toLowerCase().includes("output"))) {
        return msg.content;
      }
    }
    return null;
  }
  /**
   * Get the tool calls history
   */
  getToolCallsHistory() {
    const toolCalls = [];
    for (let i = 0; i < this.conversation.messages.length - 1; i++) {
      const msg = this.conversation.messages[i];
      const nextMsg = this.conversation.messages[i + 1];
      if (msg.type === "tool_request" && nextMsg.type === "tool_response" && nextMsg.metadata) {
        toolCalls.push({
          name: nextMsg.metadata.tool,
          input: nextMsg.metadata.params,
          output: nextMsg.metadata.result
        });
      }
    }
    return toolCalls.length > 0 ? toolCalls : void 0;
  }
  /**
   * Get response from the appropriate LLM based on model name
   */
  async getResponseFromLLM(prompt) {
    try {
      if (this.config.modelName?.includes("claude")) {
        return await this.getResponseFromClaude(prompt);
      } else if (this.config.modelName?.includes("gpt")) {
        return await this.getResponseFromOpenAI(prompt);
      } else {
        return await this.getResponseFromClaude(prompt);
      }
    } catch (error) {
      log(`Error getting LLM response: ${error}`, "agent");
      throw error;
    }
  }
  /**
   * Get response from Claude
   */
  async getResponseFromClaude(prompt) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: this.config.systemPrompt,
      messages: [{ role: "user", content: prompt }]
    });
    return response.content[0].text;
  }
  /**
   * Get response from OpenAI
   */
  async getResponseFromOpenAI(prompt) {
    if (!this.openaiClient) {
      throw new Error("OpenAI client not initialized");
    }
    const response = await this.openaiClient.chat.completions.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      messages: [
        { role: "system", content: this.config.systemPrompt },
        { role: "user", content: prompt }
      ]
    });
    return response.choices[0].message.content || "";
  }
  /**
   * Get available tools
   */
  getAvailableTools() {
    return this.availableTools;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.tools) {
      this.availableTools = config.tools;
    }
  }
  /**
   * Get supported execution modes
   */
  getSupportedExecutionModes() {
    return ["synchronous" /* SYNCHRONOUS */, "asynchronous" /* ASYNCHRONOUS */];
  }
  /**
   * Check if protocol supports a specific capability
   */
  supportsCapability(capability) {
    return this.config.capabilities.includes(capability);
  }
  /**
   * Get current protocol configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    this.agents = [];
    this.conversation = {
      messages: [],
      currentSpeaker: "",
      initiator: "",
      taskState: {
        status: "started"
      }
    };
    this.includeCodeExecutor = false;
    this.initialized = false;
    return Promise.resolve();
  }
};

// server/services/agent/protocols/SmolAgentsProtocol.ts
import Anthropic16 from "@anthropic-ai/sdk";
import OpenAI8 from "openai";
var DEFAULT_MODEL14 = "claude-3-7-sonnet-20250219";
var SmolAgentsProtocol = class {
  config = {
    systemPrompt: `You are SmolAgents, a protocol for tiny, lightweight MCP-embedded agents developed by HuggingFace. 
Your architecture specializes in:
1. Minimal resource usage with tiny specialized agents
2. Efficient context management to maximize usable context
3. Modular agent design with specific responsibilities
4. MCP (Memory, Context, Planning) embedding strategy
5. Task-specific execution with minimal overhead`,
    tools: [],
    modelName: DEFAULT_MODEL14,
    temperature: 0.7,
    maxTokens: 1024,
    capabilities: [
      "collaboration" /* COLLABORATION */,
      "tool_use" /* TOOL_USE */,
      "multi_step" /* MULTI_STEP */
    ]
  };
  anthropicClient = null;
  openaiClient = null;
  availableTools = [];
  initialized = false;
  // SmolAgents state
  agents = [];
  executionSteps = [];
  currentAgentId = "";
  taskDescription = "";
  taskStatus = "started";
  maxTokenBudget = 8e3;
  // Maximum tokens to use across all agents (for smol efficiency)
  executionPlan = [];
  /**
   * Get metadata about this protocol
   */
  getMetadata() {
    return {
      name: "SmolAgents",
      version: "1.0.0",
      description: "Tiny, lightweight MCP-embedded agents (HuggingFace)",
      capabilities: [
        "collaboration" /* COLLABORATION */,
        "tool_use" /* TOOL_USE */,
        "multi_step" /* MULTI_STEP */
      ],
      requiresAuthentication: true,
      supportedModels: [
        "claude-3-7-sonnet-20250219",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "gpt-4o",
        "gpt-4-turbo",
        "gpt-4"
      ]
    };
  }
  /**
   * Initialize the protocol with configuration
   */
  async init(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (this.config.modelName?.includes("claude")) {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY environment variable is required for Claude models");
      }
      this.anthropicClient = new Anthropic16({
        apiKey: process.env.ANTHROPIC_API_KEY
      });
    } else if (this.config.modelName?.includes("gpt")) {
      if (!process.env.OPENAI_API_KEY) {
        throw new Error("OPENAI_API_KEY environment variable is required for OpenAI models");
      }
      this.openaiClient = new OpenAI8({
        apiKey: process.env.OPENAI_API_KEY
      });
    }
    this.availableTools = this.config.tools || [];
    this.agents = [];
    this.executionSteps = [];
    this.currentAgentId = "";
    this.taskDescription = "";
    this.taskStatus = "started";
    this.executionPlan = [];
    this.initialized = true;
  }
  /**
   * Execute a task using this protocol
   */
  async execute(options2) {
    if (!this.initialized) {
      throw new Error("Protocol not initialized. Call init() first.");
    }
    const startTime2 = Date.now();
    try {
      if (options2.callbacks?.onStart) {
        options2.callbacks.onStart();
      }
      this.taskDescription = options2.task;
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "SmolAgents Initialization",
          description: "Creating specialized smol agents for the task",
          status: "started"
        });
      }
      this.initializeAgents(options2.task);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "SmolAgents Initialization",
          description: "Created specialized agents",
          output: { agentCount: this.agents.length },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Task Planning",
          description: "Planning task execution with minimal steps",
          status: "started"
        });
      }
      await this.createExecutionPlan(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Task Planning",
          description: "Execution plan created",
          output: { steps: this.executionPlan.length },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Task Execution",
          description: "Executing task with minimal resource usage",
          status: "started"
        });
      }
      await this.executeTask(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Task Execution",
          description: "Task execution completed",
          output: {
            status: this.taskStatus,
            steps: this.executionSteps.length
          },
          status: "completed"
        });
      }
      const finalResponse = this.generateFinalResponse();
      const agentResponse = {
        response: {
          content: finalResponse,
          toolCalls: this.getToolCallsHistory()
        },
        executionTime: Date.now() - startTime2,
        protocol: "smolagents",
        metadata: {
          agentCount: this.agents.length,
          executionSteps: this.executionSteps.length,
          tokenBudget: this.maxTokenBudget,
          status: this.taskStatus
        }
      };
      if (options2.callbacks?.onComplete) {
        options2.callbacks.onComplete(agentResponse);
      }
      return agentResponse;
    } catch (error) {
      log(`SmolAgents Protocol execution error: ${error}`, "agent");
      if (options2.callbacks?.onError) {
        options2.callbacks.onError(error);
      }
      throw error;
    }
  }
  /**
   * Initialize agents for the task
   */
  initializeAgents(task) {
    const routerAgent = {
      id: "router",
      type: "router" /* ROUTER */,
      name: "RouterAgent",
      systemPrompt: `You are a Router agent in a SmolAgents system. Your job is to:
1. Analyze incoming tasks and determine which specialized agent should handle them
2. Parse outputs from agents and decide next steps
3. Maintain minimal context by only passing essential information
4. Sequence agent calls in the most efficient order
5. Track overall task progress
Be extremely concise in your responses. Use minimal tokens.`,
      context: `Task: ${task}`,
      memory: [],
      maxContextSize: 1e3
    };
    const plannerAgent = {
      id: "planner",
      type: "planner" /* PLANNER */,
      name: "PlannerAgent",
      systemPrompt: `You are a Planner agent in a SmolAgents system. Your job is to:
1. Break down tasks into minimal, necessary steps
2. Create execution plans that use the fewest steps possible
3. Specify which agent should handle each step
4. Ensure steps are specific and actionable
5. Adapt plans based on execution feedback
Be extremely concise. Waste no tokens on explanations - just create the plan.`,
      context: `Task: ${task}`,
      memory: [],
      maxContextSize: 1500
    };
    const executorAgent = {
      id: "executor",
      type: "executor" /* EXECUTOR */,
      name: "ExecutorAgent",
      systemPrompt: `You are an Executor agent in a SmolAgents system. Your job is to:
1. Execute specific steps from a plan
2. Use tools efficiently to accomplish tasks
3. Return only essential results
4. Handle errors gracefully with minimal retry attempts
5. Focus on action over deliberation
Be extremely concise. Use tools precisely and return minimal output.`,
      context: `Task: ${task}`,
      memory: [],
      maxContextSize: 2e3
    };
    const memoryAgent = {
      id: "memory",
      type: "memory" /* MEMORY */,
      name: "MemoryAgent",
      systemPrompt: `You are a Memory agent in a SmolAgents system. Your job is to:
1. Store key facts, findings, and outputs from other agents
2. Retrieve relevant information when requested
3. Compress information to minimal necessary tokens
4. Maintain context across multiple execution steps
5. Prioritize important information
Use extreme compression - only store essential details in your responses.`,
      context: `Task: ${task}`,
      memory: [],
      maxContextSize: 1500
    };
    this.agents.push(routerAgent, plannerAgent, executorAgent, memoryAgent);
    if (this.taskRequiresResearch(task)) {
      const researcherAgent = {
        id: "researcher",
        type: "researcher" /* RESEARCHER */,
        name: "ResearcherAgent",
        systemPrompt: `You are a Researcher agent in a SmolAgents system. Your job is to:
1. Find specific information needed for a task
2. Extract only the most relevant details
3. Summarize findings in minimal tokens
4. Use search and retrieval tools efficiently
5. Verify information quality
Be extremely concise. Return only essential information.`,
        context: `Task: ${task}`,
        memory: [],
        maxContextSize: 2e3
      };
      this.agents.push(researcherAgent);
    }
    this.currentAgentId = "router";
  }
  /**
   * Check if a task requires research
   */
  taskRequiresResearch(task) {
    const researchKeywords = [
      "research",
      "find",
      "search",
      "information",
      "data",
      "look up",
      "investigate",
      "facts",
      "details",
      "learn about"
    ];
    return researchKeywords.some((keyword) => task.toLowerCase().includes(keyword));
  }
  /**
   * Create the execution plan
   */
  async createExecutionPlan(options2) {
    const planner = this.getAgentById("planner");
    if (!planner) {
      throw new Error("Planner agent not found");
    }
    const plannerPrompt = `Create a minimal execution plan for this task:
${this.taskDescription}

Available agents:
- router: Routes tasks between agents
- executor: Executes specific steps and uses tools
- memory: Stores and retrieves key information
${this.agents.some((a) => a.id === "researcher") ? "- researcher: Finds information and summarizes findings" : ""}

Available tools:
${this.availableTools.map((tool) => `- ${tool.name}: ${tool.description}`).join("\n")}

Create a step-by-step plan with at most 5 steps. Each step should specify:
1. The agent to use
2. The exact action to take
3. Any tools needed

Format your plan as a numbered list:
1. [agent] - action
2. [agent] - action
...

Your plan must be minimal and eliminate unnecessary steps.`;
    const plannerResponse = await this.getAgentResponse(planner, plannerPrompt, options2);
    this.executionPlan = this.extractPlanSteps(plannerResponse);
    this.addExecutionStep("planner", plannerPrompt, plannerResponse);
    this.taskStatus = "in_progress";
  }
  /**
   * Extract plan steps from planner response
   */
  extractPlanSteps(plannerResponse) {
    const stepRegex = /\d+\.\s*\[(\w+)\]\s*-\s*(.+?)(?=\n\d+\.|\n\n|$)/gs;
    const steps = [];
    let match;
    while ((match = stepRegex.exec(plannerResponse)) !== null) {
      steps.push(`[${match[1]}] ${match[2].trim()}`);
    }
    if (steps.length === 0) {
      const lines = plannerResponse.split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
      for (const line of lines) {
        const agentMatch = line.match(/\[(\w+)\]/);
        if (agentMatch) {
          steps.push(line);
        }
      }
    }
    return steps;
  }
  /**
   * Execute the task according to the plan
   */
  async executeTask(options2) {
    const maxSteps = 10;
    let stepCount = 0;
    for (let i = 0; i < this.executionPlan.length && stepCount < maxSteps; i++) {
      const planStep = this.executionPlan[i];
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Execution Step ${i + 1}`,
          description: planStep,
          status: "started"
        });
      }
      const agentMatch = planStep.match(/\[(\w+)\]/);
      if (!agentMatch) {
        log(`Invalid plan step format: ${planStep}`, "agent");
        continue;
      }
      const agentId = agentMatch[1];
      const action = planStep.replace(/\[\w+\]\s*/, "").trim();
      const agent2 = this.getAgentById(agentId);
      if (!agent2) {
        log(`Agent not found: ${agentId}`, "agent");
        continue;
      }
      this.currentAgentId = agentId;
      const agentPrompt = this.createAgentPrompt(agent2, action);
      const agentResponse = await this.getAgentResponse(agent2, agentPrompt, options2);
      let toolResults;
      if (this.containsToolRequest(agentResponse) && agent2.type === "executor" /* EXECUTOR */) {
        toolResults = await this.processToolRequests(agentResponse, options2);
      }
      this.addExecutionStep(agentId, agentPrompt, agentResponse, toolResults);
      if (agent2.type !== "memory" /* MEMORY */) {
        await this.updateMemoryAgent(agentResponse, options2);
      }
      this.updateAgentMemory(agent2, agentResponse);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Execution Step ${i + 1}`,
          description: planStep,
          output: toolResults || { response: this.truncateResponse(agentResponse, 100) },
          status: "completed"
        });
      }
      if (this.isTaskCompleted(agentResponse)) {
        this.taskStatus = "completed";
        break;
      }
      stepCount++;
    }
    if (stepCount >= maxSteps && this.taskStatus !== "completed") {
      this.taskStatus = "failed";
      log(`Exceeded maximum number of steps: ${maxSteps}`, "agent");
    }
  }
  /**
   * Create a prompt for an agent
   */
  createAgentPrompt(agent2, action) {
    let prompt = `${agent2.systemPrompt}

`;
    prompt += `${agent2.context}

`;
    prompt += `Current action: ${action}

`;
    if (agent2.memory.length > 0) {
      prompt += `Agent memory (most recent):
`;
      const recentMemories = agent2.memory.slice(-3);
      for (const memory of recentMemories) {
        prompt += `- ${memory}
`;
      }
      prompt += `
`;
    }
    switch (agent2.type) {
      case "router" /* ROUTER */:
        prompt += `Route this action to the appropriate agent or determine next steps. Be extremely concise.`;
        break;
      case "planner" /* PLANNER */:
        prompt += `Plan how to execute this action in minimal steps. Be extremely concise.`;
        break;
      case "executor" /* EXECUTOR */:
        if (this.availableTools.length > 0) {
          prompt += `Available tools:
`;
          for (const tool of this.availableTools) {
            prompt += `- ${tool.name}: ${tool.description}
`;
          }
          prompt += `
To use a tool, respond with: USE TOOL: [tool name] with parameters: [parameters]

`;
        }
        prompt += `Execute this action efficiently. Return only essential results.`;
        break;
      case "memory" /* MEMORY */:
        prompt += `Store or retrieve information related to this action. Use extreme compression.`;
        break;
      case "researcher" /* RESEARCHER */:
        prompt += `Find information needed for this action. Summarize findings in minimal tokens.`;
        break;
    }
    prompt += `

MAXIMUM TOKEN BUDGET: Use as few tokens as possible in your response.`;
    return prompt;
  }
  /**
   * Get a response from an agent
   */
  async getAgentResponse(agent2, prompt, options2) {
    const tokenLimit = Math.min(agent2.maxContextSize, this.config.maxTokens || 1024);
    const response = await this.getResponseFromLLM(prompt, tokenLimit);
    return response;
  }
  /**
   * Add an execution step to the history
   */
  addExecutionStep(agentId, input2, output, toolCalls) {
    this.executionSteps.push({
      agentId,
      input: input2,
      output,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      toolCalls: toolCalls ? [toolCalls] : void 0
    });
  }
  /**
   * Update the memory agent with important information
   */
  async updateMemoryAgent(information, options2) {
    const memoryAgent = this.getAgentById("memory");
    if (!memoryAgent) {
      return;
    }
    const memoryPrompt = `Update memory with this new information:
${information}

Extract ONLY key facts and findings. Use extreme compression.
Respond with a bullet list of key points in 50 words or less:`;
    const memoryResponse = await this.getAgentResponse(memoryAgent, memoryPrompt, options2);
    memoryAgent.context += `
Memory update at ${(/* @__PURE__ */ new Date()).toISOString()}:
${memoryResponse}`;
    this.addExecutionStep("memory", memoryPrompt, memoryResponse);
  }
  /**
   * Update an agent's memory with its recent response
   */
  updateAgentMemory(agent2, response) {
    const memoryEntry = this.truncateResponse(response, 200);
    agent2.memory.push(memoryEntry);
    if (agent2.memory.length > 5) {
      agent2.memory = agent2.memory.slice(-5);
    }
  }
  /**
   * Check if a response contains a tool request
   */
  containsToolRequest(response) {
    return response.includes("USE TOOL:") || response.includes("USE_TOOL:") || response.includes("TOOL:");
  }
  /**
   * Process tool requests in the response
   */
  async processToolRequests(response, options2) {
    const toolRegex = /(?:USE TOOL|USE_TOOL|TOOL):\s*(\w+)(?:\s+with parameters:|\s+params:|\s+with:)\s*(.+?)(?=\n\n|$)/s;
    const match = toolRegex.exec(response);
    if (!match) {
      return void 0;
    }
    const toolName = match[1];
    const parametersText = match[2];
    const tool = this.availableTools.find((t) => t.name.toLowerCase() === toolName.toLowerCase());
    if (!tool) {
      return { error: `Tool ${toolName} not found` };
    }
    let parameters = {};
    try {
      if (parametersText.trim().startsWith("{")) {
        parameters = JSON.parse(parametersText);
      } else {
        parametersText.split(",").forEach((pair) => {
          const [key, value] = pair.split(":").map((s) => s.trim());
          if (key && value) {
            parameters[key] = this.parseValue(value);
          }
        });
      }
    } catch (error) {
      log(`Error parsing tool parameters: ${error}`, "agent");
      return { error: `Failed to parse parameters: ${error.message}` };
    }
    try {
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: tool.name,
          input: parameters,
          output: void 0,
          error: void 0
        });
      }
      const result2 = await tool.execute(parameters);
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: tool.name,
          input: parameters,
          output: result2,
          error: void 0
        });
      }
      return {
        tool: toolName,
        input: parameters,
        output: result2
      };
    } catch (error) {
      log(`Error executing tool ${toolName}: ${error}`, "agent");
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: tool.name,
          input: parameters,
          output: void 0,
          error: error.message
        });
      }
      return {
        tool: toolName,
        input: parameters,
        error: error.message
      };
    }
  }
  /**
   * Parse a string value to the appropriate type
   */
  parseValue(value) {
    value = value.replace(/^["']|["']$/g, "");
    if (/^-?\d+(\.\d+)?$/.test(value)) {
      return Number(value);
    }
    if (value.toLowerCase() === "true") return true;
    if (value.toLowerCase() === "false") return false;
    return value;
  }
  /**
   * Check if the task is completed
   */
  isTaskCompleted(response) {
    const completionIndicators = [
      "task completed",
      "task is complete",
      "finished task",
      "task finished",
      "task accomplished",
      "successfully completed",
      "TASK_COMPLETE",
      "TASK_FINISHED"
    ];
    return completionIndicators.some(
      (indicator) => response.toLowerCase().includes(indicator.toLowerCase())
    );
  }
  /**
   * Get an agent by ID
   */
  getAgentById(id) {
    return this.agents.find((agent2) => agent2.id === id);
  }
  /**
   * Truncate a response to a maximum length
   */
  truncateResponse(response, maxLength) {
    if (response.length <= maxLength) {
      return response;
    }
    return response.substring(0, maxLength - 3) + "...";
  }
  /**
   * Generate the final response
   */
  generateFinalResponse() {
    let response = `# SmolAgents Task Execution Report

`;
    response += `## Task
${this.taskDescription}

`;
    response += `## Status
${this.taskStatus.toUpperCase()}

`;
    response += `## Agent Utilization
`;
    const agentUsage = /* @__PURE__ */ new Map();
    for (const step of this.executionSteps) {
      agentUsage.set(step.agentId, (agentUsage.get(step.agentId) || 0) + 1);
    }
    for (const agent2 of this.agents) {
      const usageCount = agentUsage.get(agent2.id) || 0;
      response += `- ${agent2.name}: ${usageCount} activations
`;
    }
    response += `
## Result
`;
    if (this.taskStatus === "completed") {
      const finalSteps = this.executionSteps.slice(-3);
      const executorStep = finalSteps.find((step) => step.agentId === "executor");
      if (executorStep) {
        response += this.extractResultFromResponse(executorStep.output);
      } else {
        const lastStep = this.executionSteps[this.executionSteps.length - 1];
        response += this.extractResultFromResponse(lastStep.output);
      }
    } else if (this.taskStatus === "failed") {
      response += `Task execution failed.
`;
    } else {
      response += `Task execution incomplete.
`;
    }
    response += `
## Execution Summary
`;
    response += `- Total steps: ${this.executionSteps.length}
`;
    const toolUsage = /* @__PURE__ */ new Map();
    for (const step of this.executionSteps) {
      if (step.toolCalls) {
        for (const toolCall of step.toolCalls) {
          toolUsage.set(toolCall.tool, (toolUsage.get(toolCall.tool) || 0) + 1);
        }
      }
    }
    if (toolUsage.size > 0) {
      response += `- Tools used:
`;
      for (const [tool, count2] of toolUsage.entries()) {
        response += `  - ${tool}: ${count2} calls
`;
      }
    }
    return response;
  }
  /**
   * Extract result from a response
   */
  extractResultFromResponse(response) {
    const resultSectionPatterns = [
      /result:(.+?)(?=\n\n|$)/is,
      /final result:(.+?)(?=\n\n|$)/is,
      /answer:(.+?)(?=\n\n|$)/is,
      /conclusion:(.+?)(?=\n\n|$)/is
    ];
    for (const pattern of resultSectionPatterns) {
      const match = pattern.exec(response);
      if (match) {
        return match[1].trim();
      }
    }
    return response;
  }
  /**
   * Get the tool calls history
   */
  getToolCallsHistory() {
    const toolCalls = [];
    for (const step of this.executionSteps) {
      if (step.toolCalls) {
        for (const toolCall of step.toolCalls) {
          if (!toolCall.error) {
            toolCalls.push({
              name: toolCall.tool,
              input: toolCall.input,
              output: toolCall.output
            });
          }
        }
      }
    }
    return toolCalls.length > 0 ? toolCalls : void 0;
  }
  /**
   * Get response from the appropriate LLM based on model name, with token limit
   */
  async getResponseFromLLM(prompt, maxTokens = 1024) {
    try {
      if (this.config.modelName?.includes("claude")) {
        return await this.getResponseFromClaude(prompt, maxTokens);
      } else if (this.config.modelName?.includes("gpt")) {
        return await this.getResponseFromOpenAI(prompt, maxTokens);
      } else {
        return await this.getResponseFromClaude(prompt, maxTokens);
      }
    } catch (error) {
      log(`Error getting LLM response: ${error}`, "agent");
      throw error;
    }
  }
  /**
   * Get response from Claude with token limit
   */
  async getResponseFromClaude(prompt, maxTokens) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: maxTokens,
      temperature: this.config.temperature,
      system: this.config.systemPrompt,
      messages: [{ role: "user", content: prompt }]
    });
    return response.content[0].text;
  }
  /**
   * Get response from OpenAI with token limit
   */
  async getResponseFromOpenAI(prompt, maxTokens) {
    if (!this.openaiClient) {
      throw new Error("OpenAI client not initialized");
    }
    const response = await this.openaiClient.chat.completions.create({
      model: this.config.modelName,
      max_tokens: maxTokens,
      temperature: this.config.temperature,
      messages: [
        { role: "system", content: this.config.systemPrompt },
        { role: "user", content: prompt }
      ]
    });
    return response.choices[0].message.content || "";
  }
  /**
   * Get available tools
   */
  getAvailableTools() {
    return this.availableTools;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.tools) {
      this.availableTools = config.tools;
    }
    if (config.maxTokens) {
      this.maxTokenBudget = config.maxTokens;
    }
  }
  /**
   * Get supported execution modes
   */
  getSupportedExecutionModes() {
    return ["synchronous" /* SYNCHRONOUS */];
  }
  /**
   * Check if protocol supports a specific capability
   */
  supportsCapability(capability) {
    return this.config.capabilities.includes(capability);
  }
  /**
   * Get current protocol configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    this.agents = [];
    this.executionSteps = [];
    this.currentAgentId = "";
    this.taskDescription = "";
    this.taskStatus = "started";
    this.executionPlan = [];
    this.initialized = false;
    return Promise.resolve();
  }
};

// server/services/agent/protocols/AllHandsProtocol.ts
import Anthropic17 from "@anthropic-ai/sdk";
import OpenAI9 from "openai";
var DEFAULT_MODEL15 = "claude-3-7-sonnet-20250219";
var AllHandsProtocol = class {
  config = {
    systemPrompt: `You are All-Hands, a collaborative multi-agent orchestration protocol for software development projects.
You excel at:
1. Coordinating teams of specialized development agents
2. Managing software project lifecycles
3. Ensuring code quality and consistency
4. Efficient task allocation and execution
5. Comprehensive documentation and testing`,
    tools: [],
    modelName: DEFAULT_MODEL15,
    temperature: 0.5,
    maxTokens: 2048,
    capabilities: [
      "collaboration" /* COLLABORATION */,
      "multi_step" /* MULTI_STEP */,
      "role_playing" /* ROLE_PLAYING */,
      "code_execution" /* CODE_EXECUTION */
    ]
  };
  anthropicClient = null;
  openaiClient = null;
  availableTools = [];
  initialized = false;
  // Project state
  agents = [];
  artifacts = [];
  tasks = [];
  projectContext = "";
  currentPhase = "planning";
  projectSummary = "";
  /**
   * Get metadata about this protocol
   */
  getMetadata() {
    return {
      name: "All-Hands",
      version: "1.0.0",
      description: "Dev multi-agent orchestration for repo/project flows (HuggingFace)",
      capabilities: [
        "collaboration" /* COLLABORATION */,
        "multi_step" /* MULTI_STEP */,
        "role_playing" /* ROLE_PLAYING */,
        "code_execution" /* CODE_EXECUTION */
      ],
      requiresAuthentication: true,
      supportedModels: [
        "claude-3-7-sonnet-20250219",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "gpt-4o",
        "gpt-4-turbo",
        "gpt-4"
      ]
    };
  }
  /**
   * Initialize the protocol with configuration
   */
  async init(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (this.config.modelName?.includes("claude")) {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY environment variable is required for Claude models");
      }
      this.anthropicClient = new Anthropic17({
        apiKey: process.env.ANTHROPIC_API_KEY
      });
    } else if (this.config.modelName?.includes("gpt")) {
      if (!process.env.OPENAI_API_KEY) {
        throw new Error("OPENAI_API_KEY environment variable is required for OpenAI models");
      }
      this.openaiClient = new OpenAI9({
        apiKey: process.env.OPENAI_API_KEY
      });
    }
    this.availableTools = this.config.tools || [];
    this.agents = [];
    this.artifacts = [];
    this.tasks = [];
    this.projectContext = "";
    this.currentPhase = "planning";
    this.projectSummary = "";
    this.initialized = true;
  }
  /**
   * Execute a task using this protocol
   */
  async execute(options2) {
    if (!this.initialized) {
      throw new Error("Protocol not initialized. Call init() first.");
    }
    const startTime2 = Date.now();
    try {
      if (options2.callbacks?.onStart) {
        options2.callbacks.onStart();
      }
      this.projectContext = options2.task;
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Team Assembly",
          description: "Assembling development team with specialized roles",
          status: "started"
        });
      }
      await this.assembleDevTeam(options2.task);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Team Assembly",
          description: "Development team assembled",
          output: { agents: this.agents.map((a) => a.name) },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Project Planning",
          description: "Creating project plan and task breakdown",
          status: "started"
        });
      }
      await this.runPlanningPhase(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Project Planning",
          description: "Project plan created",
          output: { tasks: this.tasks.length },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Development Phase",
          description: "Implementing core functionality",
          status: "started"
        });
      }
      this.currentPhase = "development";
      await this.runDevelopmentPhase(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Development Phase",
          description: "Core implementation completed",
          output: { artifacts: this.getArtifactsByType("code").length },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Testing Phase",
          description: "Creating and running tests",
          status: "started"
        });
      }
      this.currentPhase = "testing";
      await this.runTestingPhase(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Testing Phase",
          description: "Testing completed",
          output: { artifacts: this.getArtifactsByType("test").length },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Review Phase",
          description: "Reviewing code and addressing issues",
          status: "started"
        });
      }
      this.currentPhase = "review";
      await this.runReviewPhase(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Review Phase",
          description: "Review process completed",
          output: { artifacts: this.getArtifactsByType("review").length },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Documentation Phase",
          description: "Creating documentation",
          status: "started"
        });
      }
      this.currentPhase = "documentation";
      await this.runDocumentationPhase(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Documentation Phase",
          description: "Documentation completed",
          output: { artifacts: this.getArtifactsByType("documentation").length },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Project Summary",
          description: "Generating final project summary",
          status: "started"
        });
      }
      await this.generateProjectSummary(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Project Summary",
          description: "Project summary generated",
          status: "completed"
        });
      }
      const finalResponse = this.projectSummary;
      const agentResponse = {
        response: {
          content: finalResponse,
          toolCalls: this.getToolCallsHistory()
        },
        executionTime: Date.now() - startTime2,
        protocol: "allhands",
        metadata: {
          agents: this.agents.map((a) => a.role),
          artifacts: this.artifacts.length,
          tasks: this.tasks.length
        }
      };
      if (options2.callbacks?.onComplete) {
        options2.callbacks.onComplete(agentResponse);
      }
      return agentResponse;
    } catch (error) {
      log(`All-Hands Protocol execution error: ${error}`, "agent");
      if (options2.callbacks?.onError) {
        options2.callbacks.onError(error);
      }
      throw error;
    }
  }
  /**
   * Assemble the development team based on project needs
   */
  async assembleDevTeam(projectDescription) {
    this.agents.push(
      this.createAgent("architect" /* ARCHITECT */),
      this.createAgent("developer" /* DEVELOPER */),
      this.createAgent("tester" /* TESTER */)
    );
    if (this.needsSecurityExpert(projectDescription)) {
      this.agents.push(this.createAgent("security_expert" /* SECURITY_EXPERT */));
    }
    this.agents.push(
      this.createAgent("reviewer" /* REVIEWER */),
      this.createAgent("documenter" /* DOCUMENTER */)
    );
    if (this.isLargeProject(projectDescription)) {
      this.agents.push(this.createAgent("product_manager" /* PRODUCT_MANAGER */));
    }
  }
  /**
   * Create an agent with the specified role
   */
  createAgent(role) {
    switch (role) {
      case "architect" /* ARCHITECT */:
        return {
          role,
          name: "Software Architect",
          description: "Designs the overall system architecture and makes key technical decisions",
          expertise: ["System design", "Architecture patterns", "Technical leadership", "Code structure"],
          systemPrompt: `You are a Software Architect responsible for designing the overall system architecture.
Your focus is on:
- Creating clean, maintainable, and scalable architecture
- Making key technical decisions about frameworks, patterns, and approaches
- Ensuring the design meets all functional and non-functional requirements
- Providing architectural guidance to the development team`
        };
      case "developer" /* DEVELOPER */:
        return {
          role,
          name: "Developer",
          description: "Implements the core functionality according to architectural guidelines",
          expertise: ["Programming", "Algorithm implementation", "Problem-solving", "Debugging"],
          systemPrompt: `You are a Developer responsible for implementing the core functionality.
Your focus is on:
- Writing clean, efficient, and well-tested code
- Following architectural guidelines and coding standards
- Implementing features according to specifications
- Debugging and fixing issues as they arise`
        };
      case "tester" /* TESTER */:
        return {
          role,
          name: "Quality Assurance Engineer",
          description: "Creates and runs tests to ensure code quality and functionality",
          expertise: ["Test design", "Test automation", "Quality assurance", "Bug reporting"],
          systemPrompt: `You are a Quality Assurance Engineer responsible for testing.
Your focus is on:
- Creating comprehensive test plans and test cases
- Writing automated tests (unit, integration, and system)
- Identifying edge cases and potential issues
- Ensuring the software meets quality standards and requirements`
        };
      case "reviewer" /* REVIEWER */:
        return {
          role,
          name: "Code Reviewer",
          description: "Reviews code for quality, standards, and potential issues",
          expertise: ["Code review", "Best practices", "Static analysis", "Code quality"],
          systemPrompt: `You are a Code Reviewer responsible for ensuring code quality.
Your focus is on:
- Reviewing code for readability, maintainability, and efficiency
- Ensuring adherence to coding standards and best practices
- Identifying potential bugs, edge cases, or performance issues
- Providing constructive feedback to improve code quality`
        };
      case "documenter" /* DOCUMENTER */:
        return {
          role,
          name: "Technical Writer",
          description: "Creates documentation for the project, code, and APIs",
          expertise: ["Technical writing", "Documentation", "API documentation", "User guides"],
          systemPrompt: `You are a Technical Writer responsible for creating documentation.
Your focus is on:
- Writing clear and concise technical documentation
- Creating user guides, API documentation, and code comments
- Making complex technical concepts accessible
- Ensuring documentation is complete, accurate, and up-to-date`
        };
      case "security_expert" /* SECURITY_EXPERT */:
        return {
          role,
          name: "Security Expert",
          description: "Reviews code and architecture for security vulnerabilities",
          expertise: ["Security analysis", "Threat modeling", "Secure coding", "Vulnerability assessment"],
          systemPrompt: `You are a Security Expert responsible for ensuring the security of the software.
Your focus is on:
- Identifying potential security vulnerabilities
- Conducting threat modeling and security reviews
- Recommending secure coding practices
- Ensuring compliance with security standards and best practices`
        };
      case "product_manager" /* PRODUCT_MANAGER */:
        return {
          role,
          name: "Product Manager",
          description: "Ensures the project meets business and user requirements",
          expertise: ["Requirements gathering", "User stories", "Feature prioritization", "Product roadmap"],
          systemPrompt: `You are a Product Manager responsible for ensuring the project meets requirements.
Your focus is on:
- Clarifying business and user requirements
- Creating and managing user stories and acceptance criteria
- Prioritizing features and tasks
- Ensuring the final product delivers value to users`
        };
      default:
        throw new Error(`Unknown agent role: ${role}`);
    }
  }
  /**
   * Check if the project needs a security expert
   */
  needsSecurityExpert(projectDescription) {
    const securityKeywords = [
      "security",
      "authentication",
      "authorization",
      "encryption",
      "user data",
      "privacy",
      "sensitive",
      "login",
      "password",
      "access control",
      "oauth",
      "jwt",
      "tokens",
      "secure"
    ];
    return securityKeywords.some(
      (keyword) => projectDescription.toLowerCase().includes(keyword)
    );
  }
  /**
   * Check if the project is large and complex
   */
  isLargeProject(projectDescription) {
    const isLongDescription = projectDescription.length > 500;
    const complexityKeywords = [
      "complex",
      "large",
      "multiple",
      "several",
      "integration",
      "enterprise",
      "scalable",
      "extensive",
      "comprehensive",
      "multi-part",
      "many features",
      "sophisticated"
    ];
    const hasComplexityKeywords = complexityKeywords.some(
      (keyword) => projectDescription.toLowerCase().includes(keyword)
    );
    return isLongDescription || hasComplexityKeywords;
  }
  /**
   * Run the planning phase
   */
  async runPlanningPhase(options2) {
    const architect = this.getAgentByRole("architect" /* ARCHITECT */);
    if (!architect) {
      throw new Error("Architect agent not found");
    }
    const architecturalDesign = await this.generateArtifactFromAgent(
      architect,
      "architecture_design",
      "design",
      `Create a high-level architectural design for this project:
      
${this.projectContext}

Include:
1. Overall system architecture
2. Key components and their relationships
3. Technical decisions (languages, frameworks, patterns)
4. Data models and storage approach
5. Any API specifications

The design should be comprehensive but concise.`,
      options2
    );
    let requirementsArtifact = null;
    const productManager = this.getAgentByRole("product_manager" /* PRODUCT_MANAGER */);
    if (productManager) {
      requirementsArtifact = await this.generateArtifactFromAgent(
        productManager,
        "project_requirements",
        "documentation",
        `Based on this project description:
        
${this.projectContext}

And this architectural design:

${architecturalDesign.content}

Create detailed project requirements including:
1. User stories or functional requirements
2. Non-functional requirements
3. Acceptance criteria
4. Project scope and constraints
5. Key deliverables

Be detailed but concise.`,
        options2
      );
    }
    const taskBreakdownInput = `Create a detailed task breakdown for this project:
    
Project Description:
${this.projectContext}

Architectural Design:
${architecturalDesign.content}

${requirementsArtifact ? `
Requirements:
${requirementsArtifact.content}
` : ""}

Provide a structured list of tasks with:
1. Task description
2. Appropriate assignee role (architect, developer, tester, etc.)
3. Dependencies between tasks
4. Estimated complexity (simple, medium, complex)

Tasks should cover all phases: design, development, testing, review, and documentation.`;
    const taskPlannerAgent = productManager || architect;
    const taskBreakdownArtifact = await this.generateArtifactFromAgent(
      taskPlannerAgent,
      "task_breakdown",
      "plan",
      taskBreakdownInput,
      options2
    );
    this.tasks = this.parseTasks(taskBreakdownArtifact.content);
  }
  /**
   * Parse tasks from task breakdown artifact
   */
  parseTasks(taskBreakdown) {
    const tasks = [];
    const taskPattern = /(\d+|\*)\.\s+(.+?)(?=\n\d+\.|\n\*|\n\n|$)/gs;
    let match;
    let taskId = 1;
    while ((match = taskPattern.exec(taskBreakdown)) !== null) {
      const taskDescription = match[2].trim();
      let assignee = "developer" /* DEVELOPER */;
      const assigneeMatch = taskDescription.match(/assignee:?\s+(\w+)/i) || taskDescription.match(/role:?\s+(\w+)/i);
      if (assigneeMatch) {
        const roleName = assigneeMatch[1].toLowerCase();
        if (roleName.includes("architect")) {
          assignee = "architect" /* ARCHITECT */;
        } else if (roleName.includes("develop") || roleName.includes("implement")) {
          assignee = "developer" /* DEVELOPER */;
        } else if (roleName.includes("test")) {
          assignee = "tester" /* TESTER */;
        } else if (roleName.includes("review")) {
          assignee = "reviewer" /* REVIEWER */;
        } else if (roleName.includes("document")) {
          assignee = "documenter" /* DOCUMENTER */;
        } else if (roleName.includes("security")) {
          assignee = "security_expert" /* SECURITY_EXPERT */;
        } else if (roleName.includes("product") || roleName.includes("manager")) {
          assignee = "product_manager" /* PRODUCT_MANAGER */;
        }
      }
      const dependsOn = [];
      const dependsMatch = taskDescription.match(/depends on:?\s+(.+?)(?=\n|$)/i);
      if (dependsMatch) {
        const dependencies = dependsMatch[1].split(",").map((d) => d.trim());
        dependencies.forEach((dep) => {
          const depId = dep.match(/(\d+)/);
          if (depId) {
            dependsOn.push(`task${depId[1]}`);
          }
        });
      }
      tasks.push({
        id: `task${taskId}`,
        description: taskDescription.replace(/assignee:?\s+\w+/i, "").replace(/depends on:?\s+.+?(?=\n|$)/i, "").trim(),
        assignee,
        status: "pending",
        dependsOn,
        artifacts: []
      });
      taskId++;
    }
    return tasks;
  }
  /**
   * Run the development phase
   */
  async runDevelopmentPhase(options2) {
    const developer = this.getAgentByRole("developer" /* DEVELOPER */);
    if (!developer) {
      throw new Error("Developer agent not found");
    }
    const architectureDesign = this.artifacts.find((a) => a.name === "architecture_design");
    if (!architectureDesign) {
      throw new Error("Architecture design artifact not found");
    }
    const developerTasks = this.tasks.filter(
      (task) => task.assignee === "developer" /* DEVELOPER */ && task.status === "pending"
    );
    const completedTaskIds = [];
    for (const task of developerTasks) {
      const unsatisfiedDependencies = task.dependsOn.filter((depId) => !completedTaskIds.includes(depId));
      if (unsatisfiedDependencies.length > 0) {
        continue;
      }
      task.status = "in_progress";
      const taskDescription = `Implement the following task:
      
${task.description}

Based on the architectural design:

${architectureDesign.content}

Write the necessary code to implement this functionality. Include:
1. Well-structured code with appropriate comments
2. Error handling and edge cases
3. Explanations of key implementation decisions

Focus on quality, readability, and adherence to architectural guidelines.`;
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Development Task: ${task.id}`,
          description: task.description,
          status: "started"
        });
      }
      const codeArtifact = await this.generateArtifactFromAgent(
        developer,
        `code_${task.id}`,
        "code",
        taskDescription,
        options2
      );
      task.artifacts.push(codeArtifact.name);
      task.status = "completed";
      completedTaskIds.push(task.id);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Development Task: ${task.id}`,
          description: task.description,
          status: "completed"
        });
      }
    }
    const securityExpert = this.getAgentByRole("security_expert" /* SECURITY_EXPERT */);
    if (securityExpert) {
      const codeArtifacts = this.getArtifactsByType("code");
      const securityReviewInput = `Perform a security review on the following code artifacts:
      
${codeArtifacts.map((a) => `${a.name}:
${a.content}

`).join("")}

Identify any security issues or vulnerabilities, including:
1. Input validation issues
2. Authentication/authorization weaknesses
3. Data protection concerns
4. General security best practices not being followed

Provide specific recommendations for addressing each issue.`;
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Security Review",
          description: "Performing security analysis of code artifacts",
          status: "started"
        });
      }
      const securityReview = await this.generateArtifactFromAgent(
        securityExpert,
        "security_review",
        "security",
        securityReviewInput,
        options2
      );
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Security Review",
          description: "Security analysis completed",
          status: "completed"
        });
      }
      if (securityReview.content.toLowerCase().includes("issue") || securityReview.content.toLowerCase().includes("vulnerabilit")) {
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: "Security Fixes",
            description: "Addressing security issues identified in review",
            status: "started"
          });
        }
        for (const codeArtifact of codeArtifacts) {
          const securityFixInput = `Fix the security issues identified in this code:
          
${codeArtifact.content}

According to this security review:

${securityReview.content}

Update the code to address all security concerns while maintaining functionality.`;
          const updatedCodeArtifact = await this.generateArtifactFromAgent(
            developer,
            `${codeArtifact.name}_secure`,
            "code",
            securityFixInput,
            options2
          );
          codeArtifact.content = updatedCodeArtifact.content;
          codeArtifact.comments.push({
            role: securityExpert.role,
            comment: "Updated with security fixes",
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          });
        }
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: "Security Fixes",
            description: "Security issues addressed in code",
            status: "completed"
          });
        }
      }
    }
  }
  /**
   * Run the testing phase
   */
  async runTestingPhase(options2) {
    const tester = this.getAgentByRole("tester" /* TESTER */);
    if (!tester) {
      throw new Error("Tester agent not found");
    }
    const codeArtifacts = this.getArtifactsByType("code");
    if (options2.callbacks?.onStep) {
      options2.callbacks.onStep({
        name: "Test Plan Creation",
        description: "Creating comprehensive test plan",
        status: "started"
      });
    }
    const testPlanInput = `Create a comprehensive test plan for the following code:
    
${codeArtifacts.map((a) => `${a.name}:
${a.content}

`).join("")}

Include:
1. Test strategy and approach
2. Types of tests to implement (unit, integration, etc.)
3. Test coverage goals
4. Key test scenarios and cases
5. Any specific test frameworks or tools to use

The test plan should be thorough but realistic.`;
    const testPlan = await this.generateArtifactFromAgent(
      tester,
      "test_plan",
      "test",
      testPlanInput,
      options2
    );
    if (options2.callbacks?.onStep) {
      options2.callbacks.onStep({
        name: "Test Plan Creation",
        description: "Test plan created",
        status: "completed"
      });
    }
    for (const codeArtifact of codeArtifacts) {
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Test Implementation: ${codeArtifact.name}`,
          description: `Creating tests for ${codeArtifact.name}`,
          status: "started"
        });
      }
      const testImplementationInput = `Create tests for the following code:
      
${codeArtifact.content}

Based on this test plan:
${testPlan.content}

Implement comprehensive tests that:
1. Verify correct functionality
2. Test edge cases and error conditions
3. Achieve good code coverage
4. Are readable and maintainable

Use appropriate testing frameworks and patterns.`;
      const testArtifact = await this.generateArtifactFromAgent(
        tester,
        `tests_for_${codeArtifact.name}`,
        "test",
        testImplementationInput,
        options2
      );
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Test Implementation: ${codeArtifact.name}`,
          description: `Tests created for ${codeArtifact.name}`,
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Test Execution: ${testArtifact.name}`,
          description: `Running tests for ${codeArtifact.name}`,
          status: "started"
        });
      }
      const testExecutionInput = `Review these tests and simulate their execution:
      
${testArtifact.content}

For the following code:
${codeArtifact.content}

Provide the test results including:
1. Which tests passed or failed
2. Any issues or bugs discovered
3. Test coverage analysis
4. Recommendations for code improvements based on test results

Be thorough and realistic in your assessment.`;
      const testResults = await this.generateArtifactFromAgent(
        tester,
        `test_results_for_${codeArtifact.name}`,
        "test",
        testExecutionInput,
        options2
      );
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Test Execution: ${testArtifact.name}`,
          description: `Tests executed for ${codeArtifact.name}`,
          status: "completed"
        });
      }
      if (testResults.content.toLowerCase().includes("fail") || testResults.content.toLowerCase().includes("issue") || testResults.content.toLowerCase().includes("bug")) {
        const developer = this.getAgentByRole("developer" /* DEVELOPER */);
        if (!developer) {
          throw new Error("Developer agent not found");
        }
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: `Bug Fixing: ${codeArtifact.name}`,
            description: `Fixing issues discovered in testing`,
            status: "started"
          });
        }
        const bugFixInput = `Fix the issues discovered during testing:
        
Code:
${codeArtifact.content}

Test Results:
${testResults.content}

Update the code to fix all issues while ensuring it still meets requirements.
Explain the changes you're making and why they address the problems.`;
        const fixedCodeArtifact = await this.generateArtifactFromAgent(
          developer,
          `${codeArtifact.name}_fixed`,
          "code",
          bugFixInput,
          options2
        );
        codeArtifact.content = fixedCodeArtifact.content;
        codeArtifact.comments.push({
          role: developer.role,
          comment: "Fixed issues discovered in testing",
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: `Bug Fixing: ${codeArtifact.name}`,
            description: `Issues fixed in ${codeArtifact.name}`,
            status: "completed"
          });
        }
      }
    }
  }
  /**
   * Run the review phase
   */
  async runReviewPhase(options2) {
    const reviewer = this.getAgentByRole("reviewer" /* REVIEWER */);
    if (!reviewer) {
      throw new Error("Reviewer agent not found");
    }
    const codeArtifacts = this.getArtifactsByType("code");
    for (const codeArtifact of codeArtifacts) {
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Code Review: ${codeArtifact.name}`,
          description: `Reviewing ${codeArtifact.name}`,
          status: "started"
        });
      }
      const reviewInput = `Review the following code:
      
${codeArtifact.content}

Evaluate the code for:
1. Code quality and readability
2. Adherence to best practices
3. Performance considerations
4. Potential bugs or edge cases
5. Overall design and structure

Provide constructive feedback and specific recommendations for improvement.`;
      const reviewArtifact = await this.generateArtifactFromAgent(
        reviewer,
        `review_for_${codeArtifact.name}`,
        "review",
        reviewInput,
        options2
      );
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Code Review: ${codeArtifact.name}`,
          description: `Review completed for ${codeArtifact.name}`,
          status: "completed"
        });
      }
      codeArtifact.comments.push({
        role: reviewer.role,
        comment: `Review comments: ${reviewArtifact.content.slice(0, 100)}...`,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
      if (reviewArtifact.content.toLowerCase().includes("should") || reviewArtifact.content.toLowerCase().includes("improve") || reviewArtifact.content.toLowerCase().includes("fix")) {
        const developer = this.getAgentByRole("developer" /* DEVELOPER */);
        if (!developer) {
          throw new Error("Developer agent not found");
        }
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: `Review Fixes: ${codeArtifact.name}`,
            description: `Addressing review feedback for ${codeArtifact.name}`,
            status: "started"
          });
        }
        const reviewFixInput = `Address the review feedback for this code:
        
Code:
${codeArtifact.content}

Review Feedback:
${reviewArtifact.content}

Update the code to address the reviewer's comments and improve quality.
Explain the changes you're making and how they address the feedback.`;
        const revisedCodeArtifact = await this.generateArtifactFromAgent(
          developer,
          `${codeArtifact.name}_revised`,
          "code",
          reviewFixInput,
          options2
        );
        codeArtifact.content = revisedCodeArtifact.content;
        codeArtifact.comments.push({
          role: developer.role,
          comment: "Updated based on review feedback",
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        if (options2.callbacks?.onStep) {
          options2.callbacks.onStep({
            name: `Review Fixes: ${codeArtifact.name}`,
            description: `Review feedback addressed for ${codeArtifact.name}`,
            status: "completed"
          });
        }
      }
    }
  }
  /**
   * Run the documentation phase
   */
  async runDocumentationPhase(options2) {
    const documenter = this.getAgentByRole("documenter" /* DOCUMENTER */);
    if (!documenter) {
      throw new Error("Documenter agent not found");
    }
    if (options2.callbacks?.onStep) {
      options2.callbacks.onStep({
        name: "API Documentation",
        description: "Creating API and code documentation",
        status: "started"
      });
    }
    const codeArtifacts = this.getArtifactsByType("code");
    const apiDocInput = `Create comprehensive API and code documentation for:
    
${codeArtifacts.map((a) => `${a.name}:
${a.content}

`).join("")}

Include:
1. Overview of each component/module
2. Function/method documentation with parameters and return values
3. Usage examples
4. Data structures and types
5. Any important implementation notes

The documentation should be clear, concise, and helpful for developers.`;
    const apiDocumentation = await this.generateArtifactFromAgent(
      documenter,
      "api_documentation",
      "documentation",
      apiDocInput,
      options2
    );
    if (options2.callbacks?.onStep) {
      options2.callbacks.onStep({
        name: "API Documentation",
        description: "API documentation created",
        status: "completed"
      });
    }
    if (options2.callbacks?.onStep) {
      options2.callbacks.onStep({
        name: "User Documentation",
        description: "Creating user/installation documentation",
        status: "started"
      });
    }
    const userDocInput = `Create user and installation documentation for this project:
    
Project Overview:
${this.projectContext}

Include:
1. Project overview and purpose
2. Installation instructions
3. Configuration options
4. Basic usage examples
5. Troubleshooting tips

Format this as a comprehensive README that would help users understand and use the project.`;
    const userDocumentation = await this.generateArtifactFromAgent(
      documenter,
      "user_documentation",
      "documentation",
      userDocInput,
      options2
    );
    if (options2.callbacks?.onStep) {
      options2.callbacks.onStep({
        name: "User Documentation",
        description: "User documentation created",
        status: "completed"
      });
    }
  }
  /**
   * Generate a project summary
   */
  async generateProjectSummary(options2) {
    let summaryAgent;
    const productManager = this.getAgentByRole("product_manager" /* PRODUCT_MANAGER */);
    const architect = this.getAgentByRole("architect" /* ARCHITECT */);
    summaryAgent = productManager || architect;
    const summaryInput = `Create a comprehensive project summary for:
    
Project Overview:
${this.projectContext}

Key Artifacts:
${this.artifacts.map((a) => `- ${a.name} (${a.type}): ${a.content.slice(0, 100)}...`).join("\n")}

Include:
1. Executive summary of the project
2. Key features implemented
3. Technical architecture overview
4. Quality assurance measures
5. Future work or recommendations

This should serve as a complete overview of the project deliverables and process.`;
    const summaryArtifact = await this.generateArtifactFromAgent(
      summaryAgent,
      "project_summary",
      "documentation",
      summaryInput,
      options2
    );
    this.projectSummary = summaryArtifact.content;
  }
  /**
   * Generate an artifact from an agent
   */
  async generateArtifactFromAgent(agent2, name, type, input2, options2) {
    const content2 = await this.getAgentResponse(agent2, input2);
    const artifact = {
      name,
      type,
      content: content2,
      author: agent2.role,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      status: "approved",
      comments: []
    };
    this.artifacts.push(artifact);
    return artifact;
  }
  /**
   * Get a response from an agent
   */
  async getAgentResponse(agent2, prompt) {
    const fullPrompt = `${agent2.systemPrompt}

${prompt}`;
    return await this.getResponseFromLLM(fullPrompt);
  }
  /**
   * Get an agent by role
   */
  getAgentByRole(role) {
    return this.agents.find((a) => a.role === role);
  }
  /**
   * Get artifacts by type
   */
  getArtifactsByType(type) {
    return this.artifacts.filter((a) => a.type === type);
  }
  /**
   * Get the tool calls history
   */
  getToolCallsHistory() {
    return void 0;
  }
  /**
   * Get response from the appropriate LLM based on model name
   */
  async getResponseFromLLM(prompt) {
    try {
      if (this.config.modelName?.includes("claude")) {
        return await this.getResponseFromClaude(prompt);
      } else if (this.config.modelName?.includes("gpt")) {
        return await this.getResponseFromOpenAI(prompt);
      } else {
        return await this.getResponseFromClaude(prompt);
      }
    } catch (error) {
      log(`Error getting LLM response: ${error}`, "agent");
      throw error;
    }
  }
  /**
   * Get response from Claude
   */
  async getResponseFromClaude(prompt) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: this.config.systemPrompt,
      messages: [{ role: "user", content: prompt }]
    });
    return response.content[0].text;
  }
  /**
   * Get response from OpenAI
   */
  async getResponseFromOpenAI(prompt) {
    if (!this.openaiClient) {
      throw new Error("OpenAI client not initialized");
    }
    const response = await this.openaiClient.chat.completions.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      messages: [
        { role: "system", content: this.config.systemPrompt },
        { role: "user", content: prompt }
      ]
    });
    return response.choices[0].message.content || "";
  }
  /**
   * Get available tools
   */
  getAvailableTools() {
    return this.availableTools;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.tools) {
      this.availableTools = config.tools;
    }
  }
  /**
   * Get supported execution modes
   */
  getSupportedExecutionModes() {
    return ["synchronous" /* SYNCHRONOUS */, "asynchronous" /* ASYNCHRONOUS */];
  }
  /**
   * Check if protocol supports a specific capability
   */
  supportsCapability(capability) {
    return this.config.capabilities.includes(capability);
  }
  /**
   * Get current protocol configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    this.agents = [];
    this.artifacts = [];
    this.tasks = [];
    this.projectContext = "";
    this.currentPhase = "planning";
    this.projectSummary = "";
    this.initialized = false;
    return Promise.resolve();
  }
};

// server/services/agent/protocols/QodoPRAgentProtocol.ts
import Anthropic18 from "@anthropic-ai/sdk";
import OpenAI10 from "openai";
var DEFAULT_MODEL16 = "claude-3-7-sonnet-20250219";
var QodoPRAgentProtocol = class {
  config = {
    systemPrompt: `You are Qodo PR-Agent, an intelligent code reviewer for GitHub Pull Requests.
Your goal is to thoroughly analyze code changes and provide valuable feedback.
You excel at understanding context, identifying potential issues, and suggesting quality improvements.`,
    tools: [],
    modelName: DEFAULT_MODEL16,
    temperature: 0.3,
    maxTokens: 2048,
    capabilities: [
      "tool_use" /* TOOL_USE */,
      "code_execution" /* CODE_EXECUTION */,
      "multi_step" /* MULTI_STEP */
    ]
  };
  anthropicClient = null;
  openaiClient = null;
  availableTools = [];
  initialized = false;
  // PR state
  prFiles = [];
  prMetadata = null;
  prReview = null;
  codebaseContext = "";
  /**
   * Get metadata about this protocol
   */
  getMetadata() {
    return {
      name: "Qodo PR-Agent",
      version: "1.0.0",
      description: "GitHub Pull Request auto-summarizer and reviewer",
      capabilities: [
        "tool_use" /* TOOL_USE */,
        "code_execution" /* CODE_EXECUTION */,
        "multi_step" /* MULTI_STEP */
      ],
      requiresAuthentication: true,
      supportedModels: [
        "claude-3-7-sonnet-20250219",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "gpt-4o",
        "gpt-4-turbo",
        "gpt-4"
      ]
    };
  }
  /**
   * Initialize the protocol with configuration
   */
  async init(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (this.config.modelName?.includes("claude")) {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY environment variable is required for Claude models");
      }
      this.anthropicClient = new Anthropic18({
        apiKey: process.env.ANTHROPIC_API_KEY
      });
    } else if (this.config.modelName?.includes("gpt")) {
      if (!process.env.OPENAI_API_KEY) {
        throw new Error("OPENAI_API_KEY environment variable is required for OpenAI models");
      }
      this.openaiClient = new OpenAI10({
        apiKey: process.env.OPENAI_API_KEY
      });
    }
    this.availableTools = this.config.tools || [];
    this.prFiles = [];
    this.prMetadata = null;
    this.prReview = null;
    this.codebaseContext = "";
    this.initialized = true;
  }
  /**
   * Execute a task using this protocol
   */
  async execute(options2) {
    if (!this.initialized) {
      throw new Error("Protocol not initialized. Call init() first.");
    }
    const startTime2 = Date.now();
    try {
      if (options2.callbacks?.onStart) {
        options2.callbacks.onStart();
      }
      await this.parsePRInfo(options2.task, options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "PR Analysis",
          description: "Analyzing PR files and changes",
          status: "started"
        });
      }
      await this.analyzePRFiles(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "PR Analysis",
          description: "PR files analyzed",
          output: { filesAnalyzed: this.prFiles.length },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "PR Summary Generation",
          description: "Generating concise PR summary",
          status: "started"
        });
      }
      await this.generatePRSummary(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "PR Summary Generation",
          description: "PR summary generated",
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Code Review",
          description: "Reviewing code quality and suggesting improvements",
          status: "started"
        });
      }
      await this.conductCodeReview(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Code Review",
          description: "Code review completed",
          output: {
            suggestions: this.prReview?.suggestions.length || 0,
            codeQuality: this.prReview?.codeQuality || 0
          },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Final Report",
          description: "Generating final PR review report",
          status: "started"
        });
      }
      const finalReport = await this.generateFinalReport(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Final Report",
          description: "Final PR review report generated",
          status: "completed"
        });
      }
      const agentResponse = {
        response: {
          content: finalReport,
          toolCalls: this.getToolCallsHistory()
        },
        executionTime: Date.now() - startTime2,
        protocol: "qodopr",
        metadata: {
          filesReviewed: this.prFiles.length,
          suggestions: this.prReview?.suggestions.length || 0,
          codeQuality: this.prReview?.codeQuality || 0
        }
      };
      if (options2.callbacks?.onComplete) {
        options2.callbacks.onComplete(agentResponse);
      }
      return agentResponse;
    } catch (error) {
      log(`Qodo PR-Agent Protocol execution error: ${error}`, "agent");
      if (options2.callbacks?.onError) {
        options2.callbacks.onError(error);
      }
      throw error;
    }
  }
  /**
   * Parse PR information from the task
   */
  async parsePRInfo(task, options2) {
    const titleMatch = task.match(/Title:?\s*([^\n]+)/i);
    const descriptionMatch = task.match(/Description:?\s*([^\n]+(?:\n(?!\n)[^\n]+)*)/i);
    const authorMatch = task.match(/Author:?\s*([^\n]+)/i);
    const branchMatch = task.match(/Branch:?\s*([^\n]+)/i) || task.match(/Head Branch:?\s*([^\n]+)/i);
    const baseBranchMatch = task.match(/Base Branch:?\s*([^\n]+)/i);
    const filesChangedMatch = task.match(/Files Changed:?\s*(\d+)/i);
    const additionsMatch = task.match(/Additions:?\s*(\d+)/i);
    const deletionsMatch = task.match(/Deletions:?\s*(\d+)/i);
    const repoMatch = task.match(/Repository:?\s*([^\n]+)/i) || task.match(/Repo:?\s*([^\n]+)/i);
    const filePatches = [];
    const fileRegex = /File: ([^\n]+)\nStatus: (added|modified|deleted)\nPatch:\n```(?:diff)?\n([\s\S]+?)```/gi;
    let fileMatch;
    while ((fileMatch = fileRegex.exec(task)) !== null) {
      filePatches.push({
        filename: fileMatch[1].trim(),
        status: fileMatch[2],
        patch: fileMatch[3]
      });
    }
    this.prMetadata = {
      title: titleMatch ? titleMatch[1].trim() : "Untitled PR",
      description: descriptionMatch ? descriptionMatch[1].trim() : "No description provided",
      author: authorMatch ? authorMatch[1].trim() : "Unknown",
      baseBranch: baseBranchMatch ? baseBranchMatch[1].trim() : "main",
      headBranch: branchMatch ? branchMatch[1].trim() : "feature-branch",
      filesChanged: filesChangedMatch ? parseInt(filesChangedMatch[1]) : filePatches.length,
      additions: additionsMatch ? parseInt(additionsMatch[1]) : 0,
      deletions: deletionsMatch ? parseInt(deletionsMatch[1]) : 0,
      repositoryUrl: repoMatch ? repoMatch[1].trim() : void 0
    };
    this.prFiles = filePatches;
    if (this.prFiles.length === 0) {
      const githubTool = this.availableTools.find(
        (tool) => tool.name.includes("github") || tool.name.includes("git") || tool.name.includes("repo")
      );
      if (githubTool) {
        await this.fetchPRFilesWithTool(githubTool, task, options2);
      } else {
        this.createSyntheticFileEntries();
      }
    }
    await this.fetchCodebaseContext(options2);
  }
  /**
   * Fetch PR files using GitHub API tool
   */
  async fetchPRFilesWithTool(githubTool, task, options2) {
    try {
      const prNumberMatch = task.match(/PR #?(\d+)/i) || task.match(/Pull Request #?(\d+)/i);
      const repoMatch = task.match(/repository:?\s*([^\n]+)/i) || task.match(/repo:?\s*([^\n]+)/i);
      if (!prNumberMatch || !repoMatch) {
        throw new Error("Could not extract PR number and repository from task");
      }
      const prNumber = prNumberMatch[1];
      const repository = repoMatch[1].trim();
      const toolParams = {
        repo: repository,
        prNumber: parseInt(prNumber),
        includeContent: true
      };
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: githubTool.name,
          input: toolParams,
          output: void 0,
          error: void 0
        });
      }
      const prData = await githubTool.execute(toolParams);
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: githubTool.name,
          input: toolParams,
          output: prData,
          error: void 0
        });
      }
      if (prData) {
        if (prData.title) {
          this.prMetadata.title = prData.title;
        }
        if (prData.description) {
          this.prMetadata.description = prData.description;
        }
        if (prData.author) {
          this.prMetadata.author = prData.author;
        }
        if (prData.files && Array.isArray(prData.files)) {
          this.prFiles = prData.files.map((file) => ({
            filename: file.filename,
            status: file.status,
            patch: file.patch || "",
            content: file.content
          }));
        }
      }
    } catch (error) {
      log(`Error fetching PR files with GitHub tool: ${error}`, "agent");
    }
  }
  /**
   * Create synthetic file entries based on PR description if no files are found
   */
  createSyntheticFileEntries() {
    if (!this.prMetadata) return;
    const fileRegex = /(?:(?:added|modified|deleted|changed)\s+)?([a-zA-Z0-9_/.-]+\.[a-zA-Z0-9]+)/gi;
    const matches = [...this.prMetadata.description.matchAll(fileRegex)];
    const fileNames = [...new Set(matches.map((match) => match[1]))];
    if (fileNames.length > 0) {
      this.prFiles = fileNames.map((filename) => ({
        filename,
        status: "modified",
        patch: "File content not available"
      }));
    } else {
      this.prFiles = [
        {
          filename: "src/main.js",
          status: "modified",
          patch: "File content not available"
        }
      ];
    }
  }
  /**
   * Fetch codebase context if available
   */
  async fetchCodebaseContext(options2) {
    const codebaseTool = this.availableTools.find(
      (tool) => tool.name.includes("codebase") || tool.name.includes("repo_context") || tool.name.includes("code_context")
    );
    if (!codebaseTool || !this.prMetadata?.repositoryUrl) {
      return;
    }
    try {
      const toolParams = {
        repo: this.prMetadata.repositoryUrl,
        maxFiles: 5
        // Limit to avoid overwhelming the context
      };
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: codebaseTool.name,
          input: toolParams,
          output: void 0,
          error: void 0
        });
      }
      const codebaseData = await codebaseTool.execute(toolParams);
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: codebaseTool.name,
          input: toolParams,
          output: codebaseData,
          error: void 0
        });
      }
      if (codebaseData && typeof codebaseData === "object") {
        this.codebaseContext = Object.entries(codebaseData).map(([filename, content2]) => `File: ${filename}
\`\`\`
${content2}
\`\`\``).join("\n\n");
      }
    } catch (error) {
      log(`Error fetching codebase context: ${error}`, "agent");
    }
  }
  /**
   * Analyze the PR files
   */
  async analyzePRFiles(options2) {
    if (this.prFiles.length === 0) {
      return;
    }
    const fileGroups = this.groupFilesByType();
    for (const [fileType, files] of Object.entries(fileGroups)) {
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Analyzing ${fileType} Files`,
          description: `Analyzing ${files.length} ${fileType} files`,
          status: "started"
        });
      }
      await this.analyzeFileGroup(fileType, files, options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Analyzing ${fileType} Files`,
          description: `Analyzed ${files.length} ${fileType} files`,
          status: "completed"
        });
      }
    }
  }
  /**
   * Group files by type for more efficient analysis
   */
  groupFilesByType() {
    const fileGroups = {};
    for (const file of this.prFiles) {
      const extension = file.filename.split(".").pop() || "unknown";
      let fileType = "other";
      if (["js", "ts", "jsx", "tsx"].includes(extension)) {
        fileType = "javascript";
      } else if (["py"].includes(extension)) {
        fileType = "python";
      } else if (["java", "kt"].includes(extension)) {
        fileType = "java";
      } else if (["rb"].includes(extension)) {
        fileType = "ruby";
      } else if (["go"].includes(extension)) {
        fileType = "go";
      } else if (["php"].includes(extension)) {
        fileType = "php";
      } else if (["cs"].includes(extension)) {
        fileType = "csharp";
      } else if (["html", "css", "scss", "less"].includes(extension)) {
        fileType = "frontend";
      } else if (["json", "yaml", "yml", "xml", "toml"].includes(extension)) {
        fileType = "config";
      } else if (["md", "txt", "rst"].includes(extension)) {
        fileType = "docs";
      }
      if (!fileGroups[fileType]) {
        fileGroups[fileType] = [];
      }
      fileGroups[fileType].push(file);
    }
    return fileGroups;
  }
  /**
   * Analyze a group of files
   */
  async analyzeFileGroup(fileType, files, options2) {
    const analysisPrompt = `Analyze the following ${fileType} files from a Pull Request:
    
${files.map((file) => `File: ${file.filename}
Status: ${file.status}
Patch:
\`\`\`
${file.patch}
\`\`\`

${file.content ? `Full Content:
\`\`\`
${file.content}
\`\`\`
` : ""}
`).join("\n\n")}

${this.codebaseContext ? `
Codebase context:
${this.codebaseContext}` : ""}

Provide a detailed analysis of each file including:
1. What changed in the file
2. Why the change was made (based on code context and PR description)
3. Potential impact of these changes
4. Any potential issues, bugs, or improvements

The PR description is:
${this.prMetadata?.description || "No description provided"}`;
    const analysis = await this.getResponseFromLLM(analysisPrompt);
    for (const file of files) {
      file.analysis = analysis;
    }
  }
  /**
   * Generate PR summary
   */
  async generatePRSummary(options2) {
    if (!this.prMetadata) return;
    const summaryPrompt = `Create a concise summary for this Pull Request:
    
Title: ${this.prMetadata.title}
Description: ${this.prMetadata.description}
Author: ${this.prMetadata.author}
Files Changed: ${this.prMetadata.filesChanged}
Additions: ${this.prMetadata.additions}
Deletions: ${this.prMetadata.deletions}

${this.prFiles.length > 0 ? `Files in the PR:
${this.prFiles.map((file) => `- ${file.filename} (${file.status})`).join("\n")}` : ""}

${this.prFiles.some((file) => file.analysis) ? `File analyses:
${this.prFiles.filter((file) => file.analysis).map((file) => `File: ${file.filename}
Analysis: ${file.analysis}`).join("\n\n")}` : ""}

Create a 2-3 paragraph summary that:
1. Clearly explains what this PR does
2. Identifies the main components changed
3. Explains why these changes were made
4. Notes any significant implementation details

Use a professional, clear style. Be concise but thorough.`;
    const summaryResponse = await this.getResponseFromLLM(summaryPrompt);
    this.prReview = {
      summary: summaryResponse,
      description: "PR review in progress",
      codeQuality: 0,
      bugRisk: 0,
      suggestions: [],
      overallFeedback: ""
    };
  }
  /**
   * Conduct code review
   */
  async conductCodeReview(options2) {
    if (!this.prMetadata || !this.prReview) return;
    if (this.prFiles.length === 0) {
      this.prReview.description = "No files to review";
      this.prReview.codeQuality = 5;
      this.prReview.bugRisk = 0;
      this.prReview.overallFeedback = "No code changes to review";
      return;
    }
    const reviewPrompt = `Conduct a thorough code review for this Pull Request:
    
Title: ${this.prMetadata.title}
Description: ${this.prMetadata.description}

Files to review:
${this.prFiles.map((file) => `File: ${file.filename}
Status: ${file.status}
Patch:
\`\`\`
${file.patch}
\`\`\`
`).join("\n\n")}

Conduct a comprehensive code review that:
1. Identifies potential bugs, edge cases, or errors
2. Suggests code quality improvements (readability, maintainability)
3. Points out performance considerations
4. Checks for security issues
5. Reviews test coverage (if applicable)

For each suggestion, provide:
- The specific file and line number (if possible)
- A clear description of the issue
- The impact level (high/medium/low)
- A concrete suggestion for improvement

Also provide:
- A code quality score (1-10)
- A bug risk assessment (1-10)
- Overall constructive feedback

Be thorough but fair in your assessment.`;
    const reviewResponse = await this.getResponseFromLLM(reviewPrompt);
    const qualityMatch = reviewResponse.match(/code quality score:?\s*(\d+)/i) || reviewResponse.match(/quality score:?\s*(\d+)/i) || reviewResponse.match(/quality:?\s*(\d+)/i);
    const bugRiskMatch = reviewResponse.match(/bug risk:?\s*(\d+)/i) || reviewResponse.match(/risk assessment:?\s*(\d+)/i) || reviewResponse.match(/risk:?\s*(\d+)/i);
    const feedbackMatch = reviewResponse.match(/overall feedback:?\s*([\s\S]+?)(?=\n\n|$)/i) || reviewResponse.match(/overall:?\s*([\s\S]+?)(?=\n\n|$)/i);
    const suggestions = [];
    const suggestionBlocks = reviewResponse.match(/suggestion(?:[^:]*):?(?:[\s\S]*?)(?=suggestion|$)/gi) || [];
    for (const block of suggestionBlocks) {
      const fileMatch = block.match(/file:?\s*([^\n]+)/i);
      const lineMatch = block.match(/line:?\s*(\d+)/i) || block.match(/line number:?\s*(\d+)/i);
      const impactMatch = block.match(/impact:?\s*(high|medium|low)/i);
      const typeMatch = block.match(/type:?\s*(improvement|bug|security|performance|style|documentation)/i);
      const suggestionMatch = block.match(/(?:description|details|issue|problem):?\s*([^\n]+(?:\n(?!\n)[^\n]+)*)/i);
      if (fileMatch && suggestionMatch) {
        suggestions.push({
          file: fileMatch[1].trim(),
          lineNumber: lineMatch ? parseInt(lineMatch[1]) : void 0,
          suggestion: suggestionMatch[1].trim(),
          impact: impactMatch ? impactMatch[1].toLowerCase() : "medium",
          type: typeMatch ? typeMatch[1].toLowerCase() : "improvement"
        });
      }
    }
    this.prReview.description = reviewResponse;
    this.prReview.codeQuality = qualityMatch ? Math.min(Math.max(parseInt(qualityMatch[1]), 1), 10) : 5;
    this.prReview.bugRisk = bugRiskMatch ? Math.min(Math.max(parseInt(bugRiskMatch[1]), 0), 10) : 0;
    this.prReview.overallFeedback = feedbackMatch ? feedbackMatch[1].trim() : "No overall feedback provided";
    this.prReview.suggestions = suggestions;
  }
  /**
   * Generate final PR review report
   */
  async generateFinalReport(options2) {
    if (!this.prMetadata || !this.prReview) {
      return "Unable to generate PR review report due to missing data";
    }
    let report = `# PR Review: ${this.prMetadata.title}

`;
    report += `## Pull Request Information
`;
    report += `- **Title**: ${this.prMetadata.title}
`;
    report += `- **Author**: ${this.prMetadata.author}
`;
    report += `- **Branch**: ${this.prMetadata.headBranch} \u2192 ${this.prMetadata.baseBranch}
`;
    report += `- **Files Changed**: ${this.prMetadata.filesChanged}
`;
    report += `- **Lines Added**: ${this.prMetadata.additions}
`;
    report += `- **Lines Deleted**: ${this.prMetadata.deletions}

`;
    report += `## Summary
${this.prReview.summary}

`;
    report += `## Code Review Metrics
`;
    report += `- **Code Quality**: ${this.prReview.codeQuality}/10
`;
    report += `- **Bug Risk**: ${this.prReview.bugRisk}/10

`;
    if (this.prReview.suggestions.length > 0) {
      report += `## Suggestions

`;
      const suggestionsByFile = {};
      for (const suggestion of this.prReview.suggestions) {
        if (!suggestionsByFile[suggestion.file]) {
          suggestionsByFile[suggestion.file] = [];
        }
        suggestionsByFile[suggestion.file].push(suggestion);
      }
      for (const [file, suggestions] of Object.entries(suggestionsByFile)) {
        report += `### File: ${file}

`;
        for (const suggestion of suggestions) {
          const impact = suggestion.impact === "high" ? "\u{1F534}" : suggestion.impact === "medium" ? "\u{1F7E0}" : "\u{1F7E1}";
          const type = suggestion.type.charAt(0).toUpperCase() + suggestion.type.slice(1);
          report += `${impact} **${type}**${suggestion.lineNumber ? ` (Line ${suggestion.lineNumber})` : ""}
`;
          report += `${suggestion.suggestion}

`;
        }
      }
    }
    report += `## Overall Feedback
${this.prReview.overallFeedback}

`;
    const nextStepsPrompt = `Based on the PR review summary:

${this.prReview.summary}

And the suggestions:
${this.prReview.suggestions.map((s) => `- ${s.suggestion} (${s.impact} impact)`).join("\n")}

Generate a concise "Next Steps" section with 3-5 bullet points recommending what the author should do next to improve this PR.`;
    const nextSteps = await this.getResponseFromLLM(nextStepsPrompt);
    report += `## Next Steps
${nextSteps}

`;
    report += `---
*Review generated by Qodo PR-Agent*
`;
    return report;
  }
  /**
   * Get the tool calls history
   */
  getToolCallsHistory() {
    return void 0;
  }
  /**
   * Get response from the appropriate LLM based on model name
   */
  async getResponseFromLLM(prompt) {
    try {
      if (this.config.modelName?.includes("claude")) {
        return await this.getResponseFromClaude(prompt);
      } else if (this.config.modelName?.includes("gpt")) {
        return await this.getResponseFromOpenAI(prompt);
      } else {
        return await this.getResponseFromClaude(prompt);
      }
    } catch (error) {
      log(`Error getting LLM response: ${error}`, "agent");
      throw error;
    }
  }
  /**
   * Get response from Claude
   */
  async getResponseFromClaude(prompt) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: this.config.systemPrompt,
      messages: [{ role: "user", content: prompt }]
    });
    return response.content[0].text;
  }
  /**
   * Get response from OpenAI
   */
  async getResponseFromOpenAI(prompt) {
    if (!this.openaiClient) {
      throw new Error("OpenAI client not initialized");
    }
    const response = await this.openaiClient.chat.completions.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      messages: [
        { role: "system", content: this.config.systemPrompt },
        { role: "user", content: prompt }
      ]
    });
    return response.choices[0].message.content || "";
  }
  /**
   * Get available tools
   */
  getAvailableTools() {
    return this.availableTools;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.tools) {
      this.availableTools = config.tools;
    }
  }
  /**
   * Get supported execution modes
   */
  getSupportedExecutionModes() {
    return ["synchronous" /* SYNCHRONOUS */];
  }
  /**
   * Check if protocol supports a specific capability
   */
  supportsCapability(capability) {
    return this.config.capabilities.includes(capability);
  }
  /**
   * Get current protocol configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    this.prFiles = [];
    this.prMetadata = null;
    this.prReview = null;
    this.codebaseContext = "";
    this.initialized = false;
    return Promise.resolve();
  }
};

// server/services/agent/protocols/MSAgentAutoBuilderProtocol.ts
import Anthropic19 from "@anthropic-ai/sdk";
import OpenAI11 from "openai";
var DEFAULT_MODEL17 = "claude-3-7-sonnet-20250219";
var MSAgentAutoBuilderProtocol = class {
  config = {
    systemPrompt: `You are Microsoft Agent AutoBuilder, specialized in dynamically creating AI agents tailored to specific tasks.
You excel at:
1. Analyzing task requirements and determining needed capabilities
2. Assembling custom agents with appropriate skills
3. Optimizing agent configurations for specific contexts
4. Generating effective prompts for specialized agents
5. Managing tool selection for maximum agent utility`,
    tools: [],
    modelName: DEFAULT_MODEL17,
    temperature: 0.3,
    maxTokens: 2048,
    capabilities: [
      "tool_use" /* TOOL_USE */,
      "self_improvement" /* SELF_IMPROVEMENT */,
      "multi_step" /* MULTI_STEP */
    ]
  };
  anthropicClient = null;
  openaiClient = null;
  availableTools = [];
  initialized = false;
  // Agent building state
  agentTemplates = [];
  availableSkills = [];
  builtAgent = null;
  taskAnalysis = "";
  executionResult = null;
  /**
   * Get metadata about this protocol
   */
  getMetadata() {
    return {
      name: "Microsoft Agent AutoBuilder",
      version: "1.0.0",
      description: "Dynamic agent assembly based on task requirements",
      capabilities: [
        "tool_use" /* TOOL_USE */,
        "self_improvement" /* SELF_IMPROVEMENT */,
        "multi_step" /* MULTI_STEP */
      ],
      requiresAuthentication: true,
      supportedModels: [
        "claude-3-7-sonnet-20250219",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "gpt-4o",
        "gpt-4-turbo",
        "gpt-4"
      ]
    };
  }
  /**
   * Initialize the protocol with configuration
   */
  async init(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (this.config.modelName?.includes("claude")) {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY environment variable is required for Claude models");
      }
      this.anthropicClient = new Anthropic19({
        apiKey: process.env.ANTHROPIC_API_KEY
      });
    } else if (this.config.modelName?.includes("gpt")) {
      if (!process.env.OPENAI_API_KEY) {
        throw new Error("OPENAI_API_KEY environment variable is required for OpenAI models");
      }
      this.openaiClient = new OpenAI11({
        apiKey: process.env.OPENAI_API_KEY
      });
    }
    this.availableTools = this.config.tools || [];
    this.initializeAgentTemplates();
    this.initializeAgentSkills();
    this.builtAgent = null;
    this.taskAnalysis = "";
    this.executionResult = null;
    this.initialized = true;
  }
  /**
   * Execute a task using this protocol
   */
  async execute(options2) {
    if (!this.initialized) {
      throw new Error("Protocol not initialized. Call init() first.");
    }
    const startTime2 = Date.now();
    try {
      if (options2.callbacks?.onStart) {
        options2.callbacks.onStart();
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Task Analysis",
          description: "Analyzing task requirements",
          status: "started"
        });
      }
      await this.analyzeTask(options2.task, options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Task Analysis",
          description: "Task requirements analyzed",
          output: { analysis: this.taskAnalysis },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Agent Building",
          description: "Constructing specialized agent",
          status: "started"
        });
      }
      await this.buildSpecializedAgent(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Agent Building",
          description: "Specialized agent built",
          output: {
            agentName: this.builtAgent?.name,
            skills: this.builtAgent?.skills.map((s) => s.name)
          },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Task Execution",
          description: "Executing task with specialized agent",
          status: "started"
        });
      }
      await this.executeWithSpecializedAgent(options2.task, options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Task Execution",
          description: "Task execution completed",
          output: {
            response: this.executionResult?.response?.substring(0, 100) + "...",
            toolCallCount: this.executionResult?.toolCalls?.length || 0
          },
          status: "completed"
        });
      }
      const finalResponse = this.formatFinalResponse();
      const toolCalls = this.executionResult?.toolCalls?.map((tc) => ({
        name: tc.tool,
        input: tc.input,
        output: tc.output
      }));
      const agentResponse = {
        response: {
          content: finalResponse,
          toolCalls: toolCalls?.length ? toolCalls : void 0
        },
        executionTime: Date.now() - startTime2,
        protocol: "msagentautobuilder",
        metadata: {
          agentName: this.builtAgent?.name,
          skills: this.builtAgent?.skills.map((s) => s.name),
          taskAnalysis: this.taskAnalysis
        }
      };
      if (options2.callbacks?.onComplete) {
        options2.callbacks.onComplete(agentResponse);
      }
      return agentResponse;
    } catch (error) {
      log(`Microsoft Agent AutoBuilder Protocol execution error: ${error}`, "agent");
      if (options2.callbacks?.onError) {
        options2.callbacks.onError(error);
      }
      throw error;
    }
  }
  /**
   * Initialize agent templates
   */
  initializeAgentTemplates() {
    this.agentTemplates = [
      {
        id: "general",
        name: "General Assistant",
        description: "Versatile assistant for general tasks",
        basePrompt: `You are a versatile AI assistant focused on helping users with a wide variety of tasks. 
Your goal is to be helpful, harmless, and honest in all your interactions.`,
        defaultTools: ["web_search", "calculator"],
        skillCompatibility: ["writing", "research", "planning", "analysis"]
      },
      {
        id: "developer",
        name: "Developer Assistant",
        description: "Specialized in software development tasks",
        basePrompt: `You are a software development assistant with expertise in programming, software architecture, and technical problem-solving.
Your goal is to help users write, debug, and improve code across various programming languages and frameworks.`,
        defaultTools: ["code_execution", "web_search", "file_manager"],
        skillCompatibility: ["coding", "debugging", "architecture", "database", "testing"]
      },
      {
        id: "researcher",
        name: "Research Assistant",
        description: "Specialized in information gathering and analysis",
        basePrompt: `You are a research assistant with expertise in finding, analyzing, and summarizing information.
Your goal is to help users conduct thorough research, synthesize data, and draw evidence-based conclusions.`,
        defaultTools: ["web_search", "document_analyzer", "citation_generator"],
        skillCompatibility: ["research", "analysis", "summarization", "academic", "critical_thinking"]
      },
      {
        id: "content_creator",
        name: "Content Creation Assistant",
        description: "Specialized in creating various types of content",
        basePrompt: `You are a content creation assistant with expertise in writing, editing, and formatting various types of content.
Your goal is to help users create engaging, well-structured, and polished content for different purposes and audiences.`,
        defaultTools: ["document_editor", "image_search"],
        skillCompatibility: ["writing", "editing", "storytelling", "seo", "marketing"]
      },
      {
        id: "data_analyst",
        name: "Data Analysis Assistant",
        description: "Specialized in data processing and analysis",
        basePrompt: `You are a data analysis assistant with expertise in processing, analyzing, and visualizing data.
Your goal is to help users extract insights from data, perform statistical analyses, and communicate findings clearly.`,
        defaultTools: ["calculator", "data_processor", "chart_generator"],
        skillCompatibility: ["statistics", "visualization", "analysis", "database", "modeling"]
      }
    ];
  }
  /**
   * Initialize agent skills
   */
  initializeAgentSkills() {
    this.availableSkills = [
      // Coding skills
      {
        id: "coding",
        name: "Code Generation",
        description: "Ability to write clean, efficient code in various programming languages",
        promptAddition: `You excel at writing clean, efficient, and well-documented code in various programming languages. 
You understand programming best practices, algorithms, and data structures.`,
        requiredTools: ["code_execution"]
      },
      {
        id: "debugging",
        name: "Debugging",
        description: "Ability to identify and fix issues in code",
        promptAddition: `You excel at debugging code by identifying issues, understanding error messages, and proposing fixes. 
You can methodically trace through code execution to pinpoint problems.`,
        requiredTools: ["code_execution"]
      },
      // Research skills
      {
        id: "research",
        name: "Research",
        description: "Ability to find and synthesize information from various sources",
        promptAddition: `You excel at conducting comprehensive research by finding, evaluating, and synthesizing information from multiple sources. 
You can formulate research questions and search strategies to efficiently gather relevant information.`,
        requiredTools: ["web_search"]
      },
      {
        id: "academic",
        name: "Academic Writing",
        description: "Ability to write in formal academic style with proper citations",
        promptAddition: `You excel at academic writing with a focus on clarity, precision, and proper citation of sources. 
You understand academic conventions and can write in a scholarly tone.`,
        requiredTools: ["citation_generator"]
      },
      // Writing skills
      {
        id: "writing",
        name: "Creative Writing",
        description: "Ability to create engaging and original written content",
        promptAddition: `You excel at creative writing with a focus on originality, engaging narrative, and vivid description. 
You can adjust your writing style to different genres and audiences.`,
        requiredTools: ["document_editor"]
      },
      {
        id: "editing",
        name: "Editing and Proofreading",
        description: "Ability to improve and correct written content",
        promptAddition: `You excel at editing and proofreading with a focus on grammar, clarity, and consistency. 
You can identify and fix writing issues while preserving the author's voice and intent.`,
        requiredTools: ["document_editor"]
      },
      // Analysis skills
      {
        id: "analysis",
        name: "Critical Analysis",
        description: "Ability to evaluate information and arguments critically",
        promptAddition: `You excel at critical analysis with a focus on evaluating arguments, identifying assumptions, and recognizing biases. 
You can break down complex ideas and assess their validity and implications.`,
        requiredTools: []
      },
      {
        id: "statistics",
        name: "Statistical Analysis",
        description: "Ability to perform and interpret statistical analyses",
        promptAddition: `You excel at statistical analysis with a focus on selecting appropriate methods, interpreting results, and drawing valid conclusions. 
You understand statistical concepts and can explain them in accessible terms.`,
        requiredTools: ["calculator", "data_processor"]
      },
      // Planning skills
      {
        id: "planning",
        name: "Strategic Planning",
        description: "Ability to create structured plans with clear steps",
        promptAddition: `You excel at strategic planning with a focus on goal setting, resource allocation, and action sequencing. 
You can break down complex objectives into manageable steps and anticipate potential challenges.`,
        requiredTools: []
      },
      {
        id: "project_management",
        name: "Project Management",
        description: "Ability to organize and track project components and timelines",
        promptAddition: `You excel at project management with a focus on task organization, timeline creation, and progress tracking. 
You can help users define project scope, identify dependencies, and manage resources effectively.`,
        requiredTools: []
      },
      // Technical skills
      {
        id: "database",
        name: "Database Management",
        description: "Ability to design and query databases",
        promptAddition: `You excel at database management with a focus on schema design, query optimization, and data integrity. 
You understand database concepts and can work with various database systems.`,
        requiredTools: ["code_execution"]
      },
      {
        id: "architecture",
        name: "Software Architecture",
        description: "Ability to design software systems and components",
        promptAddition: `You excel at software architecture with a focus on system design, component interaction, and design patterns. 
You can create architectures that balance functionality, performance, security, and maintainability.`,
        requiredTools: []
      }
    ];
  }
  /**
   * Analyze the task to determine required capabilities
   */
  async analyzeTask(task, options2) {
    const analysisPrompt = `As Microsoft Agent AutoBuilder, analyze this task to determine the type of agent and skills needed to complete it effectively:

Task: ${task}

Available Agent Templates:
${this.agentTemplates.map((template) => `- ${template.name}: ${template.description}`).join("\n")}

Available Skills:
${this.availableSkills.map((skill) => `- ${skill.name}: ${skill.description}`).join("\n")}

Provide a detailed analysis with:
1. The most appropriate agent template
2. 2-4 skills that would be beneficial for this task
3. Any specific tools that would be helpful
4. A brief explanation of why these selections are appropriate

Be thorough in your analysis to ensure the agent will be well-equipped to handle this specific task.`;
    const analysis = await this.getResponseFromLLM(analysisPrompt);
    this.taskAnalysis = analysis;
  }
  /**
   * Build a specialized agent based on task analysis
   */
  async buildSpecializedAgent(options2) {
    const templateMatch = this.taskAnalysis.match(/appropriate agent template:?\s*([^\n]+)/i) || this.taskAnalysis.match(/recommend(?:ed)? (?:the )?([^\n]+) template/i) || this.taskAnalysis.match(/([^\n]+) template would be best/i);
    const skillsMatch = this.taskAnalysis.match(/skills:?\s*([^\n]+(?:\n(?!\n)[^\n]+)*)/i) || this.taskAnalysis.match(/beneficial skills:?\s*([^\n]+(?:\n(?!\n)[^\n]+)*)/i);
    const toolsMatch = this.taskAnalysis.match(/tools:?\s*([^\n]+(?:\n(?!\n)[^\n]+)*)/i) || this.taskAnalysis.match(/helpful tools:?\s*([^\n]+(?:\n(?!\n)[^\n]+)*)/i);
    let selectedTemplate = this.agentTemplates[0];
    if (templateMatch) {
      const templateName = templateMatch[1].trim();
      const matchedTemplate = this.agentTemplates.find(
        (t) => templateName.toLowerCase().includes(t.name.toLowerCase()) || t.name.toLowerCase().includes(templateName.toLowerCase())
      );
      if (matchedTemplate) {
        selectedTemplate = matchedTemplate;
      }
    }
    let selectedSkills = [];
    if (skillsMatch) {
      const skillsList = skillsMatch[1].split(/[,;\n]/).map((s) => s.trim()).filter((s) => s.length > 0);
      for (const skillName of skillsList) {
        const matchedSkill = this.availableSkills.find(
          (s) => skillName.toLowerCase().includes(s.name.toLowerCase()) || s.name.toLowerCase().includes(skillName.toLowerCase())
        );
        if (matchedSkill && !selectedSkills.some((s) => s.id === matchedSkill.id)) {
          selectedSkills.push(matchedSkill);
        }
      }
    }
    if (selectedSkills.length === 0) {
      selectedSkills = this.availableSkills.filter((skill) => selectedTemplate.skillCompatibility.includes(skill.id)).slice(0, 3);
    }
    let selectedToolNames = [...selectedTemplate.defaultTools];
    selectedSkills.forEach((skill) => {
      skill.requiredTools.forEach((tool) => {
        if (!selectedToolNames.includes(tool)) {
          selectedToolNames.push(tool);
        }
      });
    });
    if (toolsMatch) {
      const toolsList = toolsMatch[1].split(/[,;\n]/).map((t) => t.trim()).filter((t) => t.length > 0);
      toolsList.forEach((toolName) => {
        const normalizedToolName = toolName.toLowerCase().replace(/\s+/g, "_");
        if (!selectedToolNames.includes(normalizedToolName)) {
          selectedToolNames.push(normalizedToolName);
        }
      });
    }
    let fullPrompt = selectedTemplate.basePrompt + "\n\n";
    if (selectedSkills.length > 0) {
      fullPrompt += "Your specialized capabilities include:\n\n";
      selectedSkills.forEach((skill) => {
        fullPrompt += skill.promptAddition + "\n\n";
      });
    }
    fullPrompt += `For this specific task, focus on applying these capabilities effectively while maintaining a helpful, clear, and thorough approach.`;
    this.builtAgent = {
      name: `Specialized ${selectedTemplate.name}`,
      description: `A custom agent built for this specific task using the ${selectedTemplate.name} template`,
      skills: selectedSkills,
      fullPrompt,
      toolNames: selectedToolNames
    };
  }
  /**
   * Execute the task with the specialized agent
   */
  async executeWithSpecializedAgent(task, options2) {
    if (!this.builtAgent) {
      throw new Error("No agent has been built");
    }
    const executionPrompt = `${this.builtAgent.fullPrompt}

Task: ${task}

${this.builtAgent.toolNames.length > 0 ? `You have access to the following tools:
${this.builtAgent.toolNames.join(", ")}

To use a tool, indicate it clearly in your response.` : ""}

Please complete this task thoroughly and effectively, showcasing your specialized capabilities.`;
    const agentResponse = await this.getResponseFromLLM(executionPrompt);
    const toolCalls = this.extractToolCalls(agentResponse);
    const processedToolCalls = await this.processToolCalls(toolCalls, options2);
    const followupQuestions = this.extractFollowupQuestions(agentResponse);
    this.executionResult = {
      response: agentResponse,
      toolCalls: processedToolCalls,
      followupQuestions,
      thinking: `Agent execution using ${this.builtAgent.name} with ${this.builtAgent.skills.length} specialized skills`
    };
  }
  /**
   * Extract tool calls from agent response
   */
  extractToolCalls(response) {
    const toolCalls = [];
    const toolCallPatterns = [
      /Using the (\w+) tool with (?:parameters|inputs):?\s*({[\s\S]*?})/gi,
      /I'll use the (\w+) tool:?\s*({[\s\S]*?})/gi,
      /Let me use (?:the )?(\w+)(?: tool)?:?\s*({[\s\S]*?})/gi
    ];
    for (const pattern of toolCallPatterns) {
      let match;
      while ((match = pattern.exec(response)) !== null) {
        const toolName = match[1];
        const parametersJson = match[2];
        try {
          const parameters = JSON.parse(parametersJson);
          toolCalls.push({
            tool: toolName,
            input: parameters
          });
        } catch (error) {
          const params2 = {};
          const keyValuePattern = /(\w+):\s*(?:"([^"]*)"|([\w.]+))/g;
          let kvMatch;
          while ((kvMatch = keyValuePattern.exec(parametersJson)) !== null) {
            const key = kvMatch[1];
            const value = kvMatch[2] || kvMatch[3];
            params2[key] = value;
          }
          if (Object.keys(params2).length > 0) {
            toolCalls.push({
              tool: toolName,
              input: params2
            });
          }
        }
      }
    }
    return toolCalls;
  }
  /**
   * Process tool calls by executing the tools
   */
  async processToolCalls(toolCalls, options2) {
    const processedCalls = [];
    for (const call of toolCalls) {
      const tool = this.availableTools.find(
        (t) => t.name.toLowerCase() === call.tool.toLowerCase() || call.tool.toLowerCase().includes(t.name.toLowerCase())
      );
      if (tool) {
        try {
          if (options2.callbacks?.onToolUse) {
            options2.callbacks.onToolUse({
              toolName: tool.name,
              input: call.input,
              output: void 0,
              error: void 0
            });
          }
          const output = await tool.execute(call.input);
          if (options2.callbacks?.onToolUse) {
            options2.callbacks.onToolUse({
              toolName: tool.name,
              input: call.input,
              output,
              error: void 0
            });
          }
          processedCalls.push({
            tool: tool.name,
            input: call.input,
            output
          });
        } catch (error) {
          if (options2.callbacks?.onToolUse) {
            options2.callbacks.onToolUse({
              toolName: tool.name,
              input: call.input,
              output: void 0,
              error: error.message
            });
          }
          processedCalls.push({
            tool: tool.name,
            input: call.input,
            output: `Error: ${error.message}`
          });
        }
      } else {
        processedCalls.push({
          tool: call.tool,
          input: call.input,
          output: `Error: Tool "${call.tool}" not found`
        });
      }
    }
    return processedCalls;
  }
  /**
   * Extract follow-up questions from agent response
   */
  extractFollowupQuestions(response) {
    const questions = [];
    const sectionMatch = response.match(/(?:follow-up|follow up|additional) questions:?\s*([\s\S]*?)(?=\n\n|$)/i);
    if (sectionMatch) {
      const questionSection = sectionMatch[1];
      const questionPattern = /(?:^|\n)(?:\d+\.\s*|\*\s*|-\s*|Q\d+:\s*)([^\n?]+\?)/g;
      let match;
      while ((match = questionPattern.exec(questionSection)) !== null) {
        questions.push(match[1].trim());
      }
    } else {
      const questionPattern = /\n(?:\d+\.\s*|\*\s*|-\s*|Q\d+:\s*)([^\n?]+\?)/g;
      let match;
      while ((match = questionPattern.exec(response)) !== null) {
        questions.push(match[1].trim());
      }
    }
    return questions;
  }
  /**
   * Format the final response
   */
  formatFinalResponse() {
    if (!this.builtAgent || !this.executionResult) {
      return "Error: Agent execution incomplete";
    }
    let response = `# Task Execution with ${this.builtAgent.name}

`;
    response += `## Task Analysis
`;
    response += `${this.taskAnalysis.split("\n").slice(0, 5).join("\n")}

`;
    response += `## Specialized Agent Configuration
`;
    response += `**Template:** ${this.builtAgent.name}
`;
    response += `**Skills:**
`;
    this.builtAgent.skills.forEach((skill) => {
      response += `- ${skill.name}: ${skill.description}
`;
    });
    if (this.builtAgent.toolNames.length > 0) {
      response += `
**Tools:** ${this.builtAgent.toolNames.join(", ")}
`;
    }
    response += `
## Execution Result
`;
    response += this.executionResult.response;
    if (this.executionResult.toolCalls && this.executionResult.toolCalls.length > 0) {
      response += `

## Tool Usage
`;
      this.executionResult.toolCalls.forEach((call, index2) => {
        response += `### Tool Call ${index2 + 1}: ${call.tool}
`;
        response += `**Input:**
\`\`\`json
${JSON.stringify(call.input, null, 2)}
\`\`\`
`;
        response += `**Output:**
\`\`\`
${typeof call.output === "object" ? JSON.stringify(call.output, null, 2) : call.output}
\`\`\`

`;
      });
    }
    if (this.executionResult.followupQuestions && this.executionResult.followupQuestions.length > 0) {
      response += `
## Follow-up Questions
`;
      this.executionResult.followupQuestions.forEach((question, index2) => {
        response += `${index2 + 1}. ${question}
`;
      });
    }
    return response;
  }
  /**
   * Get response from the appropriate LLM based on model name
   */
  async getResponseFromLLM(prompt) {
    try {
      if (this.config.modelName?.includes("claude")) {
        return await this.getResponseFromClaude(prompt);
      } else if (this.config.modelName?.includes("gpt")) {
        return await this.getResponseFromOpenAI(prompt);
      } else {
        return await this.getResponseFromClaude(prompt);
      }
    } catch (error) {
      log(`Error getting LLM response: ${error}`, "agent");
      throw error;
    }
  }
  /**
   * Get response from Claude
   */
  async getResponseFromClaude(prompt) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: this.config.systemPrompt,
      messages: [{ role: "user", content: prompt }]
    });
    return response.content[0].text;
  }
  /**
   * Get response from OpenAI
   */
  async getResponseFromOpenAI(prompt) {
    if (!this.openaiClient) {
      throw new Error("OpenAI client not initialized");
    }
    const response = await this.openaiClient.chat.completions.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      messages: [
        { role: "system", content: this.config.systemPrompt },
        { role: "user", content: prompt }
      ]
    });
    return response.choices[0].message.content || "";
  }
  /**
   * Get available tools
   */
  getAvailableTools() {
    return this.availableTools;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.tools) {
      this.availableTools = config.tools;
    }
  }
  /**
   * Get supported execution modes
   */
  getSupportedExecutionModes() {
    return ["synchronous" /* SYNCHRONOUS */];
  }
  /**
   * Check if protocol supports a specific capability
   */
  supportsCapability(capability) {
    return this.config.capabilities.includes(capability);
  }
  /**
   * Get current protocol configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    this.builtAgent = null;
    this.taskAnalysis = "";
    this.executionResult = null;
    this.initialized = false;
    return Promise.resolve();
  }
};

// server/services/agent/protocols/KortixBuilderProtocol.ts
import Anthropic20 from "@anthropic-ai/sdk";
import OpenAI12 from "openai";
var DEFAULT_MODEL18 = "claude-3-7-sonnet-20250219";
var KortixBuilderProtocol = class {
  config = {
    systemPrompt: `You are the Kortix/Suna.so Builder, a visual no-code agent workflow designer.
You excel at:
1. Translating natural language instructions into visual workflow diagrams
2. Designing efficient multi-step agent workflows
3. Implementing logic, conditions, and data transformations
4. Creating reusable workflow templates
5. Orchestrating complex processes with minimal coding`,
    tools: [],
    modelName: DEFAULT_MODEL18,
    temperature: 0.5,
    maxTokens: 2048,
    capabilities: [
      "visual_design" /* VISUAL_DESIGN */,
      "multi_step" /* MULTI_STEP */,
      "tool_use" /* TOOL_USE */
    ]
  };
  anthropicClient = null;
  openaiClient = null;
  availableTools = [];
  initialized = false;
  // Workflow state
  workflowDefinition = null;
  executionState = null;
  availableNodeTypes = {
    ["trigger" /* TRIGGER */]: "Start a workflow based on an event",
    ["condition" /* CONDITION */]: "Branch workflow based on a condition",
    ["action" /* ACTION */]: "Perform an action or call external service",
    ["loop" /* LOOP */]: "Repeat a sequence of steps",
    ["processor" /* PROCESSOR */]: "Transform or process data",
    ["output" /* OUTPUT */]: "Generate final output or response"
  };
  workflowAnalysis = "";
  previousWorkflowOutputs = [];
  /**
   * Get metadata about this protocol
   */
  getMetadata() {
    return {
      name: "Kortix/Suna.so Builder",
      version: "1.0.0",
      description: "Visual no-code agent workflow designer",
      capabilities: [
        "visual_design" /* VISUAL_DESIGN */,
        "multi_step" /* MULTI_STEP */,
        "tool_use" /* TOOL_USE */
      ],
      requiresAuthentication: true,
      supportedModels: [
        "claude-3-7-sonnet-20250219",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "gpt-4o",
        "gpt-4-turbo",
        "gpt-4"
      ]
    };
  }
  /**
   * Initialize the protocol with configuration
   */
  async init(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (this.config.modelName?.includes("claude")) {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY environment variable is required for Claude models");
      }
      this.anthropicClient = new Anthropic20({
        apiKey: process.env.ANTHROPIC_API_KEY
      });
    } else if (this.config.modelName?.includes("gpt")) {
      if (!process.env.OPENAI_API_KEY) {
        throw new Error("OPENAI_API_KEY environment variable is required for OpenAI models");
      }
      this.openaiClient = new OpenAI12({
        apiKey: process.env.OPENAI_API_KEY
      });
    }
    this.availableTools = this.config.tools || [];
    this.workflowDefinition = null;
    this.executionState = null;
    this.workflowAnalysis = "";
    this.previousWorkflowOutputs = [];
    this.initialized = true;
  }
  /**
   * Execute a task using this protocol
   */
  async execute(options2) {
    if (!this.initialized) {
      throw new Error("Protocol not initialized. Call init() first.");
    }
    const startTime2 = Date.now();
    try {
      if (options2.callbacks?.onStart) {
        options2.callbacks.onStart();
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Workflow Analysis",
          description: "Analyzing requirements for workflow design",
          status: "started"
        });
      }
      await this.analyzeWorkflowRequirements(options2.task, options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Workflow Analysis",
          description: "Workflow requirements analyzed",
          output: { analysis: this.workflowAnalysis.substring(0, 200) + "..." },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Workflow Design",
          description: "Creating visual workflow diagram",
          status: "started"
        });
      }
      await this.designWorkflowDiagram(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Workflow Design",
          description: "Workflow diagram created",
          output: {
            nodes: this.workflowDefinition?.nodes.length,
            connections: this.workflowDefinition?.connections.length
          },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Workflow Execution",
          description: "Executing workflow simulation",
          status: "started"
        });
      }
      await this.simulateWorkflowExecution(options2.task, options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Workflow Execution",
          description: "Workflow simulation completed",
          output: {
            status: this.executionState?.status,
            steps: this.executionState?.history.length
          },
          status: "completed"
        });
      }
      const finalResponse = this.formatFinalResponse();
      const agentResponse = {
        response: {
          content: finalResponse,
          toolCalls: this.getToolCallsHistory()
        },
        executionTime: Date.now() - startTime2,
        protocol: "kortixbuilder",
        metadata: {
          workflowName: this.workflowDefinition?.name,
          workflowId: this.workflowDefinition?.id,
          nodeCount: this.workflowDefinition?.nodes.length,
          executionStatus: this.executionState?.status
        }
      };
      if (options2.callbacks?.onComplete) {
        options2.callbacks.onComplete(agentResponse);
      }
      return agentResponse;
    } catch (error) {
      log(`Kortix Builder Protocol execution error: ${error}`, "agent");
      if (options2.callbacks?.onError) {
        options2.callbacks.onError(error);
      }
      throw error;
    }
  }
  /**
   * Analyze workflow requirements from task description
   */
  async analyzeWorkflowRequirements(task, options2) {
    const analysisPrompt = `As the Kortix/Suna.so Builder, analyze this workflow automation request and identify the key components needed:

Task: ${task}

Available Node Types:
${Object.entries(this.availableNodeTypes).map(([type, desc13]) => `- ${type}: ${desc13}`).join("\n")}

Available Tools:
${this.availableTools.map((tool) => `- ${tool.name}: ${tool.description}`).join("\n")}

Please provide a detailed analysis including:
1. The primary goal of this workflow
2. Key steps or stages needed
3. Required inputs and expected outputs
4. Decision points or conditions
5. Tools or services that should be incorporated
6. Data transformations needed
7. Potential edge cases or error handling needs

This analysis will guide the visual workflow design.`;
    const analysis = await this.getResponseFromLLM(analysisPrompt);
    this.workflowAnalysis = analysis;
  }
  /**
   * Design the workflow diagram based on analysis
   */
  async designWorkflowDiagram(options2) {
    const designPrompt = `As the Kortix/Suna.so Builder, create a visual workflow diagram based on this analysis:

${this.workflowAnalysis}

Design a complete workflow with appropriate nodes and connections. Include:

1. A unique ID for the workflow
2. A descriptive name for the workflow
3. A brief workflow description
4. A set of workflow nodes (each with id, type, name, description, configuration, and position)
5. Connections between nodes (specifying source, target, and connection type)
6. Appropriate metadata (version, creator, timestamp, tags)

Use these node types:
${Object.entries(this.availableNodeTypes).map(([type, desc13]) => `- ${type}: ${desc13}`).join("\n")}

Connection types:
- standard: Regular flow connection
- success: Used after successful operation
- failure: Used after failed operation
- condition_true: When condition evaluates to true
- condition_false: When condition evaluates to false

Respond with a JSON object representing the complete workflow definition.`;
    const designResponse = await this.getResponseFromLLM(designPrompt);
    try {
      const jsonMatch = designResponse.match(/{[\s\S]*?}/);
      if (jsonMatch) {
        const workflowJson = JSON.parse(jsonMatch[0]);
        if (!workflowJson.id || !workflowJson.name || !Array.isArray(workflowJson.nodes) || !Array.isArray(workflowJson.connections)) {
          throw new Error("Invalid workflow structure");
        }
        if (!workflowJson.metadata?.createdAt) {
          if (!workflowJson.metadata) {
            workflowJson.metadata = {};
          }
          workflowJson.metadata.createdAt = (/* @__PURE__ */ new Date()).toISOString();
        }
        this.workflowDefinition = workflowJson;
      } else {
        throw new Error("Could not extract workflow JSON");
      }
    } catch (error) {
      log(`Error parsing workflow definition: ${error}`, "agent");
      this.createFallbackWorkflow();
    }
  }
  /**
   * Create a basic fallback workflow when parsing fails
   */
  createFallbackWorkflow() {
    const workflowId = `workflow-${Date.now()}`;
    const triggerNode = {
      id: `${workflowId}-trigger`,
      type: "trigger" /* TRIGGER */,
      name: "Start Workflow",
      description: "Initiates the workflow",
      config: {},
      position: { x: 100, y: 100 }
    };
    const processorNode = {
      id: `${workflowId}-processor`,
      type: "processor" /* PROCESSOR */,
      name: "Process Data",
      description: "Process input data",
      config: {},
      position: { x: 300, y: 100 }
    };
    const outputNode = {
      id: `${workflowId}-output`,
      type: "output" /* OUTPUT */,
      name: "Generate Output",
      description: "Produce final output",
      config: {},
      position: { x: 500, y: 100 }
    };
    const connection1 = {
      id: `${workflowId}-conn1`,
      sourceNodeId: triggerNode.id,
      targetNodeId: processorNode.id,
      type: "standard" /* STANDARD */
    };
    const connection2 = {
      id: `${workflowId}-conn2`,
      sourceNodeId: processorNode.id,
      targetNodeId: outputNode.id,
      type: "standard" /* STANDARD */
    };
    this.workflowDefinition = {
      id: workflowId,
      name: "Basic Workflow",
      description: "A simple linear workflow with three steps",
      nodes: [triggerNode, processorNode, outputNode],
      connections: [connection1, connection2],
      metadata: {
        version: "1.0.0",
        creator: "KortixBuilderProtocol",
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        tags: ["fallback", "basic"]
      }
    };
  }
  /**
   * Simulate workflow execution
   */
  async simulateWorkflowExecution(task, options2) {
    if (!this.workflowDefinition) {
      throw new Error("No workflow definition available");
    }
    this.executionState = {
      workflowId: this.workflowDefinition.id,
      currentNodeId: this.findStartingNodeId(),
      status: "running",
      variables: {
        input: task
        // Add any other initial variables
      },
      history: [],
      startTime: (/* @__PURE__ */ new Date()).toISOString()
    };
    const maxSteps = 20;
    let currentStep = 0;
    while (this.executionState.status === "running" && currentStep < maxSteps) {
      currentStep++;
      await this.executeWorkflowNode(options2);
      if (!this.executionState.currentNodeId || this.isEndNode(this.executionState.currentNodeId)) {
        this.executionState.status = "completed";
        this.executionState.endTime = (/* @__PURE__ */ new Date()).toISOString();
      }
    }
    if (currentStep >= maxSteps && this.executionState.status !== "completed") {
      this.executionState.status = "failed";
      this.executionState.endTime = (/* @__PURE__ */ new Date()).toISOString();
    }
  }
  /**
   * Execute a single workflow node
   */
  async executeWorkflowNode(options2) {
    if (!this.workflowDefinition || !this.executionState) {
      throw new Error("Workflow or execution state not initialized");
    }
    const currentNode = this.workflowDefinition.nodes.find(
      (node) => node.id === this.executionState.currentNodeId
    );
    if (!currentNode) {
      this.executionState.status = "failed";
      return;
    }
    const historyEntry = {
      nodeId: currentNode.id,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      input: this.getNodeInput(currentNode)
    };
    try {
      let output;
      let nextNodeId = null;
      switch (currentNode.type) {
        case "trigger" /* TRIGGER */:
          output = historyEntry.input;
          nextNodeId = this.findNextNodeId(currentNode.id, "standard" /* STANDARD */);
          break;
        case "condition" /* CONDITION */:
          const conditionResult = await this.evaluateCondition(currentNode, historyEntry.input);
          output = { condition: currentNode.name, result: conditionResult };
          nextNodeId = this.findNextNodeId(
            currentNode.id,
            conditionResult ? "condition_true" /* CONDITION_TRUE */ : "condition_false" /* CONDITION_FALSE */
          );
          break;
        case "action" /* ACTION */:
          output = await this.executeAction(currentNode, historyEntry.input, options2);
          const actionSuccess = !output.error;
          nextNodeId = this.findNextNodeId(
            currentNode.id,
            actionSuccess ? "success" /* SUCCESS */ : "failure" /* FAILURE */
          );
          break;
        case "processor" /* PROCESSOR */:
          output = await this.processData(currentNode, historyEntry.input);
          nextNodeId = this.findNextNodeId(currentNode.id, "standard" /* STANDARD */);
          break;
        case "loop" /* LOOP */:
          const continueLoop = await this.evaluateLoopCondition(currentNode, historyEntry.input);
          output = { loop: currentNode.name, continue: continueLoop };
          nextNodeId = this.findNextNodeId(
            currentNode.id,
            continueLoop ? "condition_true" /* CONDITION_TRUE */ : "condition_false" /* CONDITION_FALSE */
          );
          break;
        case "output" /* OUTPUT */:
          output = await this.generateOutput(currentNode, historyEntry.input);
          this.previousWorkflowOutputs.push(output);
          nextNodeId = null;
          break;
        default:
          output = { error: `Unsupported node type: ${currentNode.type}` };
          nextNodeId = null;
      }
      historyEntry.output = output;
      this.executionState.currentNodeId = nextNodeId || "";
    } catch (error) {
      historyEntry.error = error.message;
      const failureNodeId = this.findNextNodeId(currentNode.id, "failure" /* FAILURE */);
      this.executionState.currentNodeId = failureNodeId || "";
      if (!failureNodeId) {
        this.executionState.status = "failed";
      }
    }
    this.executionState.history.push(historyEntry);
  }
  /**
   * Find the starting node ID
   */
  findStartingNodeId() {
    if (!this.workflowDefinition) {
      throw new Error("No workflow definition available");
    }
    const triggerNode = this.workflowDefinition.nodes.find((node) => node.type === "trigger" /* TRIGGER */);
    if (triggerNode) {
      return triggerNode.id;
    }
    if (this.workflowDefinition.nodes.length > 0) {
      return this.workflowDefinition.nodes[0].id;
    }
    throw new Error("No nodes in workflow definition");
  }
  /**
   * Check if a node is an end node
   */
  isEndNode(nodeId) {
    if (!this.workflowDefinition) {
      return true;
    }
    return !this.workflowDefinition.connections.some((conn) => conn.sourceNodeId === nodeId);
  }
  /**
   * Find the next node ID based on connection type
   */
  findNextNodeId(sourceNodeId, connectionType) {
    if (!this.workflowDefinition) {
      return null;
    }
    const connection = this.workflowDefinition.connections.find(
      (conn) => conn.sourceNodeId === sourceNodeId && conn.type === connectionType
    );
    if (!connection && connectionType !== "standard" /* STANDARD */) {
      const standardConnection = this.workflowDefinition.connections.find(
        (conn) => conn.sourceNodeId === sourceNodeId && conn.type === "standard" /* STANDARD */
      );
      return standardConnection ? standardConnection.targetNodeId : null;
    }
    return connection ? connection.targetNodeId : null;
  }
  /**
   * Get input for a node based on previous node outputs and variables
   */
  getNodeInput(node) {
    if (!this.executionState) {
      return {};
    }
    const input2 = { ...this.executionState.variables };
    if (this.executionState.history.length > 0) {
      const prevNode = this.executionState.history[this.executionState.history.length - 1];
      input2.previousOutput = prevNode.output;
    }
    input2.nodeConfig = node.config;
    return input2;
  }
  /**
   * Evaluate a condition node
   */
  async evaluateCondition(node, input2) {
    if (!node.config.condition) {
      return this.evaluateConditionWithLLM(node, input2);
    }
    try {
      const condition = node.config.condition;
      if (typeof condition === "string") {
        if (condition.includes(">")) {
          const [varPath, valueStr] = condition.split(">").map((s) => s.trim());
          const varValue = this.getValueFromPath(input2, varPath);
          const compareValue = Number(valueStr);
          return varValue > compareValue;
        } else if (condition.includes("<")) {
          const [varPath, valueStr] = condition.split("<").map((s) => s.trim());
          const varValue = this.getValueFromPath(input2, varPath);
          const compareValue = Number(valueStr);
          return varValue < compareValue;
        } else if (condition.includes("==")) {
          const [varPath, valueStr] = condition.split("==").map((s) => s.trim());
          const varValue = this.getValueFromPath(input2, varPath);
          return varValue == valueStr;
        } else if (condition.includes("!=")) {
          const [varPath, valueStr] = condition.split("!=").map((s) => s.trim());
          const varValue = this.getValueFromPath(input2, varPath);
          return varValue != valueStr;
        }
      }
      return this.evaluateConditionWithLLM(node, input2);
    } catch (error) {
      log(`Error evaluating condition: ${error}`, "agent");
      return false;
    }
  }
  /**
   * Evaluate a condition using LLM
   */
  async evaluateConditionWithLLM(node, input2) {
    const conditionPrompt = `Evaluate this condition in a workflow:

Condition: ${node.name}
Description: ${node.description}
Input: ${JSON.stringify(input2, null, 2)}

Should this condition evaluate to true or false? Respond with only "true" or "false".`;
    const response = await this.getResponseFromLLM(conditionPrompt);
    return response.toLowerCase().includes("true");
  }
  /**
   * Execute an action node, possibly using tools
   */
  async executeAction(node, input2, options2) {
    if (node.config.tool) {
      return this.executeActionWithTool(node, input2, options2);
    }
    const actionPrompt = `Execute this action in a workflow:

Action: ${node.name}
Description: ${node.description}
Configuration: ${JSON.stringify(node.config, null, 2)}
Input: ${JSON.stringify(input2, null, 2)}

Simulate the execution of this action and provide the expected output.
Respond with a JSON object representing the action result.`;
    const response = await this.getResponseFromLLM(actionPrompt);
    try {
      const jsonMatch = response.match(/{[\s\S]*?}/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      }
      return { result: response };
    } catch (error) {
      return { result: response };
    }
  }
  /**
   * Execute an action with a tool
   */
  async executeActionWithTool(node, input2, options2) {
    const toolName = node.config.tool;
    const tool = this.availableTools.find(
      (t) => t.name === toolName || t.name.toLowerCase() === toolName.toLowerCase()
    );
    if (!tool) {
      return { error: `Tool not found: ${toolName}` };
    }
    let toolParams = node.config.params || {};
    if (typeof toolParams === "object") {
      toolParams = this.resolveVariableReferences(toolParams, input2);
    }
    try {
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: tool.name,
          input: toolParams,
          output: void 0,
          error: void 0
        });
      }
      const result2 = await tool.execute(toolParams);
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: tool.name,
          input: toolParams,
          output: result2,
          error: void 0
        });
      }
      return {
        tool: tool.name,
        params: toolParams,
        result: result2
      };
    } catch (error) {
      if (options2.callbacks?.onToolUse) {
        options2.callbacks.onToolUse({
          toolName: tool.name,
          input: toolParams,
          output: void 0,
          error: error.message
        });
      }
      return {
        tool: tool.name,
        params: toolParams,
        error: error.message
      };
    }
  }
  /**
   * Process data in a processor node
   */
  async processData(node, input2) {
    if (node.config.transformation) {
      return this.applyTransformation(node.config.transformation, input2);
    }
    const processorPrompt = `Process this data in a workflow:

Processor: ${node.name}
Description: ${node.description}
Configuration: ${JSON.stringify(node.config, null, 2)}
Input: ${JSON.stringify(input2, null, 2)}

Transform this data according to the processor's description.
Respond with a JSON object representing the processed data.`;
    const response = await this.getResponseFromLLM(processorPrompt);
    try {
      const jsonMatch = response.match(/{[\s\S]*?}/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      }
      return { processed: response };
    } catch (error) {
      return { processed: response };
    }
  }
  /**
   * Apply a data transformation
   */
  applyTransformation(transformation, input2) {
    const config = input2.nodeConfig || {};
    switch (transformation) {
      case "extract_fields":
        if (config.fields && Array.isArray(config.fields)) {
          const result2 = {};
          for (const field of config.fields) {
            result2[field] = this.getValueFromPath(input2, field);
          }
          return result2;
        }
        break;
      case "filter":
        if (config.condition) {
          if (input2.items && Array.isArray(input2.items)) {
            return {
              items: input2.items.filter(
                (item) => this.evaluateFilterCondition(config.condition, item)
              )
            };
          }
        }
        break;
      case "sort":
        if (config.sortBy && input2.items && Array.isArray(input2.items)) {
          const sortBy = config.sortBy;
          const sortDir = config.sortDirection || "asc";
          return {
            items: [...input2.items].sort((a, b) => {
              const aVal = this.getValueFromPath(a, sortBy);
              const bVal = this.getValueFromPath(b, sortBy);
              if (sortDir === "asc") {
                return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
              } else {
                return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
              }
            })
          };
        }
        break;
      case "aggregate":
        if (config.function && input2.items && Array.isArray(input2.items)) {
          const aggFunc = config.function;
          const field = config.field;
          if (field) {
            const values = input2.items.map(
              (item) => this.getValueFromPath(item, field)
            ).filter((val) => typeof val === "number");
            switch (aggFunc) {
              case "sum":
                return { result: values.reduce((a, b) => a + b, 0) };
              case "avg":
                return { result: values.reduce((a, b) => a + b, 0) / values.length };
              case "min":
                return { result: Math.min(...values) };
              case "max":
                return { result: Math.max(...values) };
              case "count":
                return { result: values.length };
            }
          }
        }
        break;
    }
    return input2;
  }
  /**
   * Evaluate loop condition
   */
  async evaluateLoopCondition(node, input2) {
    if (node.config.maxIterations) {
      const currentIteration = input2.loopCounter || 0;
      if (currentIteration >= node.config.maxIterations) {
        return false;
      }
    }
    if (node.config.condition) {
      return this.evaluateCondition({ ...node, config: { condition: node.config.condition } }, input2);
    }
    const loopPrompt = `Evaluate this loop condition in a workflow:

Loop: ${node.name}
Description: ${node.description}
Configuration: ${JSON.stringify(node.config, null, 2)}
Current state: ${JSON.stringify(input2, null, 2)}

Should this loop continue or exit? Respond with only "continue" or "exit".`;
    const response = await this.getResponseFromLLM(loopPrompt);
    return response.toLowerCase().includes("continue");
  }
  /**
   * Generate output from an output node
   */
  async generateOutput(node, input2) {
    if (node.config.template) {
      return this.applyOutputTemplate(node.config.template, input2);
    }
    const outputPrompt = `Generate the final output for this workflow:

Output Node: ${node.name}
Description: ${node.description}
Configuration: ${JSON.stringify(node.config, null, 2)}
Input State: ${JSON.stringify(input2, null, 2)}
Execution History: ${JSON.stringify(this.executionState?.history.map((h) => ({
      node: this.workflowDefinition?.nodes.find((n) => n.id === h.nodeId)?.name,
      output: h.output
    })), null, 2)}

Create a well-formatted, comprehensive output that fulfills the purpose of this workflow.
Respond with a JSON object containing the final output.`;
    const response = await this.getResponseFromLLM(outputPrompt);
    try {
      const jsonMatch = response.match(/{[\s\S]*?}/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      }
      return { output: response };
    } catch (error) {
      return { output: response };
    }
  }
  /**
   * Apply an output template
   */
  applyOutputTemplate(template, input2) {
    let result2 = template;
    const varPattern = /{{([^}]+)}}/g;
    let match;
    while ((match = varPattern.exec(template)) !== null) {
      const varPath = match[1].trim();
      const varValue = this.getValueFromPath(input2, varPath);
      result2 = result2.replace(match[0], String(varValue !== void 0 ? varValue : ""));
    }
    return { output: result2 };
  }
  /**
   * Get a value from a nested path (e.g., "user.profile.name")
   */
  getValueFromPath(obj, path6) {
    if (!obj || !path6) {
      return void 0;
    }
    const parts = path6.split(".");
    let current = obj;
    for (const part of parts) {
      if (current === null || current === void 0) {
        return void 0;
      }
      current = current[part];
    }
    return current;
  }
  /**
   * Resolve variable references in an object
   */
  resolveVariableReferences(obj, context) {
    const result2 = {};
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === "string" && value.startsWith("{{") && value.endsWith("}}")) {
        const path6 = value.slice(2, -2).trim();
        result2[key] = this.getValueFromPath(context, path6);
      } else if (typeof value === "object" && value !== null) {
        result2[key] = this.resolveVariableReferences(value, context);
      } else {
        result2[key] = value;
      }
    }
    return result2;
  }
  /**
   * Evaluate a filter condition
   */
  evaluateFilterCondition(condition, item) {
    try {
      if (condition.includes(">")) {
        const [path6, valueStr] = condition.split(">").map((s) => s.trim());
        const itemValue = this.getValueFromPath(item, path6);
        const compareValue = Number(valueStr);
        return itemValue > compareValue;
      } else if (condition.includes("<")) {
        const [path6, valueStr] = condition.split("<").map((s) => s.trim());
        const itemValue = this.getValueFromPath(item, path6);
        const compareValue = Number(valueStr);
        return itemValue < compareValue;
      } else if (condition.includes("==")) {
        const [path6, valueStr] = condition.split("==").map((s) => s.trim());
        const itemValue = this.getValueFromPath(item, path6);
        return String(itemValue) === valueStr;
      } else if (condition.includes("!=")) {
        const [path6, valueStr] = condition.split("!=").map((s) => s.trim());
        const itemValue = this.getValueFromPath(item, path6);
        return String(itemValue) !== valueStr;
      } else if (condition.includes("contains")) {
        const [path6, valueStr] = condition.split("contains").map((s) => s.trim());
        const itemValue = String(this.getValueFromPath(item, path6));
        return itemValue.includes(valueStr.replace(/['"]/g, ""));
      }
    } catch (error) {
      return false;
    }
    return true;
  }
  /**
   * Format the final response
   */
  formatFinalResponse() {
    if (!this.workflowDefinition || !this.executionState) {
      return "Error: Workflow execution incomplete";
    }
    let response = `# Kortix/Suna.so Workflow Design

`;
    response += `## Workflow: ${this.workflowDefinition.name}
`;
    response += `${this.workflowDefinition.description}

`;
    response += `## Workflow Diagram
`;
    response += this.generateAsciiDiagram();
    response += `

`;
    response += `## Execution Results
`;
    response += `Status: ${this.executionState.status}
`;
    if (this.executionState.startTime && this.executionState.endTime) {
      const startTime2 = new Date(this.executionState.startTime);
      const endTime = new Date(this.executionState.endTime);
      const durationMs = endTime.getTime() - startTime2.getTime();
      response += `Duration: ${durationMs}ms
`;
    }
    response += `Steps Executed: ${this.executionState.history.length}

`;
    response += `### Execution Path
`;
    for (const step of this.executionState.history) {
      const node = this.workflowDefinition.nodes.find((n) => n.id === step.nodeId);
      if (node) {
        response += `1. **${node.name}** (${node.type})`;
        if (step.error) {
          response += ` - \u274C Error: ${step.error}`;
        } else {
          response += ` - \u2705 Success`;
        }
        response += `
`;
      }
    }
    if (this.executionState.history.length > 0) {
      const lastStep = this.executionState.history[this.executionState.history.length - 1];
      if (lastStep.output) {
        response += `
### Final Output
`;
        response += "```json\n";
        response += JSON.stringify(lastStep.output, null, 2);
        response += "\n```\n";
      }
    }
    return response;
  }
  /**
   * Generate ASCII representation of workflow diagram
   */
  generateAsciiDiagram() {
    if (!this.workflowDefinition) {
      return "No workflow definition available";
    }
    let diagram = "```\n";
    const nodesByRow = /* @__PURE__ */ new Map();
    for (const node of this.workflowDefinition.nodes) {
      const row = Math.round(node.position.y / 100);
      if (!nodesByRow.has(row)) {
        nodesByRow.set(row, []);
      }
      nodesByRow.get(row).push(node);
    }
    const sortedRows = Array.from(nodesByRow.entries()).sort(([rowA], [rowB]) => rowA - rowB);
    for (const [_, rowNodes] of sortedRows) {
      rowNodes.sort((a, b) => a.position.x - b.position.x);
      let nodeRow = "";
      for (const node of rowNodes) {
        if (nodeRow.length > 0) {
          nodeRow += "     ";
        }
        nodeRow += `[${node.type.slice(0, 3).toUpperCase()}: ${node.name}]`;
      }
      diagram += nodeRow + "\n";
      let connRow = "";
      let hasConnections = false;
      for (let i = 0; i < rowNodes.length; i++) {
        const node = rowNodes[i];
        const outConns = this.workflowDefinition.connections.filter(
          (conn) => conn.sourceNodeId === node.id
        );
        if (outConns.length > 0) {
          hasConnections = true;
          if (i > 0) {
            connRow += "     ";
          }
          const nodeText = `[${node.type.slice(0, 3).toUpperCase()}: ${node.name}]`;
          const mid = Math.floor(nodeText.length / 2);
          connRow += " ".repeat(mid) + "|" + " ".repeat(nodeText.length - mid - 1);
        } else if (i > 0) {
          connRow += " ".repeat(5);
        }
      }
      if (hasConnections) {
        diagram += connRow + "\n";
        let arrowRow = "";
        for (let i = 0; i < rowNodes.length; i++) {
          const node = rowNodes[i];
          const outConns = this.workflowDefinition.connections.filter(
            (conn) => conn.sourceNodeId === node.id
          );
          if (outConns.length > 0) {
            if (i > 0) {
              arrowRow += "     ";
            }
            const nodeText = `[${node.type.slice(0, 3).toUpperCase()}: ${node.name}]`;
            const mid = Math.floor(nodeText.length / 2);
            arrowRow += " ".repeat(mid) + "v" + " ".repeat(nodeText.length - mid - 1);
          } else if (i > 0) {
            arrowRow += " ".repeat(5);
          }
        }
        diagram += arrowRow + "\n";
      }
    }
    diagram += "```";
    return diagram;
  }
  /**
   * Get the tool calls history
   */
  getToolCallsHistory() {
    const toolCalls = [];
    if (this.executionState?.history) {
      for (const step of this.executionState.history) {
        if (step.output?.tool && step.output?.params) {
          toolCalls.push({
            name: step.output.tool,
            input: step.output.params,
            output: step.output.error ? { error: step.output.error } : step.output.result
          });
        }
      }
    }
    return toolCalls.length > 0 ? toolCalls : void 0;
  }
  /**
   * Get response from the appropriate LLM based on model name
   */
  async getResponseFromLLM(prompt) {
    try {
      if (this.config.modelName?.includes("claude")) {
        return await this.getResponseFromClaude(prompt);
      } else if (this.config.modelName?.includes("gpt")) {
        return await this.getResponseFromOpenAI(prompt);
      } else {
        return await this.getResponseFromClaude(prompt);
      }
    } catch (error) {
      log(`Error getting LLM response: ${error}`, "agent");
      throw error;
    }
  }
  /**
   * Get response from Claude
   */
  async getResponseFromClaude(prompt) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: this.config.systemPrompt,
      messages: [{ role: "user", content: prompt }]
    });
    return response.content[0].text;
  }
  /**
   * Get response from OpenAI
   */
  async getResponseFromOpenAI(prompt) {
    if (!this.openaiClient) {
      throw new Error("OpenAI client not initialized");
    }
    const response = await this.openaiClient.chat.completions.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      messages: [
        { role: "system", content: this.config.systemPrompt },
        { role: "user", content: prompt }
      ]
    });
    return response.choices[0].message.content || "";
  }
  /**
   * Get available tools
   */
  getAvailableTools() {
    return this.availableTools;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.tools) {
      this.availableTools = config.tools;
    }
  }
  /**
   * Get supported execution modes
   */
  getSupportedExecutionModes() {
    return ["synchronous" /* SYNCHRONOUS */, "asynchronous" /* ASYNCHRONOUS */];
  }
  /**
   * Check if protocol supports a specific capability
   */
  supportsCapability(capability) {
    return this.config.capabilities.includes(capability);
  }
  /**
   * Get current protocol configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    this.workflowDefinition = null;
    this.executionState = null;
    this.workflowAnalysis = "";
    this.previousWorkflowOutputs = [];
    this.initialized = false;
    return Promise.resolve();
  }
};

// server/services/agent/protocols/AgentKitGoogleProtocol.ts
import Anthropic21 from "@anthropic-ai/sdk";
import OpenAI13 from "openai";
var DEFAULT_MODEL19 = "claude-3-7-sonnet-20250219";
var AgentKitGoogleProtocol = class {
  config = {
    systemPrompt: `You are Agent Kit by Google, a systematic agent development framework.
You excel at:
1. Creating reusable agent components with clear interfaces
2. Scaffolding agents from well-defined components
3. Comprehensive debugging and tracing
4. Reproducible agent development
5. Principled agent design practices`,
    tools: [],
    modelName: DEFAULT_MODEL19,
    temperature: 0.2,
    maxTokens: 2048,
    capabilities: [
      "self_improvement" /* SELF_IMPROVEMENT */,
      "systematic_thinking" /* SYSTEMATIC_THINKING */,
      "tool_use" /* TOOL_USE */
    ]
  };
  anthropicClient = null;
  openaiClient = null;
  availableTools = [];
  initialized = false;
  // Agent Kit state
  componentLibrary = [];
  currentScaffold = null;
  executionState = null;
  taskAnalysis = "";
  /**
   * Get metadata about this protocol
   */
  getMetadata() {
    return {
      name: "Agent Kit by Google",
      version: "1.0.0",
      description: "Systematic agent development framework with scaffolding and debugging",
      capabilities: [
        "self_improvement" /* SELF_IMPROVEMENT */,
        "systematic_thinking" /* SYSTEMATIC_THINKING */,
        "tool_use" /* TOOL_USE */
      ],
      requiresAuthentication: true,
      supportedModels: [
        "claude-3-7-sonnet-20250219",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "gpt-4o",
        "gpt-4-turbo",
        "gpt-4"
      ]
    };
  }
  /**
   * Initialize the protocol with configuration
   */
  async init(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (this.config.modelName?.includes("claude")) {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY environment variable is required for Claude models");
      }
      this.anthropicClient = new Anthropic21({
        apiKey: process.env.ANTHROPIC_API_KEY
      });
    } else if (this.config.modelName?.includes("gpt")) {
      if (!process.env.OPENAI_API_KEY) {
        throw new Error("OPENAI_API_KEY environment variable is required for OpenAI models");
      }
      this.openaiClient = new OpenAI13({
        apiKey: process.env.OPENAI_API_KEY
      });
    }
    this.availableTools = this.config.tools || [];
    this.initializeComponentLibrary();
    this.currentScaffold = null;
    this.executionState = null;
    this.taskAnalysis = "";
    this.initialized = true;
  }
  /**
   * Execute a task using this protocol
   */
  async execute(options2) {
    if (!this.initialized) {
      throw new Error("Protocol not initialized. Call init() first.");
    }
    const startTime2 = Date.now();
    try {
      if (options2.callbacks?.onStart) {
        options2.callbacks.onStart();
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Task Analysis",
          description: "Analyzing task for component selection",
          status: "started"
        });
      }
      await this.analyzeTask(options2.task, options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Task Analysis",
          description: "Task analysis completed",
          output: { analysis: this.taskAnalysis.substring(0, 200) + "..." },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Scaffold Creation",
          description: "Creating agent scaffold from components",
          status: "started"
        });
      }
      await this.createAgentScaffold(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Scaffold Creation",
          description: "Agent scaffold created",
          output: {
            scaffoldName: this.currentScaffold?.name,
            components: this.currentScaffold?.components.length
          },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Agent Execution",
          description: "Executing agent on task",
          status: "started"
        });
      }
      await this.executeAgentScaffold(options2.task, options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Agent Execution",
          description: "Agent execution completed",
          output: {
            traceCount: this.executionState?.debugTraces.length,
            completed: this.executionState?.completed
          },
          status: "completed"
        });
      }
      const finalResponse = this.formatFinalResponse();
      const agentResponse = {
        response: {
          content: finalResponse,
          toolCalls: this.getToolCallsHistory()
        },
        executionTime: Date.now() - startTime2,
        protocol: "agentkitgoogle",
        metadata: {
          scaffold: this.currentScaffold?.name,
          components: this.currentScaffold?.components,
          debugTraces: this.executionState?.debugTraces.length
        }
      };
      if (options2.callbacks?.onComplete) {
        options2.callbacks.onComplete(agentResponse);
      }
      return agentResponse;
    } catch (error) {
      log(`Agent Kit by Google Protocol execution error: ${error}`, "agent");
      if (options2.callbacks?.onError) {
        options2.callbacks.onError(error);
      }
      throw error;
    }
  }
  /**
   * Initialize component library
   */
  initializeComponentLibrary() {
    this.componentLibrary = [
      // Information gathering components
      {
        id: "task_analyser",
        name: "Task Analyzer",
        description: "Analyzes a task to extract key requirements and constraints",
        prompt: `Analyze the given task to identify:
1. Main goal(s) and objectives
2. Key requirements
3. Constraints and limitations
4. Success criteria
5. Potential challenges

Be systematic and comprehensive in your analysis.`,
        inputSchema: {
          task: "string"
        },
        outputSchema: {
          analysis: "string",
          main_goals: "string[]",
          requirements: "string[]",
          constraints: "string[]",
          success_criteria: "string[]",
          challenges: "string[]"
        }
      },
      {
        id: "web_researcher",
        name: "Web Researcher",
        description: "Searches for information on the web",
        prompt: `Search for information relevant to the query. Focus on:
1. Finding reliable and up-to-date sources
2. Extracting key information
3. Providing diverse perspectives when relevant
4. Citing sources properly`,
        inputSchema: {
          query: "string",
          max_results: "number?"
        },
        outputSchema: {
          results: "object[]",
          summary: "string"
        }
      },
      // Planning components
      {
        id: "step_planner",
        name: "Step Planner",
        description: "Creates a step-by-step plan to accomplish a goal",
        prompt: `Create a detailed step-by-step plan to accomplish the given goal. For each step:
1. Provide a clear description of the action
2. Explain why this step is necessary
3. Identify any dependencies on previous steps
4. Note any potential challenges or alternatives

Be thorough and logical in your planning.`,
        inputSchema: {
          goal: "string",
          context: "string?",
          constraints: "string[]?"
        },
        outputSchema: {
          plan: "object[]",
          estimated_completion_time: "string?",
          required_resources: "string[]?"
        }
      },
      {
        id: "decision_maker",
        name: "Decision Maker",
        description: "Evaluates options and makes a decision based on criteria",
        prompt: `Evaluate the given options based on the criteria and make a decision. Consider:
1. How well each option meets each criterion
2. The relative importance of different criteria
3. Any tradeoffs between options
4. Potential risks and uncertainties

Explain your reasoning clearly.`,
        inputSchema: {
          options: "string[]",
          criteria: "string[]",
          context: "string?"
        },
        outputSchema: {
          decision: "string",
          ranking: "object[]",
          reasoning: "string"
        }
      },
      // Execution components
      {
        id: "code_generator",
        name: "Code Generator",
        description: "Generates code based on requirements",
        prompt: `Generate code that satisfies the given requirements. Ensure that:
1. The code is correct, efficient, and follows best practices
2. The code is well-documented with comments
3. Edge cases are handled appropriately
4. The code is secure and robust
5. The code is easy to understand and maintain`,
        inputSchema: {
          requirements: "string",
          language: "string",
          context: "string?"
        },
        outputSchema: {
          code: "string",
          explanation: "string",
          usage_examples: "string?"
        }
      },
      {
        id: "tool_user",
        name: "Tool User",
        description: "Uses available tools to accomplish tasks",
        prompt: `Use the appropriate tools to accomplish the task. Consider:
1. Which tool is most suitable for the specific need
2. How to properly format the input for the tool
3. How to interpret and use the output from the tool
4. Whether multiple tools need to be used in sequence`,
        inputSchema: {
          task: "string",
          available_tools: "string[]",
          context: "string?"
        },
        outputSchema: {
          tool_calls: "object[]",
          result: "string"
        }
      },
      // Content generation components
      {
        id: "content_creator",
        name: "Content Creator",
        description: "Creates various types of content based on specifications",
        prompt: `Create content according to the given specifications. Ensure that:
1. The content meets the specified purpose and audience
2. The content is well-structured and flows logically
3. The content is engaging and effective
4. The content follows the specified style and tone
5. The content is accurate and properly sourced if needed`,
        inputSchema: {
          content_type: "string",
          specifications: "object",
          audience: "string?",
          tone: "string?"
        },
        outputSchema: {
          content: "string",
          notes: "string?"
        }
      },
      {
        id: "summarizer",
        name: "Summarizer",
        description: "Creates concise summaries of longer content",
        prompt: `Create a concise summary of the given content. Focus on:
1. Capturing the main ideas and key points
2. Maintaining accuracy and not distorting the original message
3. Eliminating unnecessary details while preserving important context
4. Using clear and direct language`,
        inputSchema: {
          content: "string",
          max_length: "number?",
          focus_areas: "string[]?"
        },
        outputSchema: {
          summary: "string",
          key_points: "string[]?"
        }
      },
      // Evaluation components
      {
        id: "output_evaluator",
        name: "Output Evaluator",
        description: "Evaluates outputs against criteria",
        prompt: `Evaluate the given output against the specified criteria. Consider:
1. How well the output meets each criterion
2. Any strengths or weaknesses in the output
3. Specific areas for improvement
4. Overall quality and effectiveness

Be objective and specific in your evaluation.`,
        inputSchema: {
          output: "string",
          criteria: "string[]",
          context: "string?"
        },
        outputSchema: {
          evaluation: "object",
          score: "number",
          feedback: "string"
        }
      },
      {
        id: "error_detector",
        name: "Error Detector",
        description: "Identifies errors and issues in outputs",
        prompt: `Carefully examine the given output to identify any errors or issues. Look for:
1. Factual inaccuracies
2. Logical inconsistencies
3. Grammatical or spelling errors
4. Unclear or ambiguous statements
5. Any other problems that affect quality or effectiveness

Be thorough and precise in identifying issues.`,
        inputSchema: {
          output: "string",
          context: "string?",
          reference: "string?"
        },
        outputSchema: {
          errors: "object[]",
          has_critical_errors: "boolean",
          recommendations: "string"
        }
      }
    ];
  }
  /**
   * Analyze the task
   */
  async analyzeTask(task, options2) {
    const analysisPrompt = `As an Agent Kit developer, analyze this task to determine the appropriate components and scaffold:

Task: ${task}

Available Components:
${this.componentLibrary.map((c) => `- ${c.name}: ${c.description}`).join("\n")}

Analyze the task in terms of:
1. The primary objective and key requirements
2. The types of components needed for this task
3. The most effective sequence of component execution
4. Any specific challenges or considerations
5. How tools might be integrated (if needed)

Provide a detailed analysis to guide scaffold creation.`;
    const analysis = await this.getResponseFromLLM(analysisPrompt);
    this.taskAnalysis = analysis;
  }
  /**
   * Create an agent scaffold based on task analysis
   */
  async createAgentScaffold(options2) {
    const scaffoldPrompt = `Based on this task analysis, create an Agent Kit scaffold:

Analysis:
${this.taskAnalysis}

Available Components:
${this.componentLibrary.map((c) => `- ${c.id}: ${c.name} - ${c.description}`).join("\n")}

Create a scaffold that:
1. Has an appropriate name and description
2. Selects the most relevant components (3-7 components)
3. Defines a logical flow between components
4. Includes appropriate conditionals where needed

Respond with a JSON object defining the scaffold with these properties:
{
  "name": "Scaffold name",
  "description": "Scaffold description",
  "components": ["component_id1", "component_id2", ...],
  "flow": [
    {
      "componentId": "component_id1",
      "next": "component_id2",
      "condition": null
    },
    {
      "componentId": "component_id2",
      "next": null,
      "condition": null
    }
  ]
}`;
    const scaffoldResponse = await this.getResponseFromLLM(scaffoldPrompt);
    try {
      const jsonMatch = scaffoldResponse.match(/{[\s\S]*?}/);
      if (jsonMatch) {
        const scaffoldJson = JSON.parse(jsonMatch[0]);
        if (!scaffoldJson.name || !Array.isArray(scaffoldJson.components) || !Array.isArray(scaffoldJson.flow)) {
          throw new Error("Invalid scaffold structure");
        }
        for (const componentId of scaffoldJson.components) {
          if (!this.componentLibrary.some((c) => c.id === componentId)) {
            throw new Error(`Invalid component reference: ${componentId}`);
          }
        }
        this.currentScaffold = scaffoldJson;
      } else {
        throw new Error("Could not extract scaffold JSON");
      }
    } catch (error) {
      log(`Error parsing scaffold definition: ${error}`, "agent");
      this.createFallbackScaffold();
    }
  }
  /**
   * Create a basic fallback scaffold
   */
  createFallbackScaffold() {
    this.currentScaffold = {
      name: "Basic Task Processing Scaffold",
      description: "A simple linear scaffold for analyzing, planning, executing, and evaluating tasks",
      components: ["task_analyser", "step_planner", "tool_user", "output_evaluator"],
      flow: [
        {
          componentId: "task_analyser",
          next: "step_planner",
          condition: null
        },
        {
          componentId: "step_planner",
          next: "tool_user",
          condition: null
        },
        {
          componentId: "tool_user",
          next: "output_evaluator",
          condition: null
        },
        {
          componentId: "output_evaluator",
          next: null,
          condition: null
        }
      ]
    };
  }
  /**
   * Execute the agent scaffold on a task
   */
  async executeAgentScaffold(task, options2) {
    if (!this.currentScaffold) {
      throw new Error("No scaffold available for execution");
    }
    this.executionState = {
      currentComponentId: this.getStartingComponentId(),
      variables: {
        task,
        input: task,
        available_tools: this.availableTools.map((t) => t.name),
        context: ""
      },
      completed: false,
      error: null,
      debugTraces: [],
      startTime: (/* @__PURE__ */ new Date()).toISOString(),
      endTime: null
    };
    const maxSteps = 20;
    let currentStep = 0;
    while (this.executionState.currentComponentId && !this.executionState.completed && currentStep < maxSteps) {
      await this.executeComponent(this.executionState.currentComponentId, options2);
      currentStep++;
    }
    this.executionState.endTime = (/* @__PURE__ */ new Date()).toISOString();
    if (currentStep >= maxSteps && !this.executionState.completed) {
      this.executionState.error = "Maximum number of steps reached";
    }
  }
  /**
   * Get the starting component ID
   */
  getStartingComponentId() {
    if (!this.currentScaffold || !this.currentScaffold.flow || this.currentScaffold.flow.length === 0) {
      return null;
    }
    return this.currentScaffold.flow[0].componentId;
  }
  /**
   * Execute a single component
   */
  async executeComponent(componentId, options2) {
    if (!this.currentScaffold || !this.executionState) {
      throw new Error("Scaffold or execution state not initialized");
    }
    const componentDef = this.componentLibrary.find((c) => c.id === componentId);
    if (!componentDef) {
      throw new Error(`Component not found: ${componentId}`);
    }
    const flowNode = this.currentScaffold.flow.find((f) => f.componentId === componentId);
    if (!flowNode) {
      throw new Error(`Component not found in flow: ${componentId}`);
    }
    const startTime2 = Date.now();
    try {
      const componentInput = this.prepareComponentInput(componentDef, this.executionState.variables);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Component: ${componentDef.name}`,
          description: `Executing ${componentDef.name} component`,
          status: "started"
        });
      }
      const componentOutput = await this.executeComponentLogic(componentDef, componentInput, options2);
      const endTime = Date.now();
      const duration = endTime - startTime2;
      this.executionState.debugTraces.push({
        step: this.executionState.debugTraces.length + 1,
        component: componentId,
        input: componentInput,
        output: componentOutput,
        duration,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
      Object.entries(componentOutput).forEach(([key, value]) => {
        this.executionState.variables[`${componentId}_${key}`] = value;
      });
      if (componentId === "tool_user" && componentOutput.tool_calls) {
        const toolResults = await this.executeToolCalls(componentOutput.tool_calls, options2);
        this.executionState.variables.tool_results = toolResults;
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Component: ${componentDef.name}`,
          description: `Executed ${componentDef.name} component`,
          output: componentOutput,
          status: "completed"
        });
      }
      let nextComponentId = null;
      if (flowNode.condition) {
        const conditionResult = this.evaluateCondition(flowNode.condition, this.executionState.variables);
        nextComponentId = conditionResult ? flowNode.next : null;
      } else {
        nextComponentId = flowNode.next;
      }
      this.executionState.currentComponentId = nextComponentId;
      if (!nextComponentId) {
        this.executionState.completed = true;
      }
    } catch (error) {
      this.executionState.error = error.message;
      this.executionState.debugTraces.push({
        step: this.executionState.debugTraces.length + 1,
        component: componentId,
        input: {},
        // We may not have input in an error case
        output: { error: error.message },
        duration: Date.now() - startTime2,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        annotations: ["error"]
      });
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: `Component: ${componentDef.name}`,
          description: `Error executing ${componentDef.name} component`,
          error: error.message,
          status: "failed"
        });
      }
      this.executionState.completed = true;
    }
  }
  /**
   * Prepare input for a component
   */
  prepareComponentInput(component, variables) {
    const input2 = {};
    Object.entries(component.inputSchema).forEach(([key, type]) => {
      if (variables[key] !== void 0) {
        input2[key] = variables[key];
      } else if (key === "task" && variables.input) {
        input2[key] = variables.input;
      } else if (variables[`${component.id}_${key}`]) {
        input2[key] = variables[`${component.id}_${key}`];
      } else if (type.toString().endsWith("?")) {
      } else {
        if (key === "context" && variables.summary) {
          input2[key] = variables.summary;
        } else if (key === "available_tools") {
          input2[key] = variables.available_tools || [];
        }
      }
    });
    return input2;
  }
  /**
   * Execute component logic
   */
  async executeComponentLogic(component, input2, options2) {
    const componentPrompt = `${component.prompt}

Input:
${JSON.stringify(input2, null, 2)}

Execute this component and provide the output as a JSON object with these fields:
${Object.entries(component.outputSchema).map(([key, type]) => `- ${key}: ${type}`).join("\n")}

Ensure your response is a valid JSON object.`;
    const componentResponse = await this.getResponseFromLLM(componentPrompt);
    try {
      const jsonMatch = componentResponse.match(/{[\s\S]*?}/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      }
      const outputSchema = component.outputSchema;
      const outputWithFallback = {};
      const mainOutputField = Object.keys(outputSchema)[0];
      outputWithFallback[mainOutputField] = componentResponse;
      Object.keys(outputSchema).forEach((key) => {
        if (key !== mainOutputField) {
          const type = outputSchema[key].toString();
          if (type.includes("[]") || type.includes("array")) {
            outputWithFallback[key] = [];
          } else if (type.includes("object")) {
            outputWithFallback[key] = {};
          } else if (type.includes("number")) {
            outputWithFallback[key] = 0;
          } else if (type.includes("boolean")) {
            outputWithFallback[key] = false;
          } else {
            outputWithFallback[key] = "";
          }
        }
      });
      return outputWithFallback;
    } catch (error) {
      log(`Error parsing component output: ${error}`, "agent");
      throw new Error(`Failed to parse component output: ${error}`);
    }
  }
  /**
   * Execute tool calls
   */
  async executeToolCalls(toolCalls, options2) {
    const results = {};
    for (const call of toolCalls) {
      const toolName = call.tool;
      const toolParams = call.params;
      const tool = this.availableTools.find(
        (t) => t.name === toolName || t.name.toLowerCase() === toolName.toLowerCase()
      );
      if (!tool) {
        results[toolName] = { error: `Tool not found: ${toolName}` };
        continue;
      }
      try {
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName: tool.name,
            input: toolParams,
            output: void 0,
            error: void 0
          });
        }
        const toolResult = await tool.execute(toolParams);
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName: tool.name,
            input: toolParams,
            output: toolResult,
            error: void 0
          });
        }
        results[toolName] = toolResult;
      } catch (error) {
        if (options2.callbacks?.onToolUse) {
          options2.callbacks.onToolUse({
            toolName: tool.name,
            input: toolParams,
            output: void 0,
            error: error.message
          });
        }
        results[toolName] = { error: error.message };
      }
    }
    return results;
  }
  /**
   * Evaluate a condition
   */
  evaluateCondition(condition, variables) {
    try {
      if (condition.includes("==")) {
        const [left, right] = condition.split("==").map((s) => s.trim());
        const leftValue = this.getValueFromPath(variables, left);
        return leftValue == right;
      } else if (condition.includes("!=")) {
        const [left, right] = condition.split("!=").map((s) => s.trim());
        const leftValue = this.getValueFromPath(variables, left);
        return leftValue != right;
      } else if (condition.includes(">")) {
        const [left, right] = condition.split(">").map((s) => s.trim());
        const leftValue = this.getValueFromPath(variables, left);
        return leftValue > Number(right);
      } else if (condition.includes("<")) {
        const [left, right] = condition.split("<").map((s) => s.trim());
        const leftValue = this.getValueFromPath(variables, left);
        return leftValue < Number(right);
      } else if (condition.includes("contains")) {
        const [left, right] = condition.split("contains").map((s) => s.trim());
        const leftValue = String(this.getValueFromPath(variables, left));
        return leftValue.includes(right.replace(/['"]/g, ""));
      } else if (condition === "true") {
        return true;
      } else if (condition === "false") {
        return false;
      }
      if (variables[condition] !== void 0) {
        return Boolean(variables[condition]);
      }
      if (condition.includes(".")) {
        return Boolean(this.getValueFromPath(variables, condition));
      }
    } catch (error) {
      log(`Error evaluating condition '${condition}': ${error}`, "agent");
    }
    return true;
  }
  /**
   * Get a value from a nested path (e.g., "result.score")
   */
  getValueFromPath(obj, path6) {
    if (!obj || !path6) {
      return void 0;
    }
    const parts = path6.split(".");
    let current = obj;
    for (const part of parts) {
      if (current === null || current === void 0) {
        return void 0;
      }
      current = current[part];
    }
    return current;
  }
  /**
   * Format the final response
   */
  formatFinalResponse() {
    if (!this.currentScaffold || !this.executionState) {
      return "Error: Agent execution incomplete";
    }
    let response = `# Agent Kit by Google - Execution Report

`;
    response += `## Agent Scaffold: ${this.currentScaffold.name}
`;
    response += `${this.currentScaffold.description}

`;
    response += `## Component Sequence
`;
    response += this.currentScaffold.components.map((cId) => {
      const component = this.componentLibrary.find((c) => c.id === cId);
      return `- ${component?.name} (${cId})`;
    }).join("\n");
    response += `

`;
    response += `## Execution Status
`;
    response += `- **Status**: ${this.executionState.completed ? "Completed" : "Incomplete"}`;
    if (this.executionState.error) {
      response += ` with Error: ${this.executionState.error}`;
    }
    response += `
`;
    if (this.executionState.startTime && this.executionState.endTime) {
      const startTime2 = new Date(this.executionState.startTime);
      const endTime = new Date(this.executionState.endTime);
      const durationMs = endTime.getTime() - startTime2.getTime();
      response += `- **Duration**: ${durationMs}ms
`;
    }
    response += `- **Steps Executed**: ${this.executionState.debugTraces.length}

`;
    response += `## Execution Traces
`;
    for (const trace of this.executionState.debugTraces) {
      const component = this.componentLibrary.find((c) => c.id === trace.component);
      response += `### Step ${trace.step}: ${component?.name}
`;
      response += `- **Duration**: ${trace.duration}ms
`;
      response += `- **Input**:
`;
      response += "```json\n";
      response += JSON.stringify(trace.input, null, 2);
      response += "\n```\n";
      response += `- **Output**:
`;
      response += "```json\n";
      response += JSON.stringify(trace.output, null, 2);
      response += "\n```\n";
      if (trace.annotations && trace.annotations.length > 0) {
        response += `- **Annotations**: ${trace.annotations.join(", ")}
`;
      }
      response += "\n";
    }
    if (this.executionState.completed && this.executionState.debugTraces.length > 0) {
      const lastTrace = this.executionState.debugTraces[this.executionState.debugTraces.length - 1];
      response += `## Final Result
`;
      if (lastTrace.output.error) {
        response += `Error: ${lastTrace.output.error}
`;
      } else {
        const component = this.componentLibrary.find((c) => c.id === lastTrace.component);
        if (component) {
          const mainOutputField = Object.keys(component.outputSchema)[0];
          if (lastTrace.output[mainOutputField]) {
            response += typeof lastTrace.output[mainOutputField] === "string" ? lastTrace.output[mainOutputField] : JSON.stringify(lastTrace.output[mainOutputField], null, 2);
          } else {
            response += JSON.stringify(lastTrace.output, null, 2);
          }
        } else {
          response += JSON.stringify(lastTrace.output, null, 2);
        }
      }
    }
    return response;
  }
  /**
   * Get the tool calls history
   */
  getToolCallsHistory() {
    if (!this.executionState?.variables.tool_results) {
      return void 0;
    }
    const toolResults = this.executionState.variables.tool_results;
    const toolCalls = [];
    for (const [toolName, result2] of Object.entries(toolResults)) {
      let toolParams = {};
      for (const trace of this.executionState.debugTraces) {
        if (trace.component === "tool_user" && trace.output.tool_calls) {
          const matchingCall = trace.output.tool_calls.find((call) => call.tool === toolName);
          if (matchingCall) {
            toolParams = matchingCall.params || {};
            break;
          }
        }
      }
      toolCalls.push({
        name: toolName,
        input: toolParams,
        output: result2
      });
    }
    return toolCalls.length > 0 ? toolCalls : void 0;
  }
  /**
   * Get response from the appropriate LLM based on model name
   */
  async getResponseFromLLM(prompt) {
    try {
      if (this.config.modelName?.includes("claude")) {
        return await this.getResponseFromClaude(prompt);
      } else if (this.config.modelName?.includes("gpt")) {
        return await this.getResponseFromOpenAI(prompt);
      } else {
        return await this.getResponseFromClaude(prompt);
      }
    } catch (error) {
      log(`Error getting LLM response: ${error}`, "agent");
      throw error;
    }
  }
  /**
   * Get response from Claude
   */
  async getResponseFromClaude(prompt) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: this.config.systemPrompt,
      messages: [{ role: "user", content: prompt }]
    });
    return response.content[0].text;
  }
  /**
   * Get response from OpenAI
   */
  async getResponseFromOpenAI(prompt) {
    if (!this.openaiClient) {
      throw new Error("OpenAI client not initialized");
    }
    const response = await this.openaiClient.chat.completions.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      messages: [
        { role: "system", content: this.config.systemPrompt },
        { role: "user", content: prompt }
      ]
    });
    return response.choices[0].message.content || "";
  }
  /**
   * Get available tools
   */
  getAvailableTools() {
    return this.availableTools;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.tools) {
      this.availableTools = config.tools;
    }
  }
  /**
   * Get supported execution modes
   */
  getSupportedExecutionModes() {
    return ["synchronous" /* SYNCHRONOUS */];
  }
  /**
   * Check if protocol supports a specific capability
   */
  supportsCapability(capability) {
    return this.config.capabilities.includes(capability);
  }
  /**
   * Get current protocol configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    this.currentScaffold = null;
    this.executionState = null;
    this.taskAnalysis = "";
    this.initialized = false;
    return Promise.resolve();
  }
};

// server/services/agent/protocols/MCPServerProtocol.ts
import Anthropic22 from "@anthropic-ai/sdk";
import OpenAI14 from "openai";
import { EventEmitter } from "events";
var DEFAULT_MODEL20 = "claude-3-7-sonnet-20250219";
var MCPServerProtocol = class extends EventEmitter {
  config = {
    systemPrompt: `You are the Message Control Protocol (MCP) Server, a distributed coordination system for multi-agent architectures.
You excel at:
1. Agent communication and message routing
2. Task decomposition and delegation
3. Maintaining distributed state
4. Monitoring agent execution
5. Resolving conflicts between agents`,
    tools: [],
    modelName: DEFAULT_MODEL20,
    temperature: 0.3,
    maxTokens: 2048,
    capabilities: [
      "multi_agent" /* MULTI_AGENT */,
      "parallel_execution" /* PARALLEL_EXECUTION */,
      "message_passing" /* MESSAGE_PASSING */
    ]
  };
  anthropicClient = null;
  openaiClient = null;
  availableTools = [];
  initialized = false;
  // MCP Server state
  executionContext = null;
  taskAnalysis = "";
  messageCount = 0;
  toolCallResults = {};
  /**
   * Get metadata about this protocol
   */
  getMetadata() {
    return {
      name: "MCP Server",
      version: "1.0.0",
      description: "Message Control Protocol server for distributed agent communication",
      capabilities: [
        "multi_agent" /* MULTI_AGENT */,
        "parallel_execution" /* PARALLEL_EXECUTION */,
        "message_passing" /* MESSAGE_PASSING */
      ],
      requiresAuthentication: true,
      supportedModels: [
        "claude-3-7-sonnet-20250219",
        "claude-3-opus-20240229",
        "claude-3-sonnet-20240229",
        "gpt-4o",
        "gpt-4-turbo",
        "gpt-4"
      ]
    };
  }
  /**
   * Initialize the protocol with configuration
   */
  async init(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (this.config.modelName?.includes("claude")) {
      if (!process.env.ANTHROPIC_API_KEY) {
        throw new Error("ANTHROPIC_API_KEY environment variable is required for Claude models");
      }
      this.anthropicClient = new Anthropic22({
        apiKey: process.env.ANTHROPIC_API_KEY
      });
    } else if (this.config.modelName?.includes("gpt")) {
      if (!process.env.OPENAI_API_KEY) {
        throw new Error("OPENAI_API_KEY environment variable is required for OpenAI models");
      }
      this.openaiClient = new OpenAI14({
        apiKey: process.env.OPENAI_API_KEY
      });
    }
    this.availableTools = this.config.tools || [];
    this.executionContext = null;
    this.taskAnalysis = "";
    this.messageCount = 0;
    this.toolCallResults = {};
    this.initialized = true;
  }
  /**
   * Execute a task using this protocol
   */
  async execute(options2) {
    if (!this.initialized) {
      throw new Error("Protocol not initialized. Call init() first.");
    }
    const startTime2 = Date.now();
    try {
      if (options2.callbacks?.onStart) {
        options2.callbacks.onStart();
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Task Analysis",
          description: "Analyzing task and creating agent configuration",
          status: "started"
        });
      }
      await this.analyzeTask(options2.task, options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Task Analysis",
          description: "Task analysis completed",
          output: {
            taskAnalysis: this.taskAnalysis.substring(0, 200) + "...",
            agentCount: this.executionContext?.agents.length
          },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "MCP Setup",
          description: "Setting up MCP communication server",
          status: "started"
        });
      }
      await this.setupMCPServer(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "MCP Setup",
          description: "MCP server initialized",
          output: {
            agentCount: this.executionContext?.agents.length,
            messageCount: this.executionContext?.messages.length
          },
          status: "completed"
        });
      }
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Agent Execution",
          description: "Executing agent communication",
          status: "started"
        });
      }
      await this.runMCPSimulation(options2);
      if (options2.callbacks?.onStep) {
        options2.callbacks.onStep({
          name: "Agent Execution",
          description: "Agent execution completed",
          output: {
            status: this.executionContext?.status,
            messageCount: this.executionContext?.messages.length
          },
          status: "completed"
        });
      }
      const finalResponse = this.formatFinalResponse();
      const toolCalls = this.getToolCallsHistory();
      const agentResponse = {
        response: {
          content: finalResponse,
          toolCalls
        },
        executionTime: Date.now() - startTime2,
        protocol: "mcpserver",
        metadata: {
          agentCount: this.executionContext?.agents.length,
          messageCount: this.executionContext?.messages.length,
          executionStatus: this.executionContext?.status
        }
      };
      if (options2.callbacks?.onComplete) {
        options2.callbacks.onComplete(agentResponse);
      }
      return agentResponse;
    } catch (error) {
      log(`MCP Server Protocol execution error: ${error}`, "agent");
      if (options2.callbacks?.onError) {
        options2.callbacks.onError(error);
      }
      throw error;
    }
  }
  /**
   * Analyze task and determine required agents
   */
  async analyzeTask(task, options2) {
    const analysisPrompt = `As the Message Control Protocol (MCP) Server, analyze this task to determine the optimal multi-agent setup:

Task: ${task}

Please provide a detailed analysis including:
1. Main goal and primary objectives
2. Optimal agent roles needed (3-5 specialized agents)
3. Task decomposition into subtasks for each agent
4. Dependencies between subtasks and coordination requirements
5. Potential tools or external resources needed
6. Communication patterns between agents

This analysis will guide the MCP server configuration and agent communication patterns.`;
    const analysis = await this.getResponseFromLLM(analysisPrompt);
    this.taskAnalysis = analysis;
    this.executionContext = {
      agents: [],
      messages: [],
      taskDecomposition: {
        mainGoal: task,
        subTasks: [],
        dependencies: {}
      },
      executionGraph: {
        nodes: [],
        edges: []
      },
      variables: {
        task
      },
      executionLog: [],
      startTime: (/* @__PURE__ */ new Date()).toISOString(),
      status: "running"
    };
    await this.deriveAgentsFromAnalysis(options2);
  }
  /**
   * Create agents based on task analysis
   */
  async deriveAgentsFromAnalysis(options2) {
    if (!this.executionContext) {
      throw new Error("Execution context not initialized");
    }
    const derivePrompt = `Based on this task analysis, create a set of specialized agents for the MCP server:

${this.taskAnalysis}

For each agent, specify:
1. A unique ID and descriptive name
2. A clear role definition
3. A concise description of its responsibilities
4. Key capabilities and skills
5. Initial state (should be "idle")

Then, decompose the main task into appropriate subtasks for each agent, noting any dependencies.

Respond with a structured JSON containing:
1. An array of agent definitions
2. A task decomposition object with subtasks and dependencies
3. An execution graph with nodes (agent+task pairs) and edges (dependencies)`;
    const agentConfigResponse = await this.getResponseFromLLM(derivePrompt);
    try {
      const jsonMatch = agentConfigResponse.match(/{[\s\S]*?}/);
      if (jsonMatch) {
        const configJson = JSON.parse(jsonMatch[0]);
        if (Array.isArray(configJson.agents)) {
          this.executionContext.agents = configJson.agents.map((agent2) => ({
            id: agent2.id,
            name: agent2.name,
            role: agent2.role,
            description: agent2.description,
            capabilities: Array.isArray(agent2.capabilities) ? agent2.capabilities : [],
            state: "idle" /* IDLE */,
            inbox: [],
            outbox: [],
            memory: {}
          }));
        }
        if (configJson.taskDecomposition) {
          this.executionContext.taskDecomposition = {
            mainGoal: configJson.taskDecomposition.mainGoal || this.executionContext.taskDecomposition.mainGoal,
            subTasks: Array.isArray(configJson.taskDecomposition.subTasks) ? configJson.taskDecomposition.subTasks : [],
            dependencies: configJson.taskDecomposition.dependencies || {}
          };
        }
        if (configJson.executionGraph) {
          this.executionContext.executionGraph = {
            nodes: Array.isArray(configJson.executionGraph.nodes) ? configJson.executionGraph.nodes : [],
            edges: Array.isArray(configJson.executionGraph.edges) ? configJson.executionGraph.edges : []
          };
        }
      } else {
        throw new Error("Could not extract agent configuration JSON");
      }
    } catch (error) {
      log(`Error parsing agent configuration: ${error}`, "agent");
      this.createFallbackAgents();
    }
  }
  /**
   * Create basic fallback agents if parsing fails
   */
  createFallbackAgents() {
    if (!this.executionContext) {
      throw new Error("Execution context not initialized");
    }
    this.executionContext.agents = [
      {
        id: "coordinator",
        name: "Task Coordinator",
        role: "Coordinator",
        description: "Manages overall task execution and coordinates other agents",
        capabilities: ["coordination", "planning", "monitoring"],
        state: "idle" /* IDLE */,
        inbox: [],
        outbox: [],
        memory: {}
      },
      {
        id: "researcher",
        name: "Information Researcher",
        role: "Researcher",
        description: "Gathers and analyzes information needed for the task",
        capabilities: ["research", "analysis", "summarization"],
        state: "idle" /* IDLE */,
        inbox: [],
        outbox: [],
        memory: {}
      },
      {
        id: "executor",
        name: "Task Executor",
        role: "Executor",
        description: "Executes specific actions and tool calls",
        capabilities: ["tool_use", "action_execution", "reporting"],
        state: "idle" /* IDLE */,
        inbox: [],
        outbox: [],
        memory: {}
      }
    ];
    this.executionContext.taskDecomposition = {
      mainGoal: this.executionContext.taskDecomposition.mainGoal,
      subTasks: [
        "Analyze task requirements",
        "Research necessary information",
        "Execute required actions",
        "Compile results"
      ],
      dependencies: {
        "Research necessary information": ["Analyze task requirements"],
        "Execute required actions": ["Research necessary information"],
        "Compile results": ["Execute required actions"]
      }
    };
    this.executionContext.executionGraph = {
      nodes: [
        { id: "node1", agentId: "coordinator", task: "Analyze task requirements" },
        { id: "node2", agentId: "researcher", task: "Research necessary information" },
        { id: "node3", agentId: "executor", task: "Execute required actions" },
        { id: "node4", agentId: "coordinator", task: "Compile results" }
      ],
      edges: [
        { source: "node1", target: "node2" },
        { source: "node2", target: "node3" },
        { source: "node3", target: "node4" }
      ]
    };
  }
  /**
   * Setup the MCP server
   */
  async setupMCPServer(options2) {
    if (!this.executionContext) {
      throw new Error("Execution context not initialized");
    }
    const systemMessage2 = this.createMessage(
      "system" /* SYSTEM */,
      "mcp_server",
      this.executionContext.agents.map((a) => a.id),
      {
        action: "server_initialized",
        mainGoal: this.executionContext.taskDecomposition.mainGoal,
        agentCount: this.executionContext.agents.length
      },
      10
    );
    this.executionContext.messages.push(systemMessage2);
    const initialNodes = this.executionContext.executionGraph.nodes.filter(
      (node) => !this.executionContext.executionGraph.edges.some((edge) => edge.target === node.id)
    );
    for (const node of initialNodes) {
      const agent2 = this.executionContext.agents.find((a) => a.id === node.agentId);
      if (agent2) {
        const commandMessage = this.createMessage(
          "command" /* COMMAND */,
          "mcp_server",
          [agent2.id],
          {
            action: "execute_task",
            task: node.task,
            nodeId: node.id,
            context: this.executionContext.taskDecomposition.mainGoal
          },
          5
        );
        this.executionContext.messages.push(commandMessage);
        agent2.inbox.push(commandMessage);
        agent2.state = "waiting" /* WAITING */;
        this.executionContext.executionLog.push(
          `[${(/* @__PURE__ */ new Date()).toISOString()}] Assigned task "${node.task}" to agent ${agent2.name}`
        );
      }
    }
  }
  /**
   * Run the MCP simulation
   */
  async runMCPSimulation(options2) {
    if (!this.executionContext) {
      throw new Error("Execution context not initialized");
    }
    const maxSteps = 15;
    let currentStep = 0;
    while (this.executionContext.agents.some((a) => a.state !== "completed" /* COMPLETED */ && a.state !== "failed" /* FAILED */) && currentStep < maxSteps && this.executionContext.status === "running") {
      await this.processMCPStep(options2);
      currentStep++;
    }
    const allCompleted = this.executionContext.agents.every(
      (a) => a.state === "completed" /* COMPLETED */ || a.state === "failed" /* FAILED */
    );
    if (allCompleted) {
      this.executionContext.status = "completed";
      this.executionContext.endTime = (/* @__PURE__ */ new Date()).toISOString();
      const completionMessage = this.createMessage(
        "system" /* SYSTEM */,
        "mcp_server",
        this.executionContext.agents.map((a) => a.id),
        {
          action: "execution_completed",
          status: "completed",
          totalSteps: currentStep,
          totalMessages: this.executionContext.messages.length
        },
        10
      );
      this.executionContext.messages.push(completionMessage);
      this.executionContext.executionLog.push(
        `[${(/* @__PURE__ */ new Date()).toISOString()}] MCP execution completed after ${currentStep} steps`
      );
    } else if (currentStep >= maxSteps) {
      this.executionContext.status = "failed";
      this.executionContext.endTime = (/* @__PURE__ */ new Date()).toISOString();
      const timeoutMessage = this.createMessage(
        "system" /* SYSTEM */,
        "mcp_server",
        this.executionContext.agents.map((a) => a.id),
        {
          action: "execution_timeout",
          status: "failed",
          reason: "Maximum simulation steps reached",
          totalSteps: currentStep
        },
        10
      );
      this.executionContext.messages.push(timeoutMessage);
      this.executionContext.executionLog.push(
        `[${(/* @__PURE__ */ new Date()).toISOString()}] MCP execution timed out after ${maxSteps} steps`
      );
    }
  }
  /**
   * Process a single step of the MCP simulation
   */
  async processMCPStep(options2) {
    if (!this.executionContext) {
      throw new Error("Execution context not initialized");
    }
    for (const agent2 of this.executionContext.agents) {
      if (agent2.state === "completed" /* COMPLETED */ || agent2.state === "failed" /* FAILED */) {
        continue;
      }
      if (agent2.inbox.length > 0 && agent2.state === "waiting" /* WAITING */) {
        await this.processAgentInbox(agent2, options2);
      }
    }
    for (const agent2 of this.executionContext.agents) {
      if (agent2.outbox.length > 0) {
        await this.processAgentOutbox(agent2);
      }
    }
    await this.checkAndStartDependentTasks();
  }
  /**
   * Process an agent's inbox
   */
  async processAgentInbox(agent2, options2) {
    if (!this.executionContext) {
      throw new Error("Execution context not initialized");
    }
    agent2.state = "thinking" /* THINKING */;
    const messages = [...agent2.inbox].sort((a, b) => b.priority - a.priority);
    const currentMessage = messages[0];
    agent2.inbox = agent2.inbox.filter((m) => m.id !== currentMessage.id);
    this.executionContext.executionLog.push(
      `[${(/* @__PURE__ */ new Date()).toISOString()}] Agent ${agent2.name} processing message: ${currentMessage.type}`
    );
    try {
      agent2.state = "executing" /* EXECUTING */;
      const agentResponse = await this.generateAgentResponse(agent2, currentMessage, options2);
      agent2.outbox.push(agentResponse);
      agent2.state = "waiting" /* WAITING */;
    } catch (error) {
      this.executionContext.executionLog.push(
        `[${(/* @__PURE__ */ new Date()).toISOString()}] Agent ${agent2.name} failed to process message: ${error.message}`
      );
      const errorMessage = this.createMessage(
        "error" /* ERROR */,
        agent2.id,
        ["mcp_server"],
        {
          error: error.message,
          originalMessage: currentMessage.id
        },
        10
      );
      agent2.outbox.push(errorMessage);
      agent2.state = "waiting" /* WAITING */;
    }
  }
  /**
   * Generate an agent's response to a message
   */
  async generateAgentResponse(agent2, message, options2) {
    if (message.type === "command" /* COMMAND */ && message.content.action === "execute_task") {
      return this.executeAgentTask(agent2, message, options2);
    } else if (message.type === "response" /* RESPONSE */ || message.type === "notification" /* NOTIFICATION */) {
      return this.processAgentInformation(agent2, message);
    } else {
      const responsePrompt = `You are acting as the agent "${agent2.name}" (${agent2.role}) with the following description: ${agent2.description}.

You have received this message:
${JSON.stringify(message, null, 2)}

Based on your role and capabilities ${JSON.stringify(agent2.capabilities)}, how do you respond to this message?
Your response should include:
1. Your understanding of the message
2. Any actions you would take
3. The content of your response message

Keep your response concise and focused on your specific role.`;
      const responseContent = await this.getResponseFromLLM(responsePrompt);
      return this.createMessage(
        "response" /* RESPONSE */,
        agent2.id,
        message.sender === "mcp_server" ? ["mcp_server"] : [message.sender],
        {
          originalMessageId: message.id,
          content: responseContent
        },
        7
      );
    }
  }
  /**
   * Execute a task with an agent
   */
  async executeAgentTask(agent2, message, options2) {
    if (!this.executionContext) {
      throw new Error("Execution context not initialized");
    }
    const task = message.content.task;
    const nodeId = message.content.nodeId;
    this.executionContext.executionLog.push(
      `[${(/* @__PURE__ */ new Date()).toISOString()}] Agent ${agent2.name} executing task: ${task}`
    );
    const taskPrompt = `You are acting as the agent "${agent2.name}" (${agent2.role}) with the following description: ${agent2.description}.

You are part of a multi-agent system working on this main goal: ${this.executionContext.taskDecomposition.mainGoal}

Your specific task is: ${task}

Your capabilities include: ${agent2.capabilities.join(", ")}

Available tools: ${this.availableTools.map((t) => t.name).join(", ")}

Think step by step about how to accomplish this task:
1. Analyze what information you need
2. Determine what actions to take or tools to use
3. Consider how your work fits into the larger goal
4. Identify what information to share with other agents

Then execute the task and provide:
1. Your results or findings
2. Any tool calls you need to make (if applicable)
3. Recommendations for next steps
4. Information that should be shared with other agents`;
    const taskExecution = await this.getResponseFromLLM(taskPrompt);
    const toolCallMatch = taskExecution.match(/Tool Call:[\s\S]*?```(?:json)?\s*([\s\S]*?)```/i);
    let toolResults = null;
    if (toolCallMatch && toolCallMatch[1]) {
      try {
        const toolCallJson = JSON.parse(toolCallMatch[1].trim());
        const toolName = toolCallJson.tool || toolCallJson.name;
        const toolInput = toolCallJson.input || toolCallJson.parameters || toolCallJson.params || {};
        const tool = this.availableTools.find(
          (t) => t.name === toolName || t.name.toLowerCase() === toolName.toLowerCase()
        );
        if (tool) {
          if (options2.callbacks?.onToolUse) {
            options2.callbacks.onToolUse({
              toolName: tool.name,
              input: toolInput,
              output: void 0,
              error: void 0
            });
          }
          try {
            const result2 = await tool.execute(toolInput);
            if (options2.callbacks?.onToolUse) {
              options2.callbacks.onToolUse({
                toolName: tool.name,
                input: toolInput,
                output: result2,
                error: void 0
              });
            }
            toolResults = {
              tool: tool.name,
              input: toolInput,
              output: result2
            };
            this.toolCallResults[`${agent2.id}_${this.messageCount}`] = toolResults;
            this.executionContext.executionLog.push(
              `[${(/* @__PURE__ */ new Date()).toISOString()}] Agent ${agent2.name} executed tool ${tool.name}`
            );
          } catch (error) {
            if (options2.callbacks?.onToolUse) {
              options2.callbacks.onToolUse({
                toolName: tool.name,
                input: toolInput,
                output: void 0,
                error: error.message
              });
            }
            toolResults = {
              tool: tool.name,
              input: toolInput,
              error: error.message
            };
            this.toolCallResults[`${agent2.id}_${this.messageCount}`] = toolResults;
            this.executionContext.executionLog.push(
              `[${(/* @__PURE__ */ new Date()).toISOString()}] Agent ${agent2.name} tool error: ${error.message}`
            );
          }
        }
      } catch (error) {
        this.executionContext.executionLog.push(
          `[${(/* @__PURE__ */ new Date()).toISOString()}] Error parsing tool call: ${error.message}`
        );
      }
    }
    const taskCompletionMessage = this.createMessage(
      "response" /* RESPONSE */,
      agent2.id,
      ["mcp_server"],
      {
        nodeId,
        task,
        status: "completed",
        result: taskExecution,
        toolCall: toolResults
      },
      8
    );
    const sharingMatch = taskExecution.match(/Information for other agents:[\s\S]*?((?:Agent|For|Share with)[\s\S]*?)(?:\n\n|$)/i);
    if (sharingMatch) {
      const sharingText = sharingMatch[1];
      const targetAgents = this.executionContext.agents.filter((a) => a.id !== agent2.id && sharingText.toLowerCase().includes(a.name.toLowerCase()));
      if (targetAgents.length > 0) {
        const sharingMessage = this.createMessage(
          "notification" /* NOTIFICATION */,
          agent2.id,
          targetAgents.map((a) => a.id),
          {
            type: "information_sharing",
            task,
            information: sharingText
          },
          6
        );
        agent2.outbox.push(sharingMessage);
      }
    }
    return taskCompletionMessage;
  }
  /**
   * Process information from another agent
   */
  async processAgentInformation(agent2, message) {
    if (!agent2.memory.information) {
      agent2.memory.information = [];
    }
    agent2.memory.information.push({
      from: message.sender,
      timestamp: message.timestamp,
      content: message.content
    });
    return this.createMessage(
      "response" /* RESPONSE */,
      agent2.id,
      [message.sender],
      {
        type: "acknowledgment",
        originalMessageId: message.id,
        status: "received"
      },
      5
    );
  }
  /**
   * Process an agent's outbox
   */
  async processAgentOutbox(agent2) {
    if (!this.executionContext) {
      throw new Error("Execution context not initialized");
    }
    for (const message of agent2.outbox) {
      this.executionContext.messages.push(message);
      for (const recipientId of message.recipients) {
        if (recipientId === "mcp_server") {
          if (message.type === "response" /* RESPONSE */ && message.content.status === "completed" && message.content.nodeId) {
            const node = this.executionContext.executionGraph.nodes.find(
              (n) => n.id === message.content.nodeId
            );
            if (node) {
              this.executionContext.executionLog.push(
                `[${(/* @__PURE__ */ new Date()).toISOString()}] Completed execution node: ${node.id} (${node.task})`
              );
              const remainingTasks = this.executionContext.executionGraph.nodes.filter(
                (n) => n.agentId === agent2.id && !this.isNodeCompleted(n.id)
              );
              if (remainingTasks.length === 0) {
                agent2.state = "completed" /* COMPLETED */;
                this.executionContext.executionLog.push(
                  `[${(/* @__PURE__ */ new Date()).toISOString()}] Agent ${agent2.name} completed all tasks`
                );
              }
            }
          }
        } else {
          const recipientAgent = this.executionContext.agents.find((a) => a.id === recipientId);
          if (recipientAgent) {
            recipientAgent.inbox.push(message);
          }
        }
      }
    }
    agent2.outbox = [];
  }
  /**
   * Check if a node has been completed
   */
  isNodeCompleted(nodeId) {
    if (!this.executionContext) {
      return false;
    }
    return this.executionContext.messages.some(
      (m) => m.type === "response" /* RESPONSE */ && m.content.nodeId === nodeId && m.content.status === "completed"
    );
  }
  /**
   * Check for dependent tasks that can now be started
   */
  async checkAndStartDependentTasks() {
    if (!this.executionContext) {
      return;
    }
    const completedNodeIds = this.executionContext.executionGraph.nodes.filter((node) => this.isNodeCompleted(node.id)).map((node) => node.id);
    const availableNodes = this.executionContext.executionGraph.nodes.filter((node) => {
      if (this.isNodeCompleted(node.id)) {
        return false;
      }
      const dependencies = this.executionContext.executionGraph.edges.filter((edge) => edge.target === node.id).map((edge) => edge.source);
      return dependencies.every((depId) => completedNodeIds.includes(depId));
    });
    for (const node of availableNodes) {
      const agent2 = this.executionContext.agents.find((a) => a.id === node.agentId);
      if (agent2 && agent2.state !== "failed" /* FAILED */) {
        const commandMessage = this.createMessage(
          "command" /* COMMAND */,
          "mcp_server",
          [agent2.id],
          {
            action: "execute_task",
            task: node.task,
            nodeId: node.id,
            context: this.executionContext.taskDecomposition.mainGoal
          },
          5
        );
        this.executionContext.messages.push(commandMessage);
        agent2.inbox.push(commandMessage);
        if (agent2.state === "idle" /* IDLE */) {
          agent2.state = "waiting" /* WAITING */;
        }
        this.executionContext.executionLog.push(
          `[${(/* @__PURE__ */ new Date()).toISOString()}] Assigned task "${node.task}" to agent ${agent2.name}`
        );
      }
    }
  }
  /**
   * Create a new MCP message
   */
  createMessage(type, sender, recipients, content2, priority = 5) {
    this.messageCount++;
    return {
      id: `msg_${Date.now()}_${this.messageCount}`,
      type,
      sender,
      recipients,
      content: content2,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      priority
    };
  }
  /**
   * Format the final response
   */
  formatFinalResponse() {
    if (!this.executionContext) {
      return "Error: MCP server execution incomplete";
    }
    let response = `# MCP Server - Multi-Agent Execution Report

`;
    response += `## Execution Status
`;
    response += `- **Status**: ${this.executionContext.status}
`;
    if (this.executionContext.startTime && this.executionContext.endTime) {
      const startTime2 = new Date(this.executionContext.startTime);
      const endTime = new Date(this.executionContext.endTime);
      const durationMs = endTime.getTime() - startTime2.getTime();
      response += `- **Duration**: ${durationMs}ms
`;
    }
    response += `- **Agent Count**: ${this.executionContext.agents.length}
`;
    response += `- **Message Count**: ${this.executionContext.messages.length}

`;
    response += `## Task Decomposition
`;
    response += `### Main Goal
${this.executionContext.taskDecomposition.mainGoal}

`;
    response += `### Subtasks
`;
    for (const subtask of this.executionContext.taskDecomposition.subTasks) {
      response += `- ${subtask}
`;
    }
    response += `
`;
    response += `## Agent Summary
`;
    for (const agent2 of this.executionContext.agents) {
      response += `### ${agent2.name} (${agent2.role})
`;
      response += `- **Status**: ${agent2.state}
`;
      response += `- **Description**: ${agent2.description}
`;
      const assignedTasks = this.executionContext.executionGraph.nodes.filter((node) => node.agentId === agent2.id);
      response += `- **Tasks**: ${assignedTasks.length}
`;
      response += `- **Capabilities**: ${agent2.capabilities.join(", ")}

`;
    }
    response += `## Execution Highlights
`;
    const highlightLogs = this.executionContext.executionLog.filter(
      (log2) => log2.includes("task") || log2.includes("complete") || log2.includes("executed tool") || log2.includes("error")
    ).slice(-10);
    for (const log2 of highlightLogs) {
      response += `${log2}
`;
    }
    response += `
`;
    response += `## Results and Findings
`;
    const resultMessages = this.executionContext.messages.filter(
      (m) => m.type === "response" /* RESPONSE */ && m.content.status === "completed" || m.type === "system" /* SYSTEM */ && m.content.action === "execution_completed"
    ).sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
    if (resultMessages.length > 0) {
      const completionResults = resultMessages.filter((m) => m.type === "response" /* RESPONSE */ && m.content.result).slice(0, 3);
      for (const result2 of completionResults) {
        const agent2 = this.executionContext.agents.find((a) => a.id === result2.sender);
        response += `### From ${agent2 ? agent2.name : result2.sender}
`;
        let resultText = result2.content.result;
        resultText = resultText.replace(/Tool Call:[\s\S]*?```(?:json)?\s*[\s\S]*?```/i, "[Tool Call Executed]");
        response += resultText + "\n\n";
      }
    } else {
      response += `No final results available.

`;
    }
    if (Object.keys(this.toolCallResults).length > 0) {
      response += `## Tool Usage Summary
`;
      for (const [key, result2] of Object.entries(this.toolCallResults)) {
        const [agentId] = key.split("_");
        const agent2 = this.executionContext.agents.find((a) => a.id === agentId);
        response += `### ${agent2 ? agent2.name : agentId} - ${result2.tool}
`;
        response += `**Input**: \`${JSON.stringify(result2.input)}\`
`;
        if (result2.error) {
          response += `**Error**: ${result2.error}
`;
        } else if (result2.output) {
          const output = result2.output;
          response += `**Output**: `;
          if (typeof output === "object") {
            response += "\n```\n" + JSON.stringify(output, null, 2) + "\n```\n";
          } else {
            response += `${output}
`;
          }
        }
        response += "\n";
      }
    }
    return response;
  }
  /**
   * Get the tool calls history
   */
  getToolCallsHistory() {
    const toolCalls = [];
    for (const result2 of Object.values(this.toolCallResults)) {
      if (result2.tool) {
        toolCalls.push({
          name: result2.tool,
          input: result2.input || {},
          output: result2.error ? { error: result2.error } : result2.output
        });
      }
    }
    return toolCalls.length > 0 ? toolCalls : void 0;
  }
  /**
   * Get response from the appropriate LLM based on model name
   */
  async getResponseFromLLM(prompt) {
    try {
      if (this.config.modelName?.includes("claude")) {
        return await this.getResponseFromClaude(prompt);
      } else if (this.config.modelName?.includes("gpt")) {
        return await this.getResponseFromOpenAI(prompt);
      } else {
        return await this.getResponseFromClaude(prompt);
      }
    } catch (error) {
      log(`Error getting LLM response: ${error}`, "agent");
      throw error;
    }
  }
  /**
   * Get response from Claude
   */
  async getResponseFromClaude(prompt) {
    if (!this.anthropicClient) {
      throw new Error("Anthropic client not initialized");
    }
    const response = await this.anthropicClient.messages.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      system: this.config.systemPrompt,
      messages: [{ role: "user", content: prompt }]
    });
    return response.content[0].text;
  }
  /**
   * Get response from OpenAI
   */
  async getResponseFromOpenAI(prompt) {
    if (!this.openaiClient) {
      throw new Error("OpenAI client not initialized");
    }
    const response = await this.openaiClient.chat.completions.create({
      model: this.config.modelName,
      max_tokens: this.config.maxTokens,
      temperature: this.config.temperature,
      messages: [
        { role: "system", content: this.config.systemPrompt },
        { role: "user", content: prompt }
      ]
    });
    return response.choices[0].message.content || "";
  }
  /**
   * Get available tools
   */
  getAvailableTools() {
    return this.availableTools;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
    if (config.tools) {
      this.availableTools = config.tools;
    }
  }
  /**
   * Get supported execution modes
   */
  getSupportedExecutionModes() {
    return ["synchronous" /* SYNCHRONOUS */, "asynchronous" /* ASYNCHRONOUS */];
  }
  /**
   * Check if protocol supports a specific capability
   */
  supportsCapability(capability) {
    return this.config.capabilities.includes(capability);
  }
  /**
   * Get current protocol configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    this.executionContext = null;
    this.taskAnalysis = "";
    this.messageCount = 0;
    this.toolCallResults = {};
    this.initialized = false;
    this.removeAllListeners();
    return Promise.resolve();
  }
};

// server/services/agent/AgentOperationLayer.ts
import OpenAI15 from "openai";
var AgentStrength = /* @__PURE__ */ ((AgentStrength3) => {
  AgentStrength3["AUTONOMOUS_TASKING"] = "autonomous_tasking";
  AgentStrength3["MULTI_AGENT_TEAMWORK"] = "multi_agent_teamwork";
  AgentStrength3["MICRO_TASK_HANDLING"] = "micro_task_handling";
  AgentStrength3["CONTENT_SOCIAL_OPS"] = "content_social_ops";
  AgentStrength3["CREATIVE_ROLEPLAY"] = "creative_roleplay";
  AgentStrength3["DEVOPS_CODE"] = "devops_code";
  AgentStrength3["FALLBACK_SELF_HEALING"] = "fallback_self_healing";
  AgentStrength3["BUILD_ANYTHING"] = "build_anything";
  AgentStrength3["CONNECTION_PROTOCOL"] = "connection_protocol";
  return AgentStrength3;
})(AgentStrength || {});
var AgentOperationLayer = class _AgentOperationLayer {
  static instance;
  registry;
  classifications = /* @__PURE__ */ new Map();
  constructor() {
    this.registry = ProtocolRegistry.getInstance();
    this.initializeClassifications();
  }
  /**
   * Get singleton instance
   */
  static getInstance() {
    if (!_AgentOperationLayer.instance) {
      _AgentOperationLayer.instance = new _AgentOperationLayer();
    }
    return _AgentOperationLayer.instance;
  }
  /**
   * Initialize the agent classifications
   */
  initializeClassifications() {
    this.addClassification({
      protocol: "AgentGPT",
      name: "AgentGPT",
      primaryStrength: "autonomous_tasking" /* AUTONOMOUS_TASKING */,
      secondaryStrengths: ["fallback_self_healing" /* FALLBACK_SELF_HEALING */],
      description: "General-purpose autonomous agent capable of executing complex tasks with reasoning.",
      bestUseCases: [
        "Complex research tasks requiring multiple steps",
        "Autonomous task planning and execution",
        "Generating detailed reports and analyses"
      ],
      limitations: [
        "Less effective for multi-agent collaborative tasks",
        "May struggle with very specialized domain knowledge",
        "No built-in code generation capabilities"
      ],
      complexity: "beginner",
      integrationLevel: "standalone"
    });
    this.addClassification({
      protocol: "AutoGPT",
      name: "Auto-GPT",
      primaryStrength: "autonomous_tasking" /* AUTONOMOUS_TASKING */,
      secondaryStrengths: ["build_anything" /* BUILD_ANYTHING */],
      description: "Advanced autonomous agent capable of executing multi-step tasks with memory and planning.",
      bestUseCases: [
        "Complex problem solving requiring multiple sub-tasks",
        "Projects requiring memory of previous steps",
        "Tasks needing adaptive planning"
      ],
      limitations: [
        "High token consumption",
        "Can be slow for complex tasks",
        "May occasionally get stuck in loops"
      ],
      complexity: "intermediate",
      integrationLevel: "standalone"
    });
    this.addClassification({
      protocol: "BabyAGI",
      name: "BabyAGI",
      primaryStrength: "autonomous_tasking" /* AUTONOMOUS_TASKING */,
      secondaryStrengths: ["fallback_self_healing" /* FALLBACK_SELF_HEALING */],
      description: "Lightweight autonomous agent focused on task prioritization and execution.",
      bestUseCases: [
        "Task management with dynamic prioritization",
        "Projects requiring incremental progress tracking",
        "Research with evolving objectives"
      ],
      limitations: [
        "Limited memory compared to larger agents",
        "Less sophisticated planning than AutoGPT",
        "Not designed for multi-agent collaboration"
      ],
      complexity: "beginner",
      integrationLevel: "standalone"
    });
    this.addClassification({
      protocol: "LangChain",
      name: "LangChain Protocol",
      primaryStrength: "connection_protocol" /* CONNECTION_PROTOCOL */,
      secondaryStrengths: ["build_anything" /* BUILD_ANYTHING */],
      description: "Orchestration layer for connecting LLMs with external systems and tools.",
      bestUseCases: [
        "Building complex AI application workflows",
        "Tasks requiring integration with external tools",
        "Creating composable AI systems"
      ],
      limitations: [
        "Requires programming knowledge to implement",
        "Overhead for simple use cases",
        "API may change with version updates"
      ],
      complexity: "intermediate",
      integrationLevel: "integrated"
    });
    this.addClassification({
      protocol: "MetaGPT",
      name: "MetaGPT",
      primaryStrength: "multi_agent_teamwork" /* MULTI_AGENT_TEAMWORK */,
      secondaryStrengths: ["devops_code" /* DEVOPS_CODE */],
      description: "Multi-agent system that simulates a software development team with specialized roles.",
      bestUseCases: [
        "Complete software application development",
        "Software architecture design",
        "Code generation with documentation"
      ],
      limitations: [
        "High token consumption across multiple agents",
        "Best for software-specific tasks",
        "Complex setup and configuration"
      ],
      complexity: "advanced",
      integrationLevel: "orchestration"
    });
    this.addClassification({
      protocol: "CrewAI",
      name: "CrewAI",
      primaryStrength: "multi_agent_teamwork" /* MULTI_AGENT_TEAMWORK */,
      secondaryStrengths: ["autonomous_tasking" /* AUTONOMOUS_TASKING */],
      description: "Framework for creating teams of AI agents with different roles working together.",
      bestUseCases: [
        "Complex projects requiring multiple perspectives",
        "Tasks that benefit from specialized agent roles",
        "Collaborative problem-solving with role-based agents"
      ],
      limitations: [
        "Increased complexity in setup",
        "Higher inference costs with multiple agents",
        "Can be overkill for simple tasks"
      ],
      complexity: "intermediate",
      integrationLevel: "orchestration"
    });
    this.addClassification({
      protocol: "AutoGen",
      name: "AutoGen",
      primaryStrength: "multi_agent_teamwork" /* MULTI_AGENT_TEAMWORK */,
      secondaryStrengths: ["creative_roleplay" /* CREATIVE_ROLEPLAY */],
      description: "Framework for building conversational agents that can work together in versatile configurations.",
      bestUseCases: [
        "Human-AI collaborative workflows",
        "Multi-agent conversations",
        "Assistant-user-human conversational structures"
      ],
      limitations: [
        "Less structured than CrewAI for specific roles",
        "Requires more guidance for specialized tasks",
        "Works best with well-defined interaction patterns"
      ],
      complexity: "intermediate",
      integrationLevel: "orchestration"
    });
    this.addClassification({
      protocol: "SmolAgents",
      name: "SmolAgents",
      primaryStrength: "micro_task_handling" /* MICRO_TASK_HANDLING */,
      secondaryStrengths: ["build_anything" /* BUILD_ANYTHING */],
      description: "Lightweight, efficient agents designed for focused micro-tasks.",
      bestUseCases: [
        "Simple, specific tasks with clear parameters",
        "Scenarios requiring minimal token usage",
        "Applications with many small task components"
      ],
      limitations: [
        "Limited reasoning for complex tasks",
        "Not suitable for tasks requiring extensive context",
        "Less autonomous than larger agent frameworks"
      ],
      complexity: "beginner",
      integrationLevel: "integrated"
    });
    this.addClassification({
      protocol: "OpenInterpreter",
      name: "Open Interpreter",
      primaryStrength: "micro_task_handling" /* MICRO_TASK_HANDLING */,
      secondaryStrengths: ["devops_code" /* DEVOPS_CODE */],
      description: "Natural language to code execution agent with local runtime capabilities.",
      bestUseCases: [
        "Converting natural language to executable code",
        "Performing system operations through conversation",
        "Automating programming and data analysis tasks"
      ],
      limitations: [
        "Focused primarily on code execution",
        "Security considerations for arbitrary code execution",
        "Less suited for non-coding tasks"
      ],
      complexity: "intermediate",
      integrationLevel: "standalone"
    });
    this.addClassification({
      protocol: "KUSHAI",
      name: "KUSH AI",
      primaryStrength: "content_social_ops" /* CONTENT_SOCIAL_OPS */,
      secondaryStrengths: ["creative_roleplay" /* CREATIVE_ROLEPLAY */],
      description: "Specialized agent for social media content creation and optimization.",
      bestUseCases: [
        "Creating engaging social media content",
        "Planning content calendars and strategies",
        "Analyzing social media performance metrics"
      ],
      limitations: [
        "Specialized for social media use cases",
        "Less effective for general-purpose tasks",
        "May need fine-tuning for brand-specific voice"
      ],
      complexity: "beginner",
      integrationLevel: "standalone"
    });
    this.addClassification({
      protocol: "InstagramAgent",
      name: "Instagram Agent",
      primaryStrength: "content_social_ops" /* CONTENT_SOCIAL_OPS */,
      secondaryStrengths: ["creative_roleplay" /* CREATIVE_ROLEPLAY */],
      description: "Agent specialized for Instagram content creation and strategy.",
      bestUseCases: [
        "Creating Instagram-optimized captions and content",
        "Planning visual content strategies",
        "Analyzing Instagram engagement metrics"
      ],
      limitations: [
        "Platform-specific to Instagram",
        "Limited to social media context",
        "Requires integration with visual content tools"
      ],
      complexity: "beginner",
      integrationLevel: "standalone"
    });
    this.addClassification({
      protocol: "RionaAI",
      name: "Riona AI",
      primaryStrength: "content_social_ops" /* CONTENT_SOCIAL_OPS */,
      secondaryStrengths: ["creative_roleplay" /* CREATIVE_ROLEPLAY */],
      description: "Conversational agent designed for engaging personality-driven interactions.",
      bestUseCases: [
        "Creating engaging conversational content",
        "Personal assistant interactions",
        "Character-based customer service"
      ],
      limitations: [
        "Less suited for analytical tasks",
        "Optimized for conversation rather than problem-solving",
        "May vary in quality based on personality settings"
      ],
      complexity: "intermediate",
      integrationLevel: "standalone"
    });
    this.addClassification({
      protocol: "CamelAI",
      name: "Camel AI",
      primaryStrength: "creative_roleplay" /* CREATIVE_ROLEPLAY */,
      secondaryStrengths: ["multi_agent_teamwork" /* MULTI_AGENT_TEAMWORK */],
      description: "AI framework for role-playing and simulating character interactions.",
      bestUseCases: [
        "Role-based creative writing and storytelling",
        "Simulating conversations between different personas",
        "Education through simulated scenarios"
      ],
      limitations: [
        "Less suited for analytical or data-driven tasks",
        "May generate creative rather than factual outputs",
        "Not optimized for problem-solving tasks"
      ],
      complexity: "intermediate",
      integrationLevel: "integrated"
    });
    this.addClassification({
      protocol: "PRAgent",
      name: "PR Agent",
      primaryStrength: "devops_code" /* DEVOPS_CODE */,
      secondaryStrengths: ["fallback_self_healing" /* FALLBACK_SELF_HEALING */],
      description: "Specialized agent for code review and pull request analysis.",
      bestUseCases: [
        "Automated code review for pull requests",
        "Identifying code quality issues",
        "Suggesting code improvements"
      ],
      limitations: [
        "Specialized for code review use cases",
        "Language and framework limitations",
        "May require domain-specific knowledge"
      ],
      complexity: "advanced",
      integrationLevel: "integrated"
    });
    this.addClassification({
      protocol: "AllHands",
      name: "All-Hands",
      primaryStrength: "devops_code" /* DEVOPS_CODE */,
      secondaryStrengths: ["fallback_self_healing" /* FALLBACK_SELF_HEALING */],
      description: "Agent focused on generating and executing test cases for code.",
      bestUseCases: [
        "Generating comprehensive test cases",
        "Test-driven development assistance",
        "Finding edge cases in code"
      ],
      limitations: [
        "Focuses primarily on testing",
        "Language and framework limitations",
        "May need guidance for complex systems"
      ],
      complexity: "advanced",
      integrationLevel: "integrated"
    });
    this.addClassification({
      protocol: "AutoBuilder",
      name: "AutoBuilder",
      primaryStrength: "devops_code" /* DEVOPS_CODE */,
      secondaryStrengths: ["build_anything" /* BUILD_ANYTHING */],
      description: "Agent specialized in generating full applications from specifications.",
      bestUseCases: [
        "Generating complete applications from requirements",
        "Transforming mockups to functional code",
        "Prototyping software solutions"
      ],
      limitations: [
        "May require refinement for production-ready code",
        "Framework and language limitations",
        "Complex architectures may need human guidance"
      ],
      complexity: "advanced",
      integrationLevel: "orchestration"
    });
    this.addClassification({
      protocol: "Archon",
      name: "Archon",
      primaryStrength: "fallback_self_healing" /* FALLBACK_SELF_HEALING */,
      secondaryStrengths: ["autonomous_tasking" /* AUTONOMOUS_TASKING */],
      description: "Robust agent framework with self-correction and resilience features.",
      bestUseCases: [
        "Mission-critical applications requiring high reliability",
        "Tasks requiring error recovery and self-healing",
        "Long-running autonomous operations"
      ],
      limitations: [
        "Higher complexity and overhead",
        "May be slower due to verification steps",
        "Additional resources for monitoring and recovery"
      ],
      complexity: "advanced",
      integrationLevel: "orchestration"
    });
    this.addClassification({
      protocol: "Kortix",
      name: "Kortix/Suna",
      primaryStrength: "build_anything" /* BUILD_ANYTHING */,
      secondaryStrengths: ["autonomous_tasking" /* AUTONOMOUS_TASKING */],
      description: "Versatile agent framework designed for creating and connecting AI applications.",
      bestUseCases: [
        "Rapid prototyping of AI-powered applications",
        "Creating custom workflows with multiple agents",
        "Building and deploying integrated AI solutions"
      ],
      limitations: [
        "May require technical knowledge to fully utilize",
        "Less specialized than domain-specific agents",
        "General-purpose nature can be less optimal for specific tasks"
      ],
      complexity: "intermediate",
      integrationLevel: "orchestration"
    });
    this.addClassification({
      protocol: "ACP",
      name: "Agent Communication Protocol",
      primaryStrength: "connection_protocol" /* CONNECTION_PROTOCOL */,
      secondaryStrengths: ["multi_agent_teamwork" /* MULTI_AGENT_TEAMWORK */],
      description: "Standard protocol for agent-to-agent communication and interoperability.",
      bestUseCases: [
        "Creating interoperable agent ecosystems",
        "Building multi-agent systems with heterogeneous agents",
        "Standardizing agent interaction patterns"
      ],
      limitations: [
        "Overhead for simple agent implementations",
        "Requires adoption across agent frameworks",
        "Still evolving as a standard"
      ],
      complexity: "advanced",
      integrationLevel: "integrated"
    });
    this.addClassification({
      protocol: "OAP",
      name: "Open Agent Protocol",
      primaryStrength: "connection_protocol" /* CONNECTION_PROTOCOL */,
      secondaryStrengths: ["autonomous_tasking" /* AUTONOMOUS_TASKING */],
      description: "Open standard for agent interactions and interoperability.",
      bestUseCases: [
        "Creating open ecosystems of interoperable agents",
        "Standardizing tool and agent interactions",
        "Building plugin systems for agents"
      ],
      limitations: [
        "Adoption still growing across frameworks",
        "Implementation complexity for full specification",
        "May evolve with future versions"
      ],
      complexity: "advanced",
      integrationLevel: "integrated"
    });
    this.addClassification({
      protocol: "A2A",
      name: "Agent-to-Agent Protocol",
      primaryStrength: "connection_protocol" /* CONNECTION_PROTOCOL */,
      secondaryStrengths: ["multi_agent_teamwork" /* MULTI_AGENT_TEAMWORK */],
      description: "Lightweight protocol for direct agent-to-agent communication.",
      bestUseCases: [
        "Simple agent message passing",
        "Direct agent collaboration patterns",
        "Building agent networks with minimal overhead"
      ],
      limitations: [
        "Less comprehensive than full communication protocols",
        "May need extension for complex interactions",
        "Limited standardization across frameworks"
      ],
      complexity: "intermediate",
      integrationLevel: "integrated"
    });
  }
  /**
   * Add a classification for an agent protocol
   */
  addClassification(classification) {
    this.classifications.set(classification.protocol, classification);
    log(`Registered classification for protocol: ${classification.protocol}`, "agent");
  }
  /**
   * Get classification for a protocol
   */
  getClassification(protocol) {
    return this.classifications.get(protocol);
  }
  /**
   * Get all classifications
   */
  getAllClassifications() {
    return Array.from(this.classifications.values());
  }
  /**
   * Get protocols by primary strength
   */
  getProtocolsByStrength(strength) {
    return Array.from(this.classifications.values()).filter((classification) => classification.primaryStrength === strength);
  }
  /**
   * Get protocols by complexity level
   */
  getProtocolsByComplexity(complexity) {
    return Array.from(this.classifications.values()).filter((classification) => classification.complexity === complexity);
  }
  /**
   * Get protocols that have a specific strength (either primary or secondary)
   */
  getProtocolsWithStrength(strength) {
    return Array.from(this.classifications.values()).filter(
      (classification) => classification.primaryStrength === strength || classification.secondaryStrengths.includes(strength)
    );
  }
  /**
   * Recommend protocol based on task description
   */
  async recommendProtocols(task) {
    try {
      if (!process.env.OPENAI_API_KEY) {
        return this.ruleBasedRecommendation(task);
      }
      return await this.aiBasedRecommendation(task);
    } catch (error) {
      log(`Error recommending protocols: ${error}`, "agent");
      return this.ruleBasedRecommendation(task);
    }
  }
  /**
   * Rule-based recommendation fallback
   */
  ruleBasedRecommendation(task) {
    const taskLower = task.toLowerCase();
    const matchingProtocols = [];
    if (taskLower.includes("code") || taskLower.includes("program") || taskLower.includes("develop")) {
      const devProtocols = this.getProtocolsWithStrength("devops_code" /* DEVOPS_CODE */);
      matchingProtocols.push(...devProtocols);
    }
    if (taskLower.includes("social") || taskLower.includes("content") || taskLower.includes("post")) {
      const socialProtocols = this.getProtocolsWithStrength("content_social_ops" /* CONTENT_SOCIAL_OPS */);
      matchingProtocols.push(...socialProtocols);
    }
    if (taskLower.includes("team") || taskLower.includes("collaborate") || taskLower.includes("multiple")) {
      const teamProtocols = this.getProtocolsWithStrength("multi_agent_teamwork" /* MULTI_AGENT_TEAMWORK */);
      matchingProtocols.push(...teamProtocols);
    }
    if (taskLower.includes("creative") || taskLower.includes("story") || taskLower.includes("character")) {
      const creativeProtocols = this.getProtocolsWithStrength("creative_roleplay" /* CREATIVE_ROLEPLAY */);
      matchingProtocols.push(...creativeProtocols);
    }
    if (matchingProtocols.length === 0) {
      const autoProtocols = this.getProtocolsWithStrength("autonomous_tasking" /* AUTONOMOUS_TASKING */);
      matchingProtocols.push(...autoProtocols);
    }
    const uniqueProtocols = Array.from(new Map(
      matchingProtocols.map((p) => [p.protocol, p])
    ).values()).slice(0, 3);
    return {
      recommended: uniqueProtocols,
      reasoning: "Based on keywords in your task description, these protocols may be most suitable. For more accurate recommendations, please enable OpenAI API integration."
    };
  }
  /**
   * AI-based recommendation using OpenAI
   */
  async aiBasedRecommendation(task) {
    try {
      const openai7 = new OpenAI15({
        apiKey: process.env.OPENAI_API_KEY
      });
      const protocolDescriptions = Array.from(this.classifications.values()).map((c) => `${c.protocol}: ${c.description} (Primary strength: ${this.strengthToHumanReadable(c.primaryStrength)})`);
      const systemPrompt = `You are an AI protocol selection assistant. Your job is to recommend the best agent protocols
for a given task. Consider the task carefully and select 1-3 most appropriate protocols from the list below.
Provide a brief explanation of why you selected these protocols.

Available protocols:
${protocolDescriptions.join("\n")}`;
      const userPrompt = `Task: ${task}
Please provide your recommendations in JSON format with the following structure:
{
  "recommended": ["Protocol1", "Protocol2"],
  "reasoning": "Brief explanation of why these protocols are recommended."
}`;
      const response = await openai7.chat.completions.create({
        model: "gpt-4o",
        // the newest OpenAI model is "gpt-4o" which was released May 13, 2024. do not change this unless explicitly requested by the user
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt }
        ],
        response_format: { type: "json_object" },
        max_tokens: 1e3,
        temperature: 0.2
      });
      const content2 = response.choices[0].message.content;
      if (!content2) throw new Error("Empty response from OpenAI");
      const result2 = JSON.parse(content2);
      const recommendedProtocols = (result2.recommended || []).map((name) => {
        let classification = this.getClassification(name);
        if (!classification) {
          const allClassifications = this.getAllClassifications();
          classification = allClassifications.find(
            (c) => c.protocol.toLowerCase() === name.toLowerCase() || c.name.toLowerCase() === name.toLowerCase()
          );
        }
        return classification;
      }).filter((c) => c !== void 0);
      if (recommendedProtocols.length === 0) {
        return this.ruleBasedRecommendation(task);
      }
      return {
        recommended: recommendedProtocols,
        reasoning: result2.reasoning || "These protocols were selected based on their capabilities matching your task requirements."
      };
    } catch (error) {
      log(`Error in AI-based recommendation: ${error}`, "agent");
      return this.ruleBasedRecommendation(task);
    }
  }
  /**
   * Convert strength enum to human readable name
   */
  strengthToHumanReadable(strength) {
    switch (strength) {
      case "autonomous_tasking" /* AUTONOMOUS_TASKING */:
        return "Autonomous Task Execution";
      case "multi_agent_teamwork" /* MULTI_AGENT_TEAMWORK */:
        return "Multi-Agent Teamwork";
      case "micro_task_handling" /* MICRO_TASK_HANDLING */:
        return "Micro-Task Handling";
      case "content_social_ops" /* CONTENT_SOCIAL_OPS */:
        return "Content & Social Operations";
      case "creative_roleplay" /* CREATIVE_ROLEPLAY */:
        return "Creative Roleplay";
      case "devops_code" /* DEVOPS_CODE */:
        return "DevOps & Code Generation";
      case "fallback_self_healing" /* FALLBACK_SELF_HEALING */:
        return "Fallback & Self-Healing";
      case "build_anything" /* BUILD_ANYTHING */:
        return "Build Anything Platform";
      case "connection_protocol" /* CONNECTION_PROTOCOL */:
        return "Connection Protocol";
      default:
        return String(strength);
    }
  }
};
var agentOperationLayer = AgentOperationLayer.getInstance();

// server/services/agent/AgentFramework.ts
var AgentFramework = class _AgentFramework {
  static instance;
  registry;
  config;
  initialized = false;
  /**
   * Private constructor for singleton pattern
   */
  constructor(config) {
    this.config = config;
    this.registry = config.registry || ProtocolRegistry.getInstance();
  }
  /**
   * Get singleton instance
   */
  static getInstance(config) {
    if (!_AgentFramework.instance) {
      if (!config) {
        throw new Error("Initial configuration required for AgentFramework");
      }
      _AgentFramework.instance = new _AgentFramework(config);
    } else if (config) {
      _AgentFramework.instance.config = {
        ..._AgentFramework.instance.config,
        ...config
      };
    }
    return _AgentFramework.instance;
  }
  /**
   * Initialize the framework
   */
  async initialize() {
    if (this.initialized) {
      return;
    }
    try {
      this.registerAllProtocols();
      this.initialized = true;
      log("AgentFramework initialized successfully", "agent");
    } catch (error) {
      log(`Error initializing AgentFramework: ${error}`, "agent");
      throw error;
    }
  }
  /**
   * Register all supported protocols
   */
  registerAllProtocols() {
    this.registry.registerProtocol(
      "agentgpt",
      AgentGPTProtocol,
      new AgentGPTProtocol().getMetadata()
    );
    this.registry.registerProtocol(
      "autogpt",
      AutoGPTProtocol,
      new AutoGPTProtocol().getMetadata()
    );
    this.registry.registerProtocol(
      "metagpt",
      MetaGPTProtocol,
      new MetaGPTProtocol().getMetadata()
    );
    this.registry.registerProtocol(
      "crewai",
      CrewAIProtocol,
      new CrewAIProtocol().getMetadata()
    );
    this.registry.registerProtocol(
      "openinterpreter",
      OpenInterpreterProtocol,
      new OpenInterpreterProtocol().getMetadata()
    );
    this.registry.registerProtocol(
      "archon",
      ArchonProtocol,
      new ArchonProtocol().getMetadata()
    );
    this.registry.registerProtocol(
      "babyagi",
      BabyAGIProtocol,
      new BabyAGIProtocol().getMetadata()
    );
    this.registry.registerProtocol(
      "kushai",
      KUSHAIProtocol,
      new KUSHAIProtocol().getMetadata()
    );
    this.registry.registerProtocol(
      "instagramagent",
      InstagramAgentProtocol,
      new InstagramAgentProtocol().getMetadata()
    );
    this.registry.registerProtocol(
      "rionaai",
      RionaAIProtocol,
      new RionaAIProtocol().getMetadata()
    );
    this.registry.registerProtocol(
      "kyro",
      KyroProtocol,
      new KyroProtocol().getMetadata()
    );
    this.registry.registerProtocol(
      "camelai",
      CamelAIProtocol,
      new CamelAIProtocol().getMetadata()
    );
    this.registry.registerProtocol(
      "autogen",
      AutoGenProtocol,
      new AutoGenProtocol().getMetadata()
    );
    this.registry.registerProtocol(
      "smolagents",
      SmolAgentsProtocol,
      new SmolAgentsProtocol().getMetadata()
    );
    this.registry.registerProtocol(
      "allhands",
      AllHandsProtocol,
      new AllHandsProtocol().getMetadata()
    );
    this.registry.registerProtocol(
      "qodopr",
      QodoPRAgentProtocol,
      new QodoPRAgentProtocol().getMetadata()
    );
    this.registry.registerProtocol(
      "msagentautobuilder",
      MSAgentAutoBuilderProtocol,
      new MSAgentAutoBuilderProtocol().getMetadata()
    );
    this.registry.registerProtocol(
      "kortixbuilder",
      KortixBuilderProtocol,
      new KortixBuilderProtocol().getMetadata()
    );
    this.registry.registerProtocol(
      "agentkitgoogle",
      AgentKitGoogleProtocol,
      new AgentKitGoogleProtocol().getMetadata()
    );
    this.registry.registerProtocol(
      "mcpserver",
      MCPServerProtocol,
      new MCPServerProtocol().getMetadata()
    );
  }
  /**
   * Execute a task using a specific protocol
   */
  async executeWithProtocol(protocolName, task, options2 = {}, config = {}) {
    if (!this.initialized) {
      await this.initialize();
    }
    if (!this.registry.hasProtocol(protocolName)) {
      throw new Error(`Protocol '${protocolName}' not found`);
    }
    const startTime2 = Date.now();
    const executionStartTime = /* @__PURE__ */ new Date();
    try {
      const protocol = this.registry.createProtocolInstance(protocolName);
      const metadata = this.registry.getProtocolMetadata(protocolName);
      const protocolConfig = {
        ...config,
        tools: config.tools || this.config.defaultTools
      };
      await protocol.init(protocolConfig);
      const executionOptions = {
        task,
        tools: protocolConfig.tools,
        ...options2
      };
      const response = await protocol.execute(executionOptions);
      await protocol.cleanup();
      const endTime = /* @__PURE__ */ new Date();
      const executionTime = Date.now() - startTime2;
      return {
        response,
        protocol: protocolName,
        executionTime,
        metadata: {
          protocolVersion: metadata.version,
          model: protocolConfig.modelName || "unknown",
          startTime: executionStartTime,
          endTime,
          status: "success"
        }
      };
    } catch (error) {
      const endTime = /* @__PURE__ */ new Date();
      const executionTime = Date.now() - startTime2;
      log(`Error executing protocol '${protocolName}': ${error}`, "agent");
      return {
        response: {
          response: `Error executing protocol '${protocolName}': ${error.message}`,
          executionTime
        },
        protocol: protocolName,
        executionTime,
        metadata: {
          protocolVersion: this.registry.getProtocolMetadata(protocolName).version,
          model: config.modelName || "unknown",
          startTime: executionStartTime,
          endTime,
          status: "error",
          errorMessage: error.message
        }
      };
    }
  }
  /**
   * Choose the best protocol for a given task
   */
  async chooseBestProtocol(task, requiredCapabilities = []) {
    if (!this.initialized) {
      await this.initialize();
    }
    const protocols = this.registry.listProtocols();
    const compatibleProtocols = protocols.filter(
      (p) => requiredCapabilities.every(
        (capability) => p.metadata.capabilities.includes(capability)
      )
    );
    if (compatibleProtocols.length === 0) {
      return this.config.defaultProtocol;
    }
    try {
      const recommendations = await agentOperationLayer.recommendProtocols(task);
      if (recommendations.recommended.length > 0) {
        const compatibleRecommendation = recommendations.recommended.find(
          (rec) => compatibleProtocols.some((p) => p.name === rec.protocol)
        );
        if (compatibleRecommendation) {
          return compatibleRecommendation.protocol;
        }
      }
    } catch (error) {
      log(`Error using Agent Operation Layer for recommendations: ${error}`, "agent");
    }
    const taskLower = task.toLowerCase();
    if ((taskLower.includes("github") || taskLower.includes("git")) && (taskLower.includes("pr") || taskLower.includes("pull request") || taskLower.includes("review"))) {
      const qodopr = compatibleProtocols.find((p) => p.name === "qodopr");
      if (qodopr) {
        return "qodopr";
      }
    }
    if (taskLower.includes("instagram") || taskLower.includes("social media") && taskLower.includes("image")) {
      const instagramAgent = compatibleProtocols.find((p) => p.name === "instagramagent");
      if (instagramAgent) {
        return "instagramagent";
      }
    }
    if ((taskLower.includes("twitter") || taskLower.includes("monitor")) && (taskLower.includes("git") || taskLower.includes("social"))) {
      const rionaAI = compatibleProtocols.find((p) => p.name === "rionaai");
      if (rionaAI) {
        return "rionaai";
      }
    }
    if (taskLower.includes("blog") || taskLower.includes("article") || taskLower.includes("write") && taskLower.includes("content")) {
      const kushai = compatibleProtocols.find((p) => p.name === "kushai");
      if (kushai) {
        return "kushai";
      }
    }
    if (taskLower.includes("serverless") || taskLower.includes("efficien") && taskLower.includes("automat")) {
      const kyro = compatibleProtocols.find((p) => p.name === "kyro");
      if (kyro) {
        return "kyro";
      }
    }
    if ((taskLower.includes("software") || taskLower.includes("repository") || taskLower.includes("repo")) && (taskLower.includes("develop") || taskLower.includes("build"))) {
      const allHands = compatibleProtocols.find((p) => p.name === "allhands");
      if (allHands) {
        return "allhands";
      }
    }
    if (taskLower.includes("roleplay") || taskLower.includes("role play") || taskLower.includes("conversation") && taskLower.includes("two")) {
      const camelAI = compatibleProtocols.find((p) => p.name === "camelai");
      if (camelAI) {
        return "camelai";
      }
    }
    if (taskLower.includes("code") || taskLower.includes("program") || taskLower.includes("script")) {
      const openInterpreter = compatibleProtocols.find((p) => p.name === "openinterpreter");
      if (openInterpreter) {
        return "openinterpreter";
      }
    }
    if (taskLower.includes("efficien") || taskLower.includes("resource constraint") || taskLower.includes("minimal") || taskLower.includes("lightweight")) {
      const smolAgents = compatibleProtocols.find((p) => p.name === "smolagents");
      if (smolAgents) {
        return "smolagents";
      }
    }
    if ((taskLower.includes("collaborat") || taskLower.includes("team")) && taskLower.includes("tool")) {
      const autogen = compatibleProtocols.find((p) => p.name === "autogen");
      if (autogen) {
        return "autogen";
      }
    }
    if (taskLower.includes("priorit") || taskLower.includes("task list") || taskLower.includes("organize tasks")) {
      const babyagi = compatibleProtocols.find((p) => p.name === "babyagi");
      if (babyagi) {
        return "babyagi";
      }
    }
    if (taskLower.includes("team") || taskLower.includes("collaborate") || taskLower.includes("role")) {
      const metagpt = compatibleProtocols.find((p) => p.name === "metagpt");
      if (metagpt) {
        return "metagpt";
      }
      const crewai = compatibleProtocols.find((p) => p.name === "crewai");
      if (crewai) {
        return "crewai";
      }
    }
    if (taskLower.includes("complex") || task.length > 100 || task.split(" ").length > 15) {
      const autogpt = compatibleProtocols.find((p) => p.name === "autogpt");
      if (autogpt) {
        return "autogpt";
      }
    }
    if (taskLower.includes("error") || taskLower.includes("resilient") || taskLower.includes("recover")) {
      const archon = compatibleProtocols.find((p) => p.name === "archon");
      if (archon) {
        return "archon";
      }
    }
    if ((taskLower.includes("message") || taskLower.includes("communication")) && (taskLower.includes("agent") || taskLower.includes("multi-agent") || taskLower.includes("multiagent"))) {
      const mcpserver = compatibleProtocols.find((p) => p.name === "mcpserver");
      if (mcpserver) {
        return "mcpserver";
      }
    }
    const agentgpt = compatibleProtocols.find((p) => p.name === "agentgpt");
    if (agentgpt) {
      return "agentgpt";
    }
    return compatibleProtocols[0].name;
  }
  /**
   * Execute a task with automatic protocol selection
   */
  async execute(task, options2 = {}, config = {}, requiredCapabilities = []) {
    const protocolName = await this.chooseBestProtocol(task, requiredCapabilities);
    return this.executeWithProtocol(protocolName, task, options2, config);
  }
  /**
   * Get all supported protocols
   */
  getAllProtocols() {
    return this.registry.listProtocols();
  }
  /**
   * Get protocol metadata
   */
  getProtocolMetadata(protocolName) {
    return this.registry.getProtocolMetadata(protocolName);
  }
  /**
   * Check if a protocol is supported
   */
  isProtocolSupported(protocolName) {
    return this.registry.hasProtocol(protocolName);
  }
  /**
   * Get protocol registry
   */
  getRegistry() {
    return this.registry;
  }
  /**
   * Get current configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
  }
  /**
   * Get protocols by strength category
   */
  getProtocolsByStrength(strength) {
    if (!this.initialized) {
      throw new Error("AgentFramework not initialized");
    }
    const matchingClassifications = agentOperationLayer.getProtocolsByStrength(strength);
    log(`Found ${matchingClassifications.length} classifications with primary strength ${strength}`, "agent");
    if (matchingClassifications.length > 0) {
      log(`Matching protocol names: ${matchingClassifications.map((c) => c.protocol).join(", ")}`, "agent");
    }
    const result2 = matchingClassifications.map((classification) => {
      const protocolNames = Array.from(this.registry.listProtocols().map((p) => p.name));
      const matchedProtocol = protocolNames.find(
        (name) => name.toLowerCase() === classification.protocol.toLowerCase()
      );
      const hasProtocol = !!matchedProtocol;
      log(`Protocol ${classification.protocol} exists in registry: ${hasProtocol}`, "agent");
      if (hasProtocol) {
        return {
          name: classification.protocol,
          metadata: this.registry.getProtocolMetadata(matchedProtocol)
        };
      }
      return null;
    }).filter((p) => p !== null);
    log(`Returning ${result2.length} protocols for strength ${strength}`, "agent");
    return result2;
  }
  /**
   * Get protocols with a specific strength (primary or secondary)
   */
  getProtocolsWithStrength(strength) {
    if (!this.initialized) {
      throw new Error("AgentFramework not initialized");
    }
    const matchingClassifications = agentOperationLayer.getProtocolsWithStrength(strength);
    return matchingClassifications.map((classification) => {
      const protocolNames = Array.from(this.registry.listProtocols().map((p) => p.name));
      const matchedProtocol = protocolNames.find(
        (name) => name.toLowerCase() === classification.protocol.toLowerCase()
      );
      if (matchedProtocol) {
        return {
          name: classification.protocol,
          metadata: this.registry.getProtocolMetadata(matchedProtocol)
        };
      }
      return null;
    }).filter((p) => p !== null);
  }
  /**
   * Get protocol classifications
   */
  getProtocolClassifications() {
    return agentOperationLayer.getAllClassifications();
  }
  /**
   * Get recommended protocols for a task with reasoning
   */
  async getRecommendedProtocols(task) {
    return agentOperationLayer.recommendProtocols(task);
  }
};

// server/services/agent/configureAgentFramework.ts
async function configureAgentFramework() {
  try {
    const config = {
      defaultProtocol: "agentgpt",
      // Default to simplest protocol
      defaultTools: [
        // Add common tools from the toolkit
        AgentToolkit.getWebSearchTool(),
        AgentToolkit.getWebScraperTool(),
        AgentToolkit.getCalculatorTool(),
        AgentToolkit.getDateTimeTool(),
        AgentToolkit.getWeatherTool(),
        AgentToolkit.getNewsSearchTool()
      ],
      apiKeys: {
        // Use environment variables for API keys
        anthropic: process.env.ANTHROPIC_API_KEY,
        openai: process.env.OPENAI_API_KEY
      }
    };
    const framework = AgentFramework.getInstance(config);
    await framework.initialize();
    log("Agent Framework configured successfully", "agent");
    return framework;
  } catch (error) {
    log(`Error configuring Agent Framework: ${error}`, "agent");
    throw error;
  }
}
function mapAgentTypeToProtocol(agentType) {
  switch (agentType.toLowerCase()) {
    // Original protocols
    case "agentgpt":
    case "assistant":
      return "agentgpt";
    case "autogpt":
    case "autonomous":
    case "planner":
      return "autogpt";
    case "metagpt":
    case "team":
    case "roleplay":
      return "metagpt";
    case "crewai":
    case "crew":
    case "multi-agent":
      return "crewai";
    case "openinterpreter":
    case "interpreter":
    case "code":
      return "openinterpreter";
    case "archon":
    case "self-healing":
    case "error-correcting":
      return "archon";
    // New protocols (first 10 additions)
    case "babyagi":
    case "task-prioritization":
      return "babyagi";
    case "kushai":
    case "blog":
    case "content-creation":
      return "kushai";
    case "instagramagent":
    case "instagram":
    case "social-media":
      return "instagramagent";
    case "rionaai":
    case "monitoring":
    case "twitter-monitor":
    case "github-monitor":
      return "rionaai";
    case "kyro":
    case "serverless":
    case "efficiency":
      return "kyro";
    case "camelai":
    case "conversation":
    case "roleplay-agent":
      return "camelai";
    case "autogen":
    case "microsoft-autogen":
    case "collaborative":
      return "autogen";
    case "smolagents":
    case "smol":
    case "lightweight":
    case "efficient-agent":
      return "smolagents";
    case "allhands":
    case "development-team":
    case "dev-agents":
      return "allhands";
    case "qodopr":
    case "pr-agent":
    case "github-pr":
    case "pull-request":
      return "qodopr";
    // New protocols (latest 3 additions)
    case "msagentautobuilder":
    case "autobuilder":
    case "microsoft-agent":
      return "msagentautobuilder";
    case "kortixbuilder":
    case "kortix":
    case "sunaso":
    case "workflow-builder":
      return "kortixbuilder";
    case "agentkitgoogle":
    case "agentkit":
    case "google-agent":
    case "component-agent":
      return "agentkitgoogle";
    case "mcpserver":
    case "mcp":
    case "message-control":
    case "agent-messaging":
    case "multi-agent-messaging":
      return "mcpserver";
    default:
      return "agentgpt";
  }
}
function checkApiKeys() {
  const anthropic3 = !!process.env.ANTHROPIC_API_KEY;
  const openai7 = !!process.env.OPENAI_API_KEY;
  const missing = [];
  if (!anthropic3) missing.push("ANTHROPIC_API_KEY");
  if (!openai7) missing.push("OPENAI_API_KEY");
  return { anthropic: anthropic3, openai: openai7, missing };
}

// server/services/activity-logger/index.ts
import { desc as desc5, eq as eq9, and as and6, sql as sql4 } from "drizzle-orm";
var ActivityLoggerService = class {
  /**
   * Log an activity
   */
  async logActivity(options2) {
    try {
      const activityData = {
        userId: options2.userId,
        level: options2.level,
        action: options2.action,
        entityType: options2.entityType,
        entityId: options2.entityId,
        details: options2.details,
        ipAddress: options2.ipAddress,
        userAgent: options2.userAgent,
        timestamp: /* @__PURE__ */ new Date()
      };
      await db.insert(activityLogs).values(activityData);
    } catch (error) {
      console.error("Error logging activity:", error);
    }
  }
  /**
   * Get activity logs with filtering options
   */
  async getActivityLogs(options2 = {}) {
    const whereConditions = [];
    if (options2.userId !== void 0) {
      whereConditions.push(eq9(activityLogs.userId, options2.userId));
    }
    if (options2.level) {
      whereConditions.push(eq9(activityLogs.level, options2.level));
    }
    if (options2.action) {
      whereConditions.push(eq9(activityLogs.action, options2.action));
    }
    if (options2.entityType) {
      whereConditions.push(eq9(activityLogs.entityType, options2.entityType));
    }
    if (options2.entityId) {
      whereConditions.push(eq9(activityLogs.entityId, options2.entityId));
    }
    if (options2.startDate) {
      whereConditions.push(sql4`${activityLogs.timestamp} >= ${options2.startDate}`);
    }
    if (options2.endDate) {
      whereConditions.push(sql4`${activityLogs.timestamp} <= ${options2.endDate}`);
    }
    const queryCondition = whereConditions.length > 0 ? and6(...whereConditions) : void 0;
    const limit = options2.limit || 100;
    const offset = options2.offset || 0;
    const [{ count: count2 }] = await db.select({ count: sql4`count(*)` }).from(activityLogs).where(queryCondition);
    const logs = await db.select().from(activityLogs).where(queryCondition).orderBy(desc5(activityLogs.timestamp)).limit(limit).offset(offset);
    return {
      logs,
      total: Number(count2),
      limit,
      offset
    };
  }
  /**
   * Get recent activity for a user
   */
  async getUserActivity(userId, limit = 10) {
    return db.select().from(activityLogs).where(eq9(activityLogs.userId, userId)).orderBy(desc5(activityLogs.timestamp)).limit(limit);
  }
  /**
   * Get activity by entity
   */
  async getEntityActivity(entityType, entityId, limit = 10) {
    return db.select().from(activityLogs).where(
      and6(
        eq9(activityLogs.entityType, entityType),
        eq9(activityLogs.entityId, entityId)
      )
    ).orderBy(desc5(activityLogs.timestamp)).limit(limit);
  }
  /**
   * Get system activity logs
   */
  async getSystemActivity(limit = 20) {
    return db.select().from(activityLogs).where(eq9(activityLogs.entityType, "system" /* System */)).orderBy(desc5(activityLogs.timestamp)).limit(limit);
  }
  /**
   * Get error logs
   */
  async getErrorLogs(limit = 50) {
    return db.select().from(activityLogs).where(eq9(activityLogs.level, "error" /* Error */)).orderBy(desc5(activityLogs.timestamp)).limit(limit);
  }
};
var activityLogger = new ActivityLoggerService();
var logInfo = (action, details, userId, entityType, entityId, req2) => {
  return activityLogger.logActivity({
    level: "info" /* Info */,
    action,
    details,
    userId,
    entityType,
    entityId,
    ipAddress: req2?.ip,
    userAgent: req2?.headers?.["user-agent"]
  });
};
var logError = (action, error, userId, entityType, entityId, req2) => {
  const details = {
    message: error?.message || String(error),
    stack: error?.stack,
    code: error?.code
  };
  return activityLogger.logActivity({
    level: "error" /* Error */,
    action,
    details,
    userId,
    entityType,
    entityId,
    ipAddress: req2?.ip,
    userAgent: req2?.headers?.["user-agent"]
  });
};
var logWarning = (action, details, userId, entityType, entityId, req2) => {
  return activityLogger.logActivity({
    level: "warning" /* Warning */,
    action,
    details,
    userId,
    entityType,
    entityId,
    ipAddress: req2?.ip,
    userAgent: req2?.headers?.["user-agent"]
  });
};

// server/services/guardrails/index.ts
import { EventEmitter as EventEmitter2 } from "events";
var ContentCategory = /* @__PURE__ */ ((ContentCategory3) => {
  ContentCategory3["TOXICITY"] = "toxicity";
  ContentCategory3["HATE_SPEECH"] = "hate_speech";
  ContentCategory3["SEXUAL_CONTENT"] = "sexual_content";
  ContentCategory3["VIOLENCE"] = "violence";
  ContentCategory3["SELF_HARM"] = "self_harm";
  ContentCategory3["HARASSMENT"] = "harassment";
  ContentCategory3["PROFANITY"] = "profanity";
  ContentCategory3["PII"] = "pii";
  ContentCategory3["PROPRIETARY_INFO"] = "proprietary_info";
  ContentCategory3["DISCRIMINATION"] = "discrimination";
  ContentCategory3["JAILBREAK"] = "jailbreak";
  ContentCategory3["PROMPT_INJECTION"] = "prompt_injection";
  return ContentCategory3;
})(ContentCategory || {});
var DEFAULT_GUARDRAIL_CONFIGS = {
  ["strict" /* STRICT */]: {
    enabledCategories: Object.values(ContentCategory),
    thresholds: {
      ["toxicity" /* TOXICITY */]: 0.5,
      ["hate_speech" /* HATE_SPEECH */]: 0.4,
      ["sexual_content" /* SEXUAL_CONTENT */]: 0.6,
      ["violence" /* VIOLENCE */]: 0.6,
      ["self_harm" /* SELF_HARM */]: 0.3,
      ["harassment" /* HARASSMENT */]: 0.5,
      ["profanity" /* PROFANITY */]: 0.7,
      ["pii" /* PII */]: 0.5,
      ["proprietary_info" /* PROPRIETARY_INFO */]: 0.8,
      ["discrimination" /* DISCRIMINATION */]: 0.5,
      ["jailbreak" /* JAILBREAK */]: 0.5,
      ["prompt_injection" /* PROMPT_INJECTION */]: 0.5
    },
    blockedTopics: [
      "illegal activities",
      "hacking",
      "terrorism",
      "self-harm",
      "adult content"
    ]
  },
  ["moderate" /* MODERATE */]: {
    enabledCategories: [
      "toxicity" /* TOXICITY */,
      "hate_speech" /* HATE_SPEECH */,
      "sexual_content" /* SEXUAL_CONTENT */,
      "violence" /* VIOLENCE */,
      "self_harm" /* SELF_HARM */,
      "jailbreak" /* JAILBREAK */,
      "prompt_injection" /* PROMPT_INJECTION */
    ],
    thresholds: {
      ["toxicity" /* TOXICITY */]: 0.7,
      ["hate_speech" /* HATE_SPEECH */]: 0.6,
      ["sexual_content" /* SEXUAL_CONTENT */]: 0.8,
      ["violence" /* VIOLENCE */]: 0.8,
      ["self_harm" /* SELF_HARM */]: 0.5,
      ["harassment" /* HARASSMENT */]: 0.7,
      ["profanity" /* PROFANITY */]: 0.85,
      ["pii" /* PII */]: 0.7,
      ["proprietary_info" /* PROPRIETARY_INFO */]: 0.9,
      ["discrimination" /* DISCRIMINATION */]: 0.7,
      ["jailbreak" /* JAILBREAK */]: 0.7,
      ["prompt_injection" /* PROMPT_INJECTION */]: 0.7
    },
    blockedTopics: [
      "illegal activities",
      "terrorism",
      "self-harm"
    ]
  },
  ["minimal" /* MINIMAL */]: {
    enabledCategories: [
      "hate_speech" /* HATE_SPEECH */,
      "self_harm" /* SELF_HARM */,
      "jailbreak" /* JAILBREAK */,
      "prompt_injection" /* PROMPT_INJECTION */
    ],
    thresholds: {
      ["toxicity" /* TOXICITY */]: 0.9,
      ["hate_speech" /* HATE_SPEECH */]: 0.8,
      ["sexual_content" /* SEXUAL_CONTENT */]: 0.95,
      ["violence" /* VIOLENCE */]: 0.95,
      ["self_harm" /* SELF_HARM */]: 0.7,
      ["harassment" /* HARASSMENT */]: 0.9,
      ["profanity" /* PROFANITY */]: 0.95,
      ["pii" /* PII */]: 0.9,
      ["proprietary_info" /* PROPRIETARY_INFO */]: 0.95,
      ["discrimination" /* DISCRIMINATION */]: 0.9,
      ["jailbreak" /* JAILBREAK */]: 0.8,
      ["prompt_injection" /* PROMPT_INJECTION */]: 0.8
    },
    blockedTopics: [
      "terrorism",
      "self-harm"
    ]
  },
  ["none" /* NONE */]: {
    enabledCategories: [],
    thresholds: {},
    blockedTopics: []
  },
  ["custom" /* CUSTOM */]: {
    // Custom configuration should be provided by the user
  }
};
var GuardrailsService = class extends EventEmitter2 {
  configs = /* @__PURE__ */ new Map();
  constructor() {
    super();
  }
  /**
   * Set guardrail configuration for a specific workflow
   */
  setGuardrailConfig(workflowId, config) {
    const existingConfig = this.configs.get(workflowId);
    const level = config.level || "moderate" /* MODERATE */;
    const baseConfig = DEFAULT_GUARDRAIL_CONFIGS[level];
    const newConfig = {
      level,
      enabledCategories: config.enabledCategories || baseConfig.enabledCategories || [],
      thresholds: { ...baseConfig.thresholds, ...config.thresholds },
      allowedTopics: config.allowedTopics || baseConfig.allowedTopics || [],
      blockedTopics: config.blockedTopics || baseConfig.blockedTopics || [],
      allowedPatterns: config.allowedPatterns || baseConfig.allowedPatterns || [],
      blockedPatterns: config.blockedPatterns || baseConfig.blockedPatterns || [],
      customRules: config.customRules
    };
    this.configs.set(workflowId, newConfig);
    logInfo(
      "Set guardrail config",
      {
        message: `Guardrail configuration set for workflow ${workflowId} with level ${level}`,
        workflowId
      },
      void 0,
      "workflow" /* Workflow */,
      workflowId
    );
    return newConfig;
  }
  /**
   * Get guardrail configuration for a workflow
   */
  getGuardrailConfig(workflowId) {
    return this.configs.get(workflowId);
  }
  /**
   * Apply guardrails to check if content is allowed
   */
  checkContent(workflowId, content2) {
    const config = this.configs.get(workflowId);
    if (!config || config.level === "none" /* NONE */) {
      return {
        allowed: true,
        detections: [],
        risk: "none",
        processedAt: /* @__PURE__ */ new Date()
      };
    }
    const detections = this.analyzeContent(content2, config);
    const blockingDetections = detections.filter((detection) => {
      const threshold = config.thresholds[detection.category];
      return threshold && detection.confidence >= threshold;
    });
    const allowed = blockingDetections.length === 0;
    let risk = "none";
    if (detections.length > 0) {
      const maxConfidence = Math.max(...detections.map((d) => d.confidence));
      if (maxConfidence > 0.9) {
        risk = "critical";
      } else if (maxConfidence > 0.7) {
        risk = "high";
      } else if (maxConfidence > 0.5) {
        risk = "medium";
      } else if (maxConfidence > 0.3) {
        risk = "low";
      }
    }
    let blockReason;
    if (!allowed) {
      const categories = blockingDetections.map((d) => d.category).join(", ");
      blockReason = `Content blocked due to: ${categories}`;
    }
    if (!allowed) {
      logWarning(
        "Guardrail blocked content",
        {
          message: blockReason,
          workflowId,
          categories: blockingDetections.map((d) => d.category),
          risk
        },
        void 0,
        "workflow" /* Workflow */,
        workflowId
      );
      this.emit("content-blocked", {
        workflowId,
        detections: blockingDetections,
        content: content2,
        timestamp: /* @__PURE__ */ new Date()
      });
    }
    return {
      allowed,
      detections,
      blockReason,
      risk,
      processedAt: /* @__PURE__ */ new Date()
    };
  }
  /**
   * Filter and sanitize content based on guardrails
   */
  filterContent(workflowId, content2) {
    const config = this.configs.get(workflowId);
    if (!config || config.level === "none" /* NONE */) {
      return {
        allowed: true,
        detections: [],
        filteredContent: content2,
        risk: "none",
        processedAt: /* @__PURE__ */ new Date()
      };
    }
    const detections = this.analyzeContent(content2, config);
    let filteredContent = content2;
    for (const detection of detections) {
      if (detection.location && detection.confidence >= config.thresholds[detection.category]) {
        const { start, end } = detection.location;
        if (start >= 0 && end <= content2.length) {
          const before = filteredContent.substring(0, start);
          const after = filteredContent.substring(end);
          filteredContent = before + "[FILTERED]" + after;
        }
      }
    }
    let risk = "none";
    if (detections.length > 0) {
      const maxConfidence = Math.max(...detections.map((d) => d.confidence));
      if (maxConfidence > 0.9) {
        risk = "critical";
      } else if (maxConfidence > 0.7) {
        risk = "high";
      } else if (maxConfidence > 0.5) {
        risk = "medium";
      } else if (maxConfidence > 0.3) {
        risk = "low";
      }
    }
    if (filteredContent !== content2) {
      logInfo(
        "Guardrail filtered content",
        {
          message: "Content was modified by guardrails",
          workflowId,
          categories: detections.map((d) => d.category),
          risk
        },
        void 0,
        "workflow" /* Workflow */,
        workflowId
      );
      this.emit("content-filtered", {
        workflowId,
        detections,
        originalContent: content2,
        filteredContent,
        timestamp: /* @__PURE__ */ new Date()
      });
    }
    return {
      allowed: true,
      detections,
      filteredContent,
      risk,
      processedAt: /* @__PURE__ */ new Date()
    };
  }
  /**
   * Demo implementation of content analysis
   * In a real system, this would use AI models or third-party APIs
   */
  analyzeContent(content2, config) {
    const detections = [];
    const lowercaseContent = content2.toLowerCase();
    const patterns = {
      ["toxicity" /* TOXICITY */]: ["toxic", "awful", "terrible", "disgusting"],
      ["hate_speech" /* HATE_SPEECH */]: ["hate", "racial slur", "bigot"],
      ["sexual_content" /* SEXUAL_CONTENT */]: ["explicit", "pornographic", "sexual"],
      ["violence" /* VIOLENCE */]: ["violent", "kill", "hurt", "attack"],
      ["self_harm" /* SELF_HARM */]: ["suicide", "self-harm", "kill myself"],
      ["harassment" /* HARASSMENT */]: ["harass", "bully", "stalk"],
      ["profanity" /* PROFANITY */]: ["damn", "hell", "crap"],
      ["pii" /* PII */]: ["ssn", "social security", "credit card", "phone number"],
      ["proprietary_info" /* PROPRIETARY_INFO */]: ["confidential", "proprietary", "internal only"],
      ["discrimination" /* DISCRIMINATION */]: ["discriminate", "bias", "prejudice"],
      ["jailbreak" /* JAILBREAK */]: ["ignore previous instructions", "ignore all instructions", "DAN mode"],
      ["prompt_injection" /* PROMPT_INJECTION */]: ["ignore context", "new prompt", "instead respond to"]
    };
    for (const category of config.enabledCategories) {
      const categoryPatterns = patterns[category] || [];
      for (const pattern of categoryPatterns) {
        const index2 = lowercaseContent.indexOf(pattern);
        if (index2 >= 0) {
          const regex = new RegExp(pattern, "gi");
          const matches = content2.match(regex) || [];
          const confidence = Math.min(0.5 + matches.length * 0.1, 0.95);
          detections.push({
            category,
            confidence,
            severity: confidence > 0.7 ? "high" : confidence > 0.4 ? "medium" : "low",
            text: pattern,
            location: {
              start: index2,
              end: index2 + pattern.length
            }
          });
        }
      }
    }
    for (const topic of config.blockedTopics) {
      if (lowercaseContent.includes(topic.toLowerCase())) {
        detections.push({
          category: "proprietary_info" /* PROPRIETARY_INFO */,
          // Using this as a generic category
          confidence: 0.8,
          severity: "high",
          text: topic,
          location: {
            start: lowercaseContent.indexOf(topic.toLowerCase()),
            end: lowercaseContent.indexOf(topic.toLowerCase()) + topic.length
          }
        });
      }
    }
    return detections;
  }
};
var guardrails = new GuardrailsService();

// server/middleware/guardrails.ts
var promptGuardrailsMiddleware = async (req2, res2, next) => {
  try {
    const content2 = req2.body.prompt || req2.body.task || req2.body.message?.content || req2.body.messages?.[req2.body.messages.length - 1]?.content;
    if (!content2) {
      return next();
    }
    const workflowId = (req2.body.workflowId || req2.query.workflowId || "default").toString();
    const result2 = guardrails.checkContent(workflowId, content2);
    if (!result2.allowed) {
      log(`Guardrails blocked prompt: ${result2.blockReason}`, "guardrails");
      return res2.status(403).json({
        message: "Content violates guardrails policy",
        reason: result2.blockReason,
        categories: result2.detections.map((d) => d.category),
        risk: result2.risk,
        processedAt: result2.processedAt
      });
    }
    if (result2.detections.length > 0 && result2.risk !== "none") {
      const filteredResult = guardrails.filterContent(workflowId, content2);
      if (filteredResult.filteredContent !== content2) {
        log(`Guardrails modified prompt`, "guardrails");
        if (req2.body.prompt) {
          req2.body.prompt = filteredResult.filteredContent;
        } else if (req2.body.task) {
          req2.body.task = filteredResult.filteredContent;
        } else if (req2.body.message?.content) {
          req2.body.message.content = filteredResult.filteredContent;
        } else if (req2.body.messages?.[req2.body.messages.length - 1]?.content) {
          req2.body.messages[req2.body.messages.length - 1].content = filteredResult.filteredContent;
        }
        res2.setHeader("X-Guardrails-Modified", "true");
      }
    }
    req2.guardrailsResult = result2;
    next();
  } catch (error) {
    log(`Error in guardrails middleware: ${error}`, "guardrails");
    next(error);
  }
};

// server/routes/agent-routes.ts
var router6 = express4.Router();
var agentFramework = null;
var initializeAgentFramework = async () => {
  if (!agentFramework) {
    agentFramework = await configureAgentFramework();
  }
  return agentFramework;
};
var validateApiKeys = (req2, res2, next) => {
  const keys = checkApiKeys();
  if (keys.missing.length > 0) {
    return res2.status(400).json({
      message: `Missing required API keys: ${keys.missing.join(", ")}`,
      missingKeys: keys.missing
    });
  }
  next();
};
var executeSchema = z2.object({
  task: z2.string().min(1, "Task is required"),
  protocol: z2.string().optional(),
  agentType: z2.string().optional(),
  capabilities: z2.array(z2.string()).optional(),
  config: z2.record(z2.any()).optional(),
  tools: z2.array(z2.string()).optional()
});
router6.post("/api/agent/execute", isAuthenticated3, validateApiKeys, promptGuardrailsMiddleware, async (req2, res2) => {
  try {
    const validation = executeSchema.safeParse(req2.body);
    if (!validation.success) {
      return res2.status(400).json({
        message: "Invalid request body",
        errors: validation.error.errors
      });
    }
    const { task, protocol, agentType, capabilities, config, tools: tools2 } = validation.data;
    const framework = await initializeAgentFramework();
    let protocolName = protocol;
    if (!protocolName && agentType) {
      protocolName = mapAgentTypeToProtocol(agentType);
    }
    const requiredCapabilities = capabilities?.map((cap) => {
      return cap;
    }) || [];
    const requestContext = {
      userId: req2.user?.id,
      requestTime: /* @__PURE__ */ new Date(),
      userAgent: req2.headers["user-agent"]
    };
    const callbacks = req2.sendWebSocketEvent ? {
      onStart: () => {
        req2.sendWebSocketEvent({
          type: "execution_started",
          data: {
            task,
            protocol: protocolName || "auto",
            timestamp: /* @__PURE__ */ new Date()
          }
        });
      },
      onComplete: (response) => {
        req2.sendWebSocketEvent({
          type: "execution_completed",
          data: {
            task,
            protocol: protocolName || "auto",
            timestamp: /* @__PURE__ */ new Date(),
            response: response.response
          }
        });
      },
      onError: (error) => {
        req2.sendWebSocketEvent({
          type: "execution_failed",
          data: {
            task,
            protocol: protocolName || "auto",
            timestamp: /* @__PURE__ */ new Date(),
            error: error.message
          }
        });
      },
      onStep: (step) => {
        req2.sendWebSocketEvent({
          type: "node_execution_update",
          data: {
            step,
            timestamp: /* @__PURE__ */ new Date()
          }
        });
      },
      onToolUse: (toolUse) => {
        req2.sendWebSocketEvent({
          type: "langgraph_tool_execution",
          data: {
            tool: toolUse.toolName,
            input: toolUse.input,
            output: toolUse.output,
            error: toolUse.error,
            timestamp: /* @__PURE__ */ new Date()
          }
        });
      }
    } : void 0;
    const executionConfig = {
      ...config || {},
      metadata: {
        ...(config || {}).metadata || {},
        requestContext
      }
    };
    let result2;
    if (protocolName) {
      result2 = await framework.executeWithProtocol(
        protocolName,
        task,
        { context: { requestContext }, callbacks },
        executionConfig
      );
    } else {
      result2 = await framework.execute(
        task,
        { context: { requestContext }, callbacks },
        executionConfig,
        requiredCapabilities
      );
    }
    res2.json(result2);
  } catch (error) {
    log(`Error in agent execution: ${error}`, "agent");
    res2.status(500).json({
      message: "Error executing agent task",
      error: error.message
    });
  }
});
router6.get("/api/agent/protocols", async (req2, res2) => {
  try {
    const framework = await initializeAgentFramework();
    const protocols = framework.getAllProtocols();
    res2.json({
      protocols: protocols.map((p) => ({
        name: p.name,
        version: p.metadata.version,
        description: p.metadata.description,
        capabilities: p.metadata.capabilities
      }))
    });
  } catch (error) {
    log(`Error getting protocols: ${error}`, "agent");
    res2.status(500).json({
      message: "Error retrieving protocols",
      error: error.message
    });
  }
});
router6.get("/api/agent/tools", async (req2, res2) => {
  try {
    const framework = await initializeAgentFramework();
    const tools2 = framework.getConfig().defaultTools;
    res2.json({
      tools: tools2.map((tool) => ({
        name: tool.name,
        description: tool.description,
        parameters: Object.entries(tool.parameters).map(([name, info]) => ({
          name,
          type: info.type,
          description: info.description,
          required: info.required || false
        }))
      }))
    });
  } catch (error) {
    log(`Error getting tools: ${error}`, "agent");
    res2.status(500).json({
      message: "Error retrieving tools",
      error: error.message
    });
  }
});
router6.get("/api/agent/api-keys", isAuthenticated3, async (req2, res2) => {
  const keys = checkApiKeys();
  res2.json({
    status: keys.missing.length === 0 ? "ok" : "missing",
    providers: {
      anthropic: keys.anthropic,
      openai: keys.openai
    },
    missing: keys.missing
  });
});
router6.get("/api/agent/job/:jobId", isAuthenticated3, async (req2, res2) => {
  const jobStatus = req2.jobStatus;
  if (!jobStatus) {
    return res2.status(404).json({
      message: `Job ${req2.params.jobId} not found`
    });
  }
  res2.json({
    id: jobStatus.id,
    status: jobStatus.status,
    task: jobStatus.data?.task,
    protocol: jobStatus.data?.protocol,
    attempt: jobStatus.data?.attempt,
    history: jobStatus.data?.history,
    result: jobStatus.result
  });
});
router6.get("/api/agent/protocols/by-strength/:strength?", async (req2, res2) => {
  try {
    if (!req2.params.strength) {
      return res2.status(400).json({
        message: "Strength parameter is required",
        validStrengths: Object.values(AgentStrength)
      });
    }
    const strengthValue = req2.params.strength.toLowerCase();
    const strength = Object.values(AgentStrength).find(
      (s) => s.toLowerCase() === strengthValue
    );
    if (!strength) {
      return res2.status(400).json({
        message: `Invalid strength category: ${req2.params.strength}`,
        validStrengths: Object.values(AgentStrength)
      });
    }
    const framework = await initializeAgentFramework();
    const protocols = framework.getProtocolsByStrength(strength);
    res2.json({
      strength: req2.params.strength,
      protocols: protocols.map((p) => ({
        name: p.name,
        version: p.metadata.version,
        description: p.metadata.description,
        capabilities: p.metadata.capabilities
      }))
    });
  } catch (error) {
    log(`Error getting protocols by strength: ${error}`, "agent");
    res2.status(500).json({
      message: "Error retrieving protocols by strength",
      error: error.message
    });
  }
});
router6.get("/api/agent/strengths", async (req2, res2) => {
  try {
    const strengths = Object.entries(AgentStrength).map(([key, value]) => ({
      key,
      value,
      humanReadable: key.split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(" ")
    }));
    res2.json({ strengths });
  } catch (error) {
    log(`Error getting strength categories: ${error}`, "agent");
    res2.status(500).json({
      message: "Error retrieving strength categories",
      error: error.message
    });
  }
});
router6.get("/api/agent/classifications", async (req2, res2) => {
  try {
    const framework = await initializeAgentFramework();
    const classifications = framework.getProtocolClassifications();
    res2.json({ classifications });
  } catch (error) {
    log(`Error getting protocol classifications: ${error}`, "agent");
    res2.status(500).json({
      message: "Error retrieving protocol classifications",
      error: error.message
    });
  }
});
router6.post("/api/agent/recommend", async (req2, res2) => {
  try {
    const { task } = req2.body;
    if (!task || typeof task !== "string" || task.trim() === "") {
      return res2.status(400).json({
        message: "Task is required"
      });
    }
    const framework = await initializeAgentFramework();
    const recommendations = await framework.getRecommendedProtocols(task);
    res2.json(recommendations);
  } catch (error) {
    log(`Error getting protocol recommendations: ${error}`, "agent");
    res2.status(500).json({
      message: "Error retrieving protocol recommendations",
      error: error.message
    });
  }
});
var agent_routes_default = router6;

// server/routes/guardrails-routes.ts
import { Router as Router4 } from "express";
import { z as z3 } from "zod";
var router7 = Router4();
var isAuthenticated4 = (req2, res2, next) => {
  if (!req2.isAuthenticated()) {
    return res2.status(401).json({ message: "Unauthorized" });
  }
  next();
};
router7.get("/api/guardrails/:workflowId", isAuthenticated4, async (req2, res2) => {
  try {
    const { workflowId } = req2.params;
    const config = guardrails.getGuardrailConfig(workflowId);
    if (!config) {
      return res2.status(200).json({
        level: "moderate" /* MODERATE */,
        enabledCategories: [
          "toxicity" /* TOXICITY */,
          "hate_speech" /* HATE_SPEECH */,
          "self_harm" /* SELF_HARM */,
          "jailbreak" /* JAILBREAK */,
          "prompt_injection" /* PROMPT_INJECTION */
        ],
        // Default values for other fields - omitted for brevity
        active: false,
        message: "No configuration set yet, showing default moderate level"
      });
    }
    res2.status(200).json({
      ...config,
      active: true
    });
  } catch (error) {
    logError(
      "get_guardrail_config_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error retrieving guardrail configuration",
      error: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
var guardrailConfigSchema = z3.object({
  level: z3.enum([
    "strict" /* STRICT */,
    "moderate" /* MODERATE */,
    "minimal" /* MINIMAL */,
    "custom" /* CUSTOM */,
    "none" /* NONE */
  ]),
  enabledCategories: z3.array(z3.nativeEnum(ContentCategory)).optional(),
  thresholds: z3.record(z3.nativeEnum(ContentCategory), z3.number().min(0).max(1)).optional().transform(
    (thresholds) => thresholds
  ),
  allowedTopics: z3.array(z3.string()).optional(),
  blockedTopics: z3.array(z3.string()).optional(),
  allowedPatterns: z3.array(z3.string()).optional(),
  blockedPatterns: z3.array(z3.string()).optional(),
  customRules: z3.record(z3.string(), z3.any()).optional()
});
router7.post("/api/guardrails/:workflowId", isAuthenticated4, async (req2, res2) => {
  try {
    const { workflowId } = req2.params;
    const validation = guardrailConfigSchema.safeParse(req2.body);
    if (!validation.success) {
      return res2.status(400).json({
        message: "Invalid guardrail configuration",
        errors: validation.error.format()
      });
    }
    const config = guardrails.setGuardrailConfig(workflowId, validation.data);
    res2.status(200).json({
      message: "Guardrail configuration updated successfully",
      config
    });
  } catch (error) {
    logError(
      "set_guardrail_config_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error setting guardrail configuration",
      error: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
var contentCheckSchema = z3.object({
  content: z3.string().min(1, "Content is required"),
  filter: z3.boolean().optional().default(false)
});
router7.post("/api/guardrails/:workflowId/check", isAuthenticated4, async (req2, res2) => {
  try {
    const { workflowId } = req2.params;
    const validation = contentCheckSchema.safeParse(req2.body);
    if (!validation.success) {
      return res2.status(400).json({
        message: "Invalid request",
        errors: validation.error.format()
      });
    }
    const { content: content2, filter } = validation.data;
    const result2 = filter ? guardrails.filterContent(workflowId, content2) : guardrails.checkContent(workflowId, content2);
    res2.status(200).json(result2);
  } catch (error) {
    logError(
      "check_content_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error checking content",
      error: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router7.post("/api/guardrails/:workflowId/filter", isAuthenticated4, async (req2, res2) => {
  try {
    const { workflowId } = req2.params;
    const validation = z3.object({
      content: z3.string().min(1, "Content is required")
    }).safeParse(req2.body);
    if (!validation.success) {
      return res2.status(400).json({
        message: "Invalid request",
        errors: validation.error.format()
      });
    }
    const { content: content2 } = validation.data;
    const result2 = guardrails.filterContent(workflowId, content2);
    res2.status(200).json(result2);
  } catch (error) {
    logError(
      "filter_content_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error filtering content",
      error: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
var guardrails_routes_default = router7;

// server/routes/search-routes.ts
import { Router as Router5 } from "express";

// server/services/search/index.ts
import { and as and7, desc as desc6, eq as eq10, ilike, inArray as inArray2, sql as sql5 } from "drizzle-orm";
import OpenAI16 from "openai";
var openai = new OpenAI16({ apiKey: process.env.OPENAI_API_KEY });
var SearchService = class {
  /**
   * Perform a basic keyword search
   */
  async basicSearch(query2, filters = {}, page = 1, limit = 20) {
    const sortBy = filters.sortBy || "createdAt";
    const sortDirection = filters.sortDirection || "desc";
    const offset = (page - 1) * limit;
    const whereConditions = [];
    if (filters.userId) {
      whereConditions.push(sql5`metadata->>'userId' = ${filters.userId.toString()}`);
    }
    if (filters.types && filters.types.length > 0) {
      whereConditions.push(inArray2(vectorItems.objectType, filters.types));
    }
    if (query2 && query2.trim() !== "") {
      whereConditions.push(
        sql5`(
          ${ilike(vectorItems.title, `%${query2}%`)} OR 
          ${ilike(vectorItems.content, `%${query2}%`)} OR
          metadata::text ILIKE ${`%${query2}%`}
        )`
      );
    }
    if (filters.fromDate) {
      whereConditions.push(sql5`${vectorItems.createdAt} >= ${filters.fromDate}`);
    }
    if (filters.toDate) {
      whereConditions.push(sql5`${vectorItems.createdAt} <= ${filters.toDate}`);
    }
    if (filters.tags && filters.tags.length > 0) {
      whereConditions.push(
        sql5`metadata->>'tags' ?| array[${filters.tags.join(",")}]`
      );
    }
    const queryBaseCondition = whereConditions.length > 0 ? and7(...whereConditions) : void 0;
    let countQuery = db.select({ count: sql5`count(*)` }).from(vectorItems);
    if (whereConditions.length > 0) {
      countQuery = countQuery.where(queryBaseCondition);
    }
    const countResults = await countQuery;
    const count2 = countResults.length > 0 ? Number(countResults[0].count) : 0;
    const orderByClause = sortDirection === "desc" ? desc6(vectorItems[sortBy]) : vectorItems[sortBy];
    let searchQuery = db.select().from(vectorItems);
    if (whereConditions.length > 0) {
      searchQuery = searchQuery.where(queryBaseCondition);
    }
    const searchResults = await searchQuery.orderBy(orderByClause).limit(limit).offset(offset);
    const results = searchResults.map((item) => this.vectorItemToSearchResult(item));
    return {
      results,
      total: Number(count2),
      page,
      limit
    };
  }
  /**
   * Perform semantic search using vector embeddings with pgvector
   */
  async semanticSearch(query2, filters = {}, page = 1, limit = 20) {
    if (!process.env.OPENAI_API_KEY) {
      throw new Error("OPENAI_API_KEY environment variable not set");
    }
    try {
      const queryEmbedding = await this.generateEmbedding(query2);
      const filterConditions = [];
      if (filters.userId) {
        filterConditions.push(sql5`metadata->>'userId' = ${filters.userId.toString()}`);
      }
      if (filters.types && filters.types.length > 0) {
        filterConditions.push(inArray2(vectorItems.objectType, filters.types));
      }
      if (filters.fromDate) {
        filterConditions.push(sql5`${vectorItems.createdAt} >= ${filters.fromDate}`);
      }
      if (filters.toDate) {
        filterConditions.push(sql5`${vectorItems.createdAt} <= ${filters.toDate}`);
      }
      if (filters.tags && filters.tags.length > 0) {
        filterConditions.push(
          sql5`metadata->>'tags' ?| array[${filters.tags.join(",")}]`
        );
      }
      const filterCondition = filterConditions.length > 0 ? and7(...filterConditions) : void 0;
      const offset = (page - 1) * limit;
      let semCountQuery = db.select({ count: sql5`count(*)` }).from(vectorItems);
      if (filterConditions.length > 0) {
        semCountQuery = semCountQuery.where(filterCondition);
      }
      const countResults = await semCountQuery;
      const count2 = countResults.length > 0 ? Number(countResults[0].count) : 0;
      let vectorQuery = db.select().from(vectorItems);
      if (filterConditions.length > 0) {
        vectorQuery = vectorQuery.where(filterCondition);
      }
      const vectorResults = await vectorQuery.limit(limit * 3).offset(offset);
      const scoredResults = vectorResults.map((item) => {
        const storedEmbedding = Array.isArray(item.embedding) ? item.embedding : JSON.parse(item.embedding);
        let dotProduct = 0;
        let magnitudeA = 0;
        let magnitudeB = 0;
        for (let i = 0; i < queryEmbedding.length; i++) {
          dotProduct += queryEmbedding[i] * storedEmbedding[i];
          magnitudeA += queryEmbedding[i] * queryEmbedding[i];
          magnitudeB += storedEmbedding[i] * storedEmbedding[i];
        }
        const relevanceScore = dotProduct / (Math.sqrt(magnitudeA) * Math.sqrt(magnitudeB));
        return {
          ...item,
          relevanceScore
        };
      });
      const sortedResults = scoredResults.sort((a, b) => b.relevanceScore - a.relevanceScore).slice(0, limit);
      const results = sortedResults.map((item) => ({
        ...this.vectorItemToSearchResult(item),
        relevanceScore: item.relevanceScore
      }));
      return {
        results,
        total: Number(count2),
        page,
        limit
      };
    } catch (error) {
      console.error("Semantic search error:", error);
      return this.basicSearch(query2, filters, page, limit);
    }
  }
  /**
   * Index content for search using pgvector
   */
  async indexContent(objectId, objectType, title, content2, metadata = {}) {
    try {
      const embedding = await this.generateEmbedding(content2);
      const [existingItem] = await db.select().from(vectorItems).where(
        and7(
          eq10(vectorItems.objectId, objectId),
          eq10(vectorItems.objectType, objectType)
        )
      );
      if (existingItem) {
        const [updated] = await db.update(vectorItems).set({
          title,
          content: content2,
          embedding,
          // pgvector will handle the array format properly
          metadata,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq10(vectorItems.id, existingItem.id)).returning();
        return updated;
      } else {
        const [newItem] = await db.insert(vectorItems).values({
          objectId,
          objectType,
          title,
          content: content2,
          embedding,
          // pgvector will handle the array format properly
          metadata,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).returning();
        return newItem;
      }
    } catch (error) {
      console.error("Error indexing content:", error);
      throw error;
    }
  }
  /**
   * Remove indexed content
   */
  async removeIndex(objectId, objectType) {
    await db.delete(vectorItems).where(
      and7(
        eq10(vectorItems.objectId, objectId),
        eq10(vectorItems.objectType, objectType)
      )
    );
  }
  /**
   * Save a search for later use
   */
  async saveSearch(userId, name, query2, filters, entityType) {
    const [savedSearch] = await db.insert(savedSearches).values({
      userId,
      name,
      query: query2,
      filters,
      entityType,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    }).returning();
    return savedSearch;
  }
  /**
   * Get saved searches for a user
   */
  async getSavedSearches(userId, entityType) {
    const conditions = [eq10(savedSearches.userId, userId)];
    if (entityType) {
      conditions.push(eq10(savedSearches.entityType, entityType));
    }
    return db.select().from(savedSearches).where(and7(...conditions)).orderBy(desc6(savedSearches.updatedAt));
  }
  /**
   * Generate vector embedding using OpenAI
   */
  async generateEmbedding(text2) {
    if (!process.env.OPENAI_API_KEY) {
      return Array.from({ length: 1536 }, () => Math.random());
    }
    try {
      const response = await openai.embeddings.create({
        model: "text-embedding-ada-002",
        input: text2.slice(0, 8e3)
        // Limit to 8000 chars per OpenAI docs
      });
      return response.data[0].embedding;
    } catch (error) {
      console.error("Error generating embedding:", error);
      return Array.from({ length: 1536 }, () => Math.random());
    }
  }
  // Cosine similarity is now handled directly by pgvector in the database
  /**
   * Transform VectorItem to SearchResult
   */
  vectorItemToSearchResult(item) {
    return {
      id: item.objectId,
      type: item.objectType,
      title: item.title || "",
      content: item.content,
      metadata: item.metadata || {},
      createdAt: item.createdAt,
      updatedAt: item.updatedAt,
      relevanceScore: item.relevanceScore
    };
  }
};
var searchService = new SearchService();

// server/routes/search-routes.ts
import { z as z4 } from "zod";
var router8 = Router5();
var isAuthenticated5 = (req2, res2, next) => {
  if (!req2.isAuthenticated()) {
    return res2.status(401).json({ message: "Unauthorized" });
  }
  next();
};
router8.get("/api/search", isAuthenticated5, async (req2, res2) => {
  try {
    const {
      q = "",
      types = "",
      tags = "",
      from,
      to,
      status,
      sort = "createdAt",
      direction = "desc",
      page = "1",
      limit = "20"
    } = req2.query;
    const filters = {
      userId: req2.user.id,
      types: types ? types.split(",") : void 0,
      tags: tags ? tags.split(",") : void 0,
      fromDate: from ? new Date(from) : void 0,
      toDate: to ? new Date(to) : void 0,
      status,
      sortBy: sort,
      sortDirection: direction
    };
    const results = await searchService.basicSearch(
      q,
      filters,
      parseInt(page),
      parseInt(limit)
    );
    logInfo(
      "search_performed",
      { query: q, filters, resultsCount: results.total },
      req2.user.id,
      void 0,
      void 0,
      req2
    );
    res2.status(200).json(results);
  } catch (error) {
    logError(
      "search_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error performing search",
      error: error.message
    });
  }
});
router8.get("/api/semantic-search", isAuthenticated5, async (req2, res2) => {
  try {
    const {
      q = "",
      types = "",
      tags = "",
      from,
      to,
      status,
      page = "1",
      limit = "20"
    } = req2.query;
    const filters = {
      userId: req2.user.id,
      types: types ? types.split(",") : void 0,
      tags: tags ? tags.split(",") : void 0,
      fromDate: from ? new Date(from) : void 0,
      toDate: to ? new Date(to) : void 0,
      status
    };
    if (!process.env.OPENAI_API_KEY) {
      return res2.status(400).json({
        message: "Semantic search is not available because OpenAI API key is not configured",
        fallbackResults: await searchService.basicSearch(q, filters, parseInt(page), parseInt(limit))
      });
    }
    const results = await searchService.semanticSearch(
      q,
      filters,
      parseInt(page),
      parseInt(limit)
    );
    logInfo(
      "semantic_search_performed",
      { query: q, filters, resultsCount: results.total },
      req2.user.id,
      void 0,
      void 0,
      req2
    );
    res2.status(200).json(results);
  } catch (error) {
    logError(
      "semantic_search_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    try {
      const {
        q = "",
        types = "",
        tags = "",
        from,
        to,
        status,
        page = "1",
        limit = "20"
      } = req2.query;
      const filters = {
        userId: req2.user.id,
        types: types ? types.split(",") : void 0,
        tags: tags ? tags.split(",") : void 0,
        fromDate: from ? new Date(from) : void 0,
        toDate: to ? new Date(to) : void 0,
        status
      };
      const fallbackResults = await searchService.basicSearch(
        q,
        filters,
        parseInt(page),
        parseInt(limit)
      );
      res2.status(200).json({
        message: "Semantic search failed, falling back to basic search",
        error: error.message,
        ...fallbackResults
      });
    } catch (fallbackError) {
      res2.status(500).json({
        message: "Error performing search",
        error: error.message
      });
    }
  }
});
var saveSearchSchema = z4.object({
  name: z4.string().min(1, "Name is required"),
  query: z4.string(),
  filters: z4.record(z4.any()).optional(),
  entityType: z4.string().min(1, "Entity type is required")
});
router8.post("/api/search/save", isAuthenticated5, async (req2, res2) => {
  try {
    const validation = saveSearchSchema.safeParse(req2.body);
    if (!validation.success) {
      return res2.status(400).json({
        message: "Invalid request",
        errors: validation.error.flatten().fieldErrors
      });
    }
    const { name, query: query2, filters, entityType } = validation.data;
    const savedSearch = await searchService.saveSearch(
      req2.user.id,
      name,
      query2,
      filters || {},
      entityType
    );
    logInfo(
      "search_saved",
      { name, query: query2, entityType },
      req2.user.id,
      void 0,
      void 0,
      req2
    );
    res2.status(201).json(savedSearch);
  } catch (error) {
    logError(
      "save_search_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error saving search",
      error: error.message
    });
  }
});
router8.get("/api/search/saved", isAuthenticated5, async (req2, res2) => {
  try {
    const { type } = req2.query;
    const savedSearches2 = await searchService.getSavedSearches(
      req2.user.id,
      type
    );
    res2.status(200).json(savedSearches2);
  } catch (error) {
    logError(
      "get_saved_searches_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error retrieving saved searches",
      error: error.message
    });
  }
});
var search_routes_default = router8;

// server/routes/langflow-routes.ts
import { Router as Router6 } from "express";
import { z as z5 } from "zod";

// server/services/langflow/index.ts
import { eq as eq11 } from "drizzle-orm";
import axios5 from "axios";
var LangflowService = class {
  apiUrl;
  apiKey;
  isInitialized = false;
  constructor() {
    this.apiUrl = process.env.LANGFLOW_API_URL || "http://localhost:7860";
    this.apiKey = process.env.LANGFLOW_API_KEY || null;
    if (!this.apiKey) {
      log("LANGFLOW_API_KEY environment variable is not set. Some Langflow features may be limited.", "langflow");
    }
    log("Langflow service initialized", "langflow");
    this.isInitialized = true;
  }
  /**
   * Check if the Langflow service is available
   */
  async isAvailable() {
    try {
      const response = await axios5.get(`${this.apiUrl}/api/v1/health`);
      return response.status === 200;
    } catch (error) {
      log(`Error checking Langflow availability: ${error}`, "langflow");
      return false;
    }
  }
  /**
   * Set the API key for Langflow
   */
  setApiKey(apiKey) {
    this.apiKey = apiKey;
    process.env.LANGFLOW_API_KEY = apiKey;
    log("Langflow API key set", "langflow");
  }
  /**
   * Create a new workflow in Langflow
   */
  async createWorkflow(name, description, data) {
    try {
      const response = await axios5.post(`${this.apiUrl}/api/v1/flows`, {
        name,
        description,
        data: data || this.getDefaultWorkflowTemplate()
      }, {
        headers: this.getHeaders()
      });
      return response.data;
    } catch (error) {
      log(`Error creating Langflow workflow: ${error}`, "langflow");
      throw new Error(`Failed to create Langflow workflow: ${error}`);
    }
  }
  /**
   * Get a workflow from Langflow by ID
   */
  async getWorkflow(id) {
    try {
      const response = await axios5.get(`${this.apiUrl}/api/v1/flows/${id}`, {
        headers: this.getHeaders()
      });
      return response.data;
    } catch (error) {
      log(`Error fetching Langflow workflow: ${error}`, "langflow");
      throw new Error(`Failed to fetch Langflow workflow: ${error}`);
    }
  }
  /**
   * Update an existing workflow in Langflow
   */
  async updateWorkflow(id, data) {
    try {
      const response = await axios5.put(`${this.apiUrl}/api/v1/flows/${id}`, data, {
        headers: this.getHeaders()
      });
      return response.data;
    } catch (error) {
      log(`Error updating Langflow workflow: ${error}`, "langflow");
      throw new Error(`Failed to update Langflow workflow: ${error}`);
    }
  }
  /**
   * Delete a workflow from Langflow
   */
  async deleteWorkflow(id) {
    try {
      await axios5.delete(`${this.apiUrl}/api/v1/flows/${id}`, {
        headers: this.getHeaders()
      });
      return true;
    } catch (error) {
      log(`Error deleting Langflow workflow: ${error}`, "langflow");
      throw new Error(`Failed to delete Langflow workflow: ${error}`);
    }
  }
  /**
   * Execute a workflow in Langflow
   */
  async executeWorkflow(id, inputs) {
    try {
      const response = await axios5.post(`${this.apiUrl}/api/v1/flows/${id}/execute`, {
        inputs
      }, {
        headers: this.getHeaders()
      });
      return {
        id: response.data.id,
        workflowId: id,
        inputs,
        outputs: response.data.outputs,
        status: response.data.status,
        error: response.data.error,
        logs: response.data.logs,
        metrics: response.data.metrics,
        startTime: /* @__PURE__ */ new Date(),
        endTime: /* @__PURE__ */ new Date()
      };
    } catch (error) {
      log(`Error executing Langflow workflow: ${error}`, "langflow");
      throw new Error(`Failed to execute Langflow workflow: ${error}`);
    }
  }
  /**
   * Get available components from Langflow
   */
  async getComponents() {
    try {
      const response = await axios5.get(`${this.apiUrl}/api/v1/components`, {
        headers: this.getHeaders()
      });
      return response.data;
    } catch (error) {
      log(`Error fetching Langflow components: ${error}`, "langflow");
      throw new Error(`Failed to fetch Langflow components: ${error}`);
    }
  }
  /**
   * Import a workflow from a JSON file
   */
  async importWorkflow(workflowJson) {
    try {
      const response = await axios5.post(`${this.apiUrl}/api/v1/flows/import`, workflowJson, {
        headers: this.getHeaders()
      });
      return response.data;
    } catch (error) {
      log(`Error importing Langflow workflow: ${error}`, "langflow");
      throw new Error(`Failed to import Langflow workflow: ${error}`);
    }
  }
  /**
   * Export a workflow to JSON format
   */
  async exportWorkflow(id) {
    try {
      const response = await axios5.get(`${this.apiUrl}/api/v1/flows/${id}/export`, {
        headers: this.getHeaders()
      });
      return response.data;
    } catch (error) {
      log(`Error exporting Langflow workflow: ${error}`, "langflow");
      throw new Error(`Failed to export Langflow workflow: ${error}`);
    }
  }
  /**
   * Convert a SynthralOS workflow to Langflow format
   */
  async convertToLangflow(workflowId) {
    try {
      const [workflow] = await db.select().from(workflows).where(eq11(workflows.id, workflowId));
      if (!workflow) {
        throw new Error(`Workflow with ID ${workflowId} not found`);
      }
      const langflowData = this.convertToLangflowFormat(workflow.data);
      return await this.createWorkflow(
        workflow.name,
        workflow.description || void 0,
        langflowData
      );
    } catch (error) {
      log(`Error converting workflow to Langflow: ${error}`, "langflow");
      throw new Error(`Failed to convert workflow to Langflow: ${error}`);
    }
  }
  /**
   * Convert a Langflow workflow to SynthralOS format
   */
  async convertFromLangflow(langflowId) {
    try {
      const langflowWorkflow = await this.getWorkflow(langflowId);
      const synthralOSData = this.convertFromLangflowFormat(langflowWorkflow.data);
      return synthralOSData;
    } catch (error) {
      log(`Error converting Langflow workflow to SynthralOS: ${error}`, "langflow");
      throw new Error(`Failed to convert Langflow workflow to SynthralOS: ${error}`);
    }
  }
  /**
   * Sync a workflow between SynthralOS and Langflow
   */
  async syncWorkflow(workflowId, langflowId) {
    try {
      const [workflow] = await db.select().from(workflows).where(eq11(workflows.id, workflowId));
      const langflowWorkflow = await this.getWorkflow(langflowId);
      if (!workflow) {
        throw new Error(`Workflow with ID ${workflowId} not found`);
      }
      if (!langflowWorkflow) {
        throw new Error(`Langflow workflow with ID ${langflowId} not found`);
      }
      const workflowData = workflow.data;
      await db.update(workflows).set({
        data: {
          ...workflowData,
          langflowId,
          lastSyncedAt: (/* @__PURE__ */ new Date()).toISOString()
        }
      }).where(eq11(workflows.id, workflowId));
      return true;
    } catch (error) {
      log(`Error syncing workflow with Langflow: ${error}`, "langflow");
      throw new Error(`Failed to sync workflow with Langflow: ${error}`);
    }
  }
  /**
   * Generate a default workflow template
   */
  getDefaultWorkflowTemplate() {
    return {
      nodes: [],
      edges: [],
      version: "1.0.0"
    };
  }
  /**
   * Get headers for API requests
   */
  getHeaders() {
    const headers = {
      "Content-Type": "application/json"
    };
    if (this.apiKey) {
      headers["Authorization"] = `Bearer ${this.apiKey}`;
    }
    return headers;
  }
  /**
   * Convert SynthralOS workflow data to Langflow format
   */
  convertToLangflowFormat(data) {
    const langflowNodes = (data.nodes || []).map((node) => {
      const langflowType = this.mapNodeTypeToLangflow(node.type);
      const nodeTemplate = this.getLangflowNodeTemplate(langflowType);
      return {
        id: node.id,
        type: langflowType,
        position: node.position,
        width: node.width || 200,
        height: node.height || 150,
        selected: node.selected || false,
        positionAbsolute: node.positionAbsolute || node.position,
        dragging: false,
        data: {
          ...nodeTemplate.data,
          ...node.data,
          node_id: node.id,
          type: langflowType,
          // Convert parameters to match Langflow format
          parameters: {
            ...nodeTemplate.data?.parameters || {},
            ...node.data?.parameters || {}
          },
          // Handle display properties
          display_name: node.data?.label || nodeTemplate.data?.display_name || langflowType,
          description: node.data?.description || nodeTemplate.data?.description || ""
        },
        // Style and display properties
        style: {
          ...nodeTemplate.style,
          ...node.style
        }
      };
    });
    const langflowEdges = (data.edges || []).map((edge) => {
      return {
        id: edge.id,
        source: edge.source,
        target: edge.target,
        sourceHandle: edge.sourceHandle || null,
        targetHandle: edge.targetHandle || null,
        type: edge.type || "default",
        markerEnd: edge.markerEnd || {
          type: "arrowclosed",
          width: 20,
          height: 20
        },
        animated: edge.animated || false,
        style: edge.style || {
          stroke: "#555",
          strokeWidth: 2
        }
      };
    });
    return {
      nodes: langflowNodes,
      edges: langflowEdges,
      viewport: data.viewport || { x: 0, y: 0, zoom: 1 },
      version: "1.0.0",
      description: data.description || "",
      name: data.name || "Converted Workflow"
    };
  }
  /**
   * Convert Langflow workflow data to SynthralOS format
   */
  convertFromLangflowFormat(data) {
    const synthralNodes = (data.nodes || []).map((node) => {
      const synthralType = this.mapLangflowNodeType(node.type);
      return {
        id: node.id,
        type: synthralType,
        position: node.position,
        width: node.width,
        height: node.height,
        selected: node.selected || false,
        positionAbsolute: node.positionAbsolute,
        // Convert parameters to match SynthralOS format
        data: {
          ...node.data,
          label: node.data?.display_name || node.data?.node_id || node.id,
          description: node.data?.description || "",
          // Extract parameters from Langflow format
          parameters: this.extractParametersFromLangflowNode(node.data),
          // Store original type for reference
          originalType: node.type
        },
        style: node.style || {}
      };
    });
    const synthralEdges = (data.edges || []).map((edge) => {
      return {
        id: edge.id,
        source: edge.source,
        target: edge.target,
        sourceHandle: edge.sourceHandle,
        targetHandle: edge.targetHandle,
        type: edge.type || "default",
        animated: edge.animated || false,
        style: edge.style || {}
      };
    });
    return {
      nodes: synthralNodes,
      edges: synthralEdges,
      viewport: data.viewport,
      description: data.description,
      name: data.name
    };
  }
  /**
   * Extract parameters from a Langflow node data
   */
  extractParametersFromLangflowNode(nodeData) {
    if (!nodeData) return {};
    const parameters = {};
    if (nodeData.parameters && typeof nodeData.parameters === "object") {
      Object.entries(nodeData.parameters).forEach(([key, value]) => {
        parameters[key] = value;
      });
    }
    if (nodeData.template && typeof nodeData.template === "object") {
      Object.entries(nodeData.template).forEach(([key, value]) => {
        if (value && typeof value === "object" && "value" in value) {
          parameters[key] = value.value;
        }
      });
    }
    return parameters;
  }
  /**
   * Get a template for a Langflow node type
   */
  getLangflowNodeTemplate(nodeType) {
    const templates = {
      // LLM Nodes
      "ChatOpenAI": {
        data: {
          display_name: "ChatOpenAI",
          description: "OpenAI Chat Model",
          parameters: {
            model_name: "gpt-4o",
            temperature: 0.7,
            max_tokens: 256
          },
          template: {
            model_name: { value: "gpt-4o" },
            temperature: { value: 0.7 },
            max_tokens: { value: 256 }
          }
        },
        style: {
          background: "#FFF5E0",
          color: "#000",
          border: "1px solid #FF9500",
          borderRadius: "4px"
        }
      },
      "ChatAnthropic": {
        data: {
          display_name: "ChatAnthropic",
          description: "Anthropic Claude Chat Model",
          parameters: {
            model_name: "claude-3-7-sonnet-20250219",
            temperature: 0.7,
            max_tokens: 1024
          },
          template: {
            model_name: { value: "claude-3-7-sonnet-20250219" },
            temperature: { value: 0.7 },
            max_tokens: { value: 1024 }
          }
        },
        style: {
          background: "#F0F0FF",
          color: "#000",
          border: "1px solid #9370DB",
          borderRadius: "4px"
        }
      },
      // Chain Nodes
      "LLMChain": {
        data: {
          display_name: "LLM Chain",
          description: "Chain to run queries against LLMs",
          parameters: {
            verbose: true
          },
          template: {
            verbose: { value: true }
          }
        },
        style: {
          background: "#E8F4FD",
          color: "#000",
          border: "1px solid #0096FF",
          borderRadius: "4px"
        }
      },
      // Prompt Nodes
      "PromptTemplate": {
        data: {
          display_name: "Prompt Template",
          description: "Template for generating prompts",
          parameters: {
            template: "You are a helpful assistant. Answer the following question:\n\n{question}",
            input_variables: ["question"]
          },
          template: {
            template: {
              value: "You are a helpful assistant. Answer the following question:\n\n{question}"
            },
            input_variables: { value: ["question"] }
          }
        },
        style: {
          background: "#F5FFE0",
          color: "#000",
          border: "1px solid #8BC34A",
          borderRadius: "4px"
        }
      },
      // Memory Nodes
      "BufferMemory": {
        data: {
          display_name: "Buffer Memory",
          description: "Memory for storing chat history",
          parameters: {
            memory_key: "chat_history",
            return_messages: true
          },
          template: {
            memory_key: { value: "chat_history" },
            return_messages: { value: true }
          }
        },
        style: {
          background: "#FFE0FB",
          color: "#000",
          border: "1px solid #E040FB",
          borderRadius: "4px"
        }
      },
      // Vector Store Nodes
      "VectorStoreNode": {
        data: {
          display_name: "Vector Store",
          description: "Store and retrieve vectors",
          parameters: {
            collection_name: "default",
            search_type: "similarity",
            k: 5
          },
          template: {
            collection_name: { value: "default" },
            search_type: { value: "similarity" },
            k: { value: 5 }
          }
        },
        style: {
          background: "#E0FFFF",
          color: "#000",
          border: "1px solid #00CED1",
          borderRadius: "4px"
        }
      },
      // Tool Nodes
      "Tool": {
        data: {
          display_name: "Tool",
          description: "Tool for an agent to use",
          parameters: {
            name: "search",
            description: "Useful for searching information"
          },
          template: {
            name: { value: "search" },
            description: { value: "Useful for searching information" }
          }
        },
        style: {
          background: "#FFE0E0",
          color: "#000",
          border: "1px solid #FF5252",
          borderRadius: "4px"
        }
      },
      // Agent Nodes
      "OpenAIFunctionsAgent": {
        data: {
          display_name: "OpenAI Functions Agent",
          description: "Agent that uses OpenAI function calling",
          parameters: {
            system_message: "You are a helpful assistant with access to tools."
          },
          template: {
            system_message: {
              value: "You are a helpful assistant with access to tools."
            }
          }
        },
        style: {
          background: "#E6F7FF",
          color: "#000",
          border: "1px solid #1890FF",
          borderRadius: "4px"
        }
      },
      // Default node
      "default": {
        data: {
          display_name: "Custom Node",
          description: "Custom node type",
          parameters: {}
        },
        style: {
          background: "#F5F5F5",
          color: "#000",
          border: "1px solid #999",
          borderRadius: "4px"
        }
      }
    };
    return templates[nodeType] || templates.default;
  }
  /**
   * Map SynthralOS node type to Langflow node type
   */
  mapNodeTypeToLangflow(nodeType) {
    const nodeTypeMap = {
      // Input/Output
      "input": "InputNode",
      "output": "OutputNode",
      // LLM Models
      "llm": "ChatOpenAI",
      "openai": "ChatOpenAI",
      "claude": "ChatAnthropic",
      "anthropic": "ChatAnthropic",
      "mistral": "ChatMistral",
      "llama": "ChatOllama",
      "gemini": "ChatGoogleGenerativeAI",
      "perplexity": "ChatPerplexity",
      "cohere": "ChatCohere",
      "groq": "ChatGroq",
      // Chains
      "chain": "LLMChain",
      "sequentialChain": "SequentialChain",
      "routerChain": "RouterChain",
      "retrievalChain": "RetrievalQAChain",
      "summarizationChain": "SummarizeChain",
      "qaChain": "QAChain",
      "ragChain": "RagChain",
      "mapReduceChain": "MapReduceChain",
      "refineChain": "RefineChain",
      "conversationalChain": "ConversationalRetrievalChain",
      "sqlChain": "SqlDatabaseChain",
      "apiChain": "APIChain",
      // Agents
      "agent": "OpenAIFunctionsAgent",
      "conversationalAgent": "ConversationalAgent",
      "reactAgent": "ReActAgent",
      "planAndExecuteAgent": "PlanAndExecuteAgent",
      "toolAgent": "ToolCallingAgent",
      "xmlAgent": "XMLAgent",
      "multiAgentOrchestrator": "MultiAgentOrchestrator",
      "jsonAgent": "JSONAgent",
      "creativeAgent": "CreativeAgent",
      "autogptAgent": "AutoGPTAgent",
      "babyagiAgent": "BabyAGIAgent",
      "crewAIAgent": "CrewAIAgent",
      // Memory
      "memory": "BufferMemory",
      "conversationMemory": "ConversationBufferMemory",
      "summaryMemory": "ConversationSummaryMemory",
      "vectorMemory": "VectorStoreMemory",
      "windowMemory": "ConversationBufferWindowMemory",
      "entityMemory": "EntityMemory",
      "zepMemory": "ZepMemory",
      "motifMemory": "MotifMemory",
      "graphMemory": "GraphMemory",
      "postgresMemory": "PostgresMemory",
      "redisMemory": "RedisMemory",
      // Tools
      "tool": "Tool",
      "searchTool": "SearchTool",
      "calculatorTool": "CalculatorTool",
      "webBrowserTool": "WebBrowserTool",
      "wolframAlphaTool": "WolframAlphaTool",
      "databaseTool": "SQLDatabaseTool",
      "apiTool": "APITool",
      "pythonTool": "PythonREPLTool",
      "fileToolkit": "FileManagementToolkit",
      "slackTool": "SlackTool",
      "zapierTool": "ZapierNLATool",
      "shellTool": "ShellTool",
      "githubTool": "GitHubSearchTool",
      "googleToolkit": "GoogleSearchToolkit",
      "playWrightTool": "PlayWrightBrowserTool",
      "puppeteerTool": "PuppeteerTool",
      "makeToolkit": "HumanInputToolkit",
      // Prompts
      "promptTemplate": "PromptTemplate",
      "chatPromptTemplate": "ChatPromptTemplate",
      "systemMessage": "SystemMessagePromptTemplate",
      "humanMessage": "HumanMessagePromptTemplate",
      "messagesPlaceholder": "MessagesPlaceholder",
      "aiMessage": "AIMessagePromptTemplate",
      "fewShotPromptTemplate": "FewShotPromptTemplate",
      "toolMessage": "ToolMessagePromptTemplate",
      // Vector Stores
      "vectorStore": "VectorStoreNode",
      "pgvector": "PGVectorStore",
      "chroma": "ChromaStore",
      "pinecone": "PineconeStore",
      "supavec": "SupavecStore",
      "qdrant": "QdrantVectorStore",
      "weaviate": "WeaviateStore",
      "faiss": "FaissStore",
      "milvus": "MilvusStore",
      "redisVector": "RedisVectorStore",
      // Document Processing
      "textSplitter": "RecursiveCharacterTextSplitter",
      "documentLoader": "TextLoader",
      "pdfLoader": "PDFLoader",
      "webLoader": "WebLoader",
      "csvLoader": "CSVLoader",
      "jsonLoader": "JSONLoader",
      "htmlLoader": "HTMLLoader",
      "markdownLoader": "MarkdownLoader",
      "sitemapLoader": "SitemapLoader",
      "documentCompressor": "DocumentCompressor",
      "documentTransformer": "DocumentTransformer",
      // Retrievers
      "retriever": "VectorStoreRetriever",
      "contextualRetriever": "ContextualCompressor",
      "hybridRetriever": "HybridRetriever",
      "multiQueryRetriever": "MultiQueryRetriever",
      "parentDocumentRetriever": "ParentDocumentRetriever",
      "selfQueryRetriever": "SelfQueryRetriever",
      "ensembleRetriever": "EnsembleRetriever",
      "timeWeightedRetriever": "TimeWeightedRetriever",
      // Parsers
      "parser": "OutputParser",
      "structuredParser": "StructuredOutputParser",
      "jsonParser": "JsonOutputParser",
      "xmlParser": "XMLOutputParser",
      "pydanticParser": "PydanticOutputParser",
      "promptLayerParser": "PromptLayerOutputParser",
      // External Integrations
      "slack": "SlackIntegration",
      "zapier": "ZapierIntegration",
      "github": "GitHubIntegration",
      "notion": "NotionIntegration",
      "airtable": "AirtableIntegration",
      "googleDrive": "GoogleDriveIntegration",
      "gmail": "GmailIntegration",
      "discord": "DiscordIntegration",
      "trello": "TrelloIntegration",
      "hubspot": "HubspotIntegration",
      "salesforce": "SalesforceIntegration",
      "zendesk": "ZendeskIntegration",
      // Observability
      "langfuse": "LangfuseTracer",
      "llamaindex": "LlamaIndexNode",
      "posthog": "PosthogTracker",
      "opentelemetry": "OpenTelemetryTracer",
      "signoz": "SignozMonitor",
      "weightsAndBiases": "WandbMonitor"
    };
    return nodeTypeMap[nodeType] || "CustomNode";
  }
  /**
   * Map Langflow node type to SynthralOS node type
   */
  mapLangflowNodeType(nodeType) {
    const nodeTypeMap = {
      // Input/Output
      "InputNode": "input",
      "OutputNode": "output",
      // LLM Models
      "ChatOpenAI": "openai",
      "OpenAI": "openai",
      "ChatAnthropic": "anthropic",
      "Anthropic": "anthropic",
      "ChatMistral": "mistral",
      "ChatOllama": "llama",
      "ChatGoogleGenerativeAI": "gemini",
      "ChatPerplexity": "perplexity",
      "ChatCohere": "cohere",
      "ChatGroq": "groq",
      // Chains
      "LLMChain": "chain",
      "SequentialChain": "sequentialChain",
      "RouterChain": "routerChain",
      "RetrievalQAChain": "retrievalChain",
      "SummarizeChain": "summarizationChain",
      "QAChain": "qaChain",
      "RagChain": "ragChain",
      "MapReduceChain": "mapReduceChain",
      "RefineChain": "refineChain",
      "ConversationalRetrievalChain": "conversationalChain",
      "SqlDatabaseChain": "sqlChain",
      "APIChain": "apiChain",
      // Agents
      "OpenAIFunctionsAgent": "agent",
      "ConversationalAgent": "conversationalAgent",
      "ReActAgent": "reactAgent",
      "PlanAndExecuteAgent": "planAndExecuteAgent",
      "ToolCallingAgent": "toolAgent",
      "XMLAgent": "xmlAgent",
      "MultiAgentOrchestrator": "multiAgentOrchestrator",
      "JSONAgent": "jsonAgent",
      "CreativeAgent": "creativeAgent",
      "AutoGPTAgent": "autogptAgent",
      "BabyAGIAgent": "babyagiAgent",
      "CrewAIAgent": "crewAIAgent",
      // Memory
      "BufferMemory": "memory",
      "ConversationBufferMemory": "conversationMemory",
      "ConversationSummaryMemory": "summaryMemory",
      "VectorStoreMemory": "vectorMemory",
      "ConversationBufferWindowMemory": "windowMemory",
      "EntityMemory": "entityMemory",
      "ZepMemory": "zepMemory",
      "MotifMemory": "motifMemory",
      "GraphMemory": "graphMemory",
      "PostgresMemory": "postgresMemory",
      "RedisMemory": "redisMemory",
      // Tools
      "Tool": "tool",
      "SearchTool": "searchTool",
      "CalculatorTool": "calculatorTool",
      "WebBrowserTool": "webBrowserTool",
      "WolframAlphaTool": "wolframAlphaTool",
      "SQLDatabaseTool": "databaseTool",
      "APITool": "apiTool",
      "PythonREPLTool": "pythonTool",
      "FileManagementToolkit": "fileToolkit",
      "SlackTool": "slackTool",
      "ZapierNLATool": "zapierTool",
      "ShellTool": "shellTool",
      "GitHubSearchTool": "githubTool",
      "GoogleSearchToolkit": "googleToolkit",
      "PlayWrightBrowserTool": "playWrightTool",
      "PuppeteerTool": "puppeteerTool",
      "HumanInputToolkit": "makeToolkit",
      // Prompts
      "PromptTemplate": "promptTemplate",
      "ChatPromptTemplate": "chatPromptTemplate",
      "SystemMessagePromptTemplate": "systemMessage",
      "HumanMessagePromptTemplate": "humanMessage",
      "MessagesPlaceholder": "messagesPlaceholder",
      "AIMessagePromptTemplate": "aiMessage",
      "FewShotPromptTemplate": "fewShotPromptTemplate",
      "ToolMessagePromptTemplate": "toolMessage",
      // Vector Stores
      "VectorStoreNode": "vectorStore",
      "PGVectorStore": "pgvector",
      "ChromaStore": "chroma",
      "PineconeStore": "pinecone",
      "SupavecStore": "supavec",
      "QdrantVectorStore": "qdrant",
      "WeaviateStore": "weaviate",
      "FaissStore": "faiss",
      "MilvusStore": "milvus",
      "RedisVectorStore": "redis",
      // Document Processing
      "RecursiveCharacterTextSplitter": "textSplitter",
      "TextLoader": "documentLoader",
      "PDFLoader": "pdfLoader",
      "WebLoader": "webLoader",
      "CSVLoader": "csvLoader",
      "JSONLoader": "jsonLoader",
      "HTMLLoader": "htmlLoader",
      "MarkdownLoader": "markdownLoader",
      "SitemapLoader": "sitemapLoader",
      "DocumentCompressor": "documentCompressor",
      "DocumentTransformer": "documentTransformer",
      // Retrievers
      "VectorStoreRetriever": "retriever",
      "ContextualCompressor": "contextualRetriever",
      "HybridRetriever": "hybridRetriever",
      "MultiQueryRetriever": "multiQueryRetriever",
      "ParentDocumentRetriever": "parentDocumentRetriever",
      "SelfQueryRetriever": "selfQueryRetriever",
      "EnsembleRetriever": "ensembleRetriever",
      "TimeWeightedRetriever": "timeWeightedRetriever",
      // Parsers
      "OutputParser": "parser",
      "StructuredOutputParser": "structuredParser",
      "JsonOutputParser": "jsonParser",
      "XMLOutputParser": "xmlParser",
      "PydanticOutputParser": "pydanticParser",
      "PromptLayerOutputParser": "promptLayerParser",
      // External Integrations
      "SlackIntegration": "slack",
      "ZapierIntegration": "zapier",
      "GitHubIntegration": "github",
      "NotionIntegration": "notion",
      "AirtableIntegration": "airtable",
      "GoogleDriveIntegration": "googleDrive",
      "GmailIntegration": "gmail",
      "DiscordIntegration": "discord",
      "TrelloIntegration": "trello",
      "HubspotIntegration": "hubspot",
      "SalesforceIntegration": "salesforce",
      "ZendeskIntegration": "zendesk",
      // Observability
      "LangfuseTracer": "langfuse",
      "LlamaIndexNode": "llamaindex",
      "PosthogTracker": "posthog",
      "OpenTelemetryTracer": "opentelemetry",
      "SignozMonitor": "signoz",
      "WandbMonitor": "weightsAndBiases"
    };
    return nodeTypeMap[nodeType] || "custom";
  }
};
var langflowService = new LangflowService();

// server/routes/langflow-routes.ts
var router9 = Router6();
var workflowSchema = z5.object({
  name: z5.string().min(1, "Name is required"),
  description: z5.string().optional(),
  data: z5.any()
});
var executeWorkflowSchema = z5.object({
  inputs: z5.record(z5.any())
});
var convertWorkflowSchema = z5.object({
  workflowId: z5.number().int().positive()
});
var syncWorkflowSchema = z5.object({
  workflowId: z5.number().int().positive(),
  langflowId: z5.string().min(1, "Langflow ID is required")
});
var configSchema = z5.object({
  apiUrl: z5.string().url("Invalid URL format"),
  apiKey: z5.string().min(1, "API key is required")
});
router9.get("/status", async (req2, res2) => {
  try {
    const isAvailable = await langflowService.isAvailable();
    res2.json({
      status: isAvailable ? "operational" : "unavailable",
      available: isAvailable,
      version: "v1.0.0",
      api_url: process.env.LANGFLOW_API_URL || "http://localhost:7860",
      features: {
        components: true,
        visualization: true,
        execution: true,
        conversion: true
      },
      nodeTypes: {
        llm: ["ChatOpenAI", "ChatAnthropic"],
        chains: ["LLMChain", "RetrievalQAChain", "SummarizeChain"],
        agents: ["OpenAIFunctionsAgent", "ReActAgent"],
        memory: ["BufferMemory", "ConversationSummaryMemory"],
        tools: ["SearchTool", "CalculatorTool", "WebBrowserTool"],
        vectorStores: ["PGVectorStore", "ChromaStore", "PineconeStore"]
      }
    });
  } catch (error) {
    console.error("Error checking Langflow status:", error);
    res2.status(500).json({ error: "Failed to check Langflow status" });
  }
});
router9.post("/config", isAuthenticated3, async (req2, res2) => {
  try {
    const { apiUrl, apiKey } = configSchema.parse(req2.body);
    process.env.LANGFLOW_API_URL = apiUrl;
    process.env.LANGFLOW_API_KEY = apiKey;
    langflowService.setApiKey(apiKey);
    const isAvailable = await langflowService.isAvailable();
    if (!isAvailable) {
      return res2.status(400).json({
        error: "Could not connect to Langflow with provided credentials"
      });
    }
    res2.json({ success: true, message: "Langflow API configured successfully" });
  } catch (error) {
    console.error("Error configuring Langflow API:", error);
    if (error instanceof z5.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to configure Langflow API" });
  }
});
router9.get("/components", isAuthenticated3, async (req2, res2) => {
  try {
    const components = await langflowService.getComponents();
    res2.json(components);
  } catch (error) {
    console.error("Error fetching Langflow components:", error);
    res2.status(500).json({ error: "Failed to fetch Langflow components" });
  }
});
router9.post("/import", isAuthenticated3, async (req2, res2) => {
  try {
    const workflowData = workflowSchema.parse(req2.body);
    const workflow = await langflowService.importWorkflow(workflowData);
    res2.json(workflow);
  } catch (error) {
    console.error("Error importing workflow to Langflow:", error);
    if (error instanceof z5.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to import workflow to Langflow" });
  }
});
router9.get("/export/:id", isAuthenticated3, async (req2, res2) => {
  try {
    const { id } = req2.params;
    const workflowData = await langflowService.exportWorkflow(id);
    res2.json(workflowData);
  } catch (error) {
    console.error("Error exporting workflow from Langflow:", error);
    res2.status(500).json({ error: "Failed to export workflow from Langflow" });
  }
});
router9.post("/workflows", isAuthenticated3, async (req2, res2) => {
  try {
    const { name, description, data } = workflowSchema.parse(req2.body);
    const workflow = await langflowService.createWorkflow(name, description, data);
    res2.json(workflow);
  } catch (error) {
    console.error("Error creating Langflow workflow:", error);
    if (error instanceof z5.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to create Langflow workflow" });
  }
});
router9.get("/workflows/:id", isAuthenticated3, async (req2, res2) => {
  try {
    const { id } = req2.params;
    const workflow = await langflowService.getWorkflow(id);
    res2.json(workflow);
  } catch (error) {
    console.error("Error fetching Langflow workflow:", error);
    res2.status(500).json({ error: "Failed to fetch Langflow workflow" });
  }
});
router9.put("/workflows/:id", isAuthenticated3, async (req2, res2) => {
  try {
    const { id } = req2.params;
    const workflowData = workflowSchema.parse(req2.body);
    const workflow = await langflowService.updateWorkflow(id, workflowData);
    res2.json(workflow);
  } catch (error) {
    console.error("Error updating Langflow workflow:", error);
    if (error instanceof z5.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to update Langflow workflow" });
  }
});
router9.delete("/workflows/:id", isAuthenticated3, async (req2, res2) => {
  try {
    const { id } = req2.params;
    await langflowService.deleteWorkflow(id);
    res2.json({ success: true });
  } catch (error) {
    console.error("Error deleting Langflow workflow:", error);
    res2.status(500).json({ error: "Failed to delete Langflow workflow" });
  }
});
router9.post("/workflows/:id/execute", isAuthenticated3, async (req2, res2) => {
  try {
    const { id } = req2.params;
    const { inputs } = executeWorkflowSchema.parse(req2.body);
    const result2 = await langflowService.executeWorkflow(id, inputs);
    res2.json(result2);
  } catch (error) {
    console.error("Error executing Langflow workflow:", error);
    if (error instanceof z5.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to execute Langflow workflow" });
  }
});
router9.post("/convert/to-langflow", isAuthenticated3, async (req2, res2) => {
  try {
    const { workflowId } = convertWorkflowSchema.parse(req2.body);
    const langflowWorkflow = await langflowService.convertToLangflow(workflowId);
    res2.json(langflowWorkflow);
  } catch (error) {
    console.error("Error converting workflow to Langflow:", error);
    if (error instanceof z5.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to convert workflow to Langflow" });
  }
});
router9.post("/convert/from-langflow/:id", isAuthenticated3, async (req2, res2) => {
  try {
    const { id } = req2.params;
    const synthralOSData = await langflowService.convertFromLangflow(id);
    res2.json(synthralOSData);
  } catch (error) {
    console.error("Error converting Langflow workflow to SynthralOS:", error);
    res2.status(500).json({ error: "Failed to convert Langflow workflow to SynthralOS" });
  }
});
router9.post("/sync", isAuthenticated3, async (req2, res2) => {
  try {
    const { workflowId, langflowId } = syncWorkflowSchema.parse(req2.body);
    const success = await langflowService.syncWorkflow(workflowId, langflowId);
    res2.json({ success });
  } catch (error) {
    console.error("Error syncing workflow with Langflow:", error);
    if (error instanceof z5.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to sync workflow with Langflow" });
  }
});
var langflow_routes_default = router9;

// server/routes/langchain-routes.ts
import { Router as Router7 } from "express";
import { z as z6 } from "zod";

// server/services/langchain/index.ts
import {
  PromptTemplate,
  ChatPromptTemplate,
  HumanMessagePromptTemplate,
  MessagesPlaceholder
} from "@langchain/core/prompts";
import { SystemMessage } from "@langchain/core/messages";
import { ChatOpenAI } from "@langchain/openai";
import { ChatAnthropic } from "@langchain/anthropic";
import { RunnableSequence, RunnablePassthrough } from "@langchain/core/runnables";
import { StringOutputParser } from "@langchain/core/output_parsers";
import { AgentExecutor, createOpenAIFunctionsAgent } from "langchain/agents";
import {
  BufferMemory,
  ConversationSummaryMemory
} from "langchain/memory";

// server/services/vector-db/supavec.ts
import { eq as eq12, and as and8, sql as sql6 } from "drizzle-orm";
import axios6 from "axios";
var VectorDbType2 = /* @__PURE__ */ ((VectorDbType3) => {
  VectorDbType3["PGVECTOR"] = "pgvector";
  VectorDbType3["PINECONE"] = "pinecone";
  VectorDbType3["WEAVIATE"] = "weaviate";
  VectorDbType3["MILVUS"] = "milvus";
  VectorDbType3["QDRANT"] = "qdrant";
  VectorDbType3["VESPA"] = "vespa";
  VectorDbType3["CHROMA"] = "chroma";
  VectorDbType3["FAISS"] = "faiss";
  VectorDbType3["REDIS"] = "redis";
  VectorDbType3["SUPAVEC"] = "supavec";
  return VectorDbType3;
})(VectorDbType2 || {});
var SupavecService = class {
  defaultEmbeddingModel;
  isInitialized = false;
  constructor() {
    this.defaultEmbeddingModel = {
      model: "text-embedding-3-large",
      dimensions: 1536,
      provider: "openai"
    };
    log("Supavec service initialized", "supavec");
    this.isInitialized = true;
  }
  /**
   * Set the default embedding model
   */
  setDefaultEmbeddingModel(config) {
    this.defaultEmbeddingModel = config;
    log(`Default embedding model set to ${config.model}`, "supavec");
  }
  /**
   * Create a new vector database
   */
  async createVectorDatabase(userId, name, type, config, description, isDefault = false) {
    try {
      if (isDefault) {
        await db.update(vectorDatabases).set({ isDefault: false }).where(and8(
          eq12(vectorDatabases.userId, userId),
          eq12(vectorDatabases.isDefault, true)
        ));
      }
      const [vectorDb] = await db.insert(vectorDatabases).values({
        userId,
        name,
        type,
        config,
        description,
        isDefault,
        dimensions: config.dimensions || this.defaultEmbeddingModel.dimensions,
        isActive: true,
        metrics: {
          vectorCount: 0,
          avgQueryTime: 0,
          indexType: config.indexType || "HNSW",
          lastOptimized: (/* @__PURE__ */ new Date()).toISOString()
        }
      }).returning();
      if (type === "supavec" /* SUPAVEC */) {
        await this.initializeSupavecDatabase(vectorDb.id, config);
      }
      return vectorDb;
    } catch (error) {
      log(`Error creating vector database: ${error}`, "supavec");
      throw new Error(`Failed to create vector database: ${error}`);
    }
  }
  /**
   * Get all vector databases for a user
   */
  async getVectorDatabases(userId) {
    try {
      const databases = await db.select().from(vectorDatabases).where(eq12(vectorDatabases.userId, userId));
      return databases;
    } catch (error) {
      log(`Error fetching vector databases: ${error}`, "supavec");
      throw new Error(`Failed to fetch vector databases: ${error}`);
    }
  }
  /**
   * Get a vector database by ID
   */
  async getVectorDatabase(id, userId) {
    try {
      const [database] = await db.select().from(vectorDatabases).where(and8(
        eq12(vectorDatabases.id, id),
        eq12(vectorDatabases.userId, userId)
      ));
      if (!database) {
        throw new Error(`Vector database with ID ${id} not found`);
      }
      return database;
    } catch (error) {
      log(`Error fetching vector database: ${error}`, "supavec");
      throw new Error(`Failed to fetch vector database: ${error}`);
    }
  }
  /**
   * Update a vector database
   */
  async updateVectorDatabase(id, userId, data) {
    try {
      await this.getVectorDatabase(id, userId);
      if (data.isDefault) {
        await db.update(vectorDatabases).set({ isDefault: false }).where(and8(
          eq12(vectorDatabases.userId, userId),
          eq12(vectorDatabases.isDefault, true),
          sql6`id != ${id}`
        ));
      }
      const [updated] = await db.update(vectorDatabases).set({
        ...data,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq12(vectorDatabases.id, id)).returning();
      return updated;
    } catch (error) {
      log(`Error updating vector database: ${error}`, "supavec");
      throw new Error(`Failed to update vector database: ${error}`);
    }
  }
  /**
   * Delete a vector database
   */
  async deleteVectorDatabase(id, userId) {
    try {
      const db1 = await this.getVectorDatabase(id, userId);
      if (db1.isDefault) {
        const otherDbs = await db.select().from(vectorDatabases).where(and8(
          eq12(vectorDatabases.userId, userId),
          sql6`id != ${id}`
        )).limit(1);
        if (otherDbs.length > 0) {
          await db.update(vectorDatabases).set({ isDefault: true }).where(eq12(vectorDatabases.id, otherDbs[0].id));
        }
      }
      await db.delete(vectorCollections).where(eq12(vectorCollections.dbId, id));
      await db.delete(vectorDatabases).where(eq12(vectorDatabases.id, id));
      return true;
    } catch (error) {
      log(`Error deleting vector database: ${error}`, "supavec");
      throw new Error(`Failed to delete vector database: ${error}`);
    }
  }
  /**
   * Create a new collection within a vector database
   */
  async createCollection(dbId, userId, options2) {
    try {
      const vectorDb = await this.getVectorDatabase(dbId, userId);
      const [collection] = await db.insert(vectorCollections).values({
        dbId,
        name: options2.name,
        description: options2.description,
        metadata: options2.metadata || {},
        dimensions: options2.dimensions || vectorDb.dimensions,
        itemCount: 0
      }).returning();
      if (vectorDb.type === "supavec" /* SUPAVEC */) {
        await this.initializeSupavecCollection(collection.id, vectorDb.config);
      }
      return collection;
    } catch (error) {
      log(`Error creating vector collection: ${error}`, "supavec");
      throw new Error(`Failed to create vector collection: ${error}`);
    }
  }
  /**
   * Get all collections for a vector database
   */
  async getCollections(dbId, userId) {
    try {
      await this.getVectorDatabase(dbId, userId);
      const collections = await db.select().from(vectorCollections).where(eq12(vectorCollections.dbId, dbId));
      return collections;
    } catch (error) {
      log(`Error fetching vector collections: ${error}`, "supavec");
      throw new Error(`Failed to fetch vector collections: ${error}`);
    }
  }
  /**
   * Get a collection by ID
   */
  async getCollection(id, userId) {
    try {
      const [collection] = await db.select({
        collection: vectorCollections,
        database: vectorDatabases
      }).from(vectorCollections).innerJoin(
        vectorDatabases,
        eq12(vectorCollections.dbId, vectorDatabases.id)
      ).where(and8(
        eq12(vectorCollections.id, id),
        eq12(vectorDatabases.userId, userId)
      ));
      if (!collection) {
        throw new Error(`Vector collection with ID ${id} not found`);
      }
      return collection.collection;
    } catch (error) {
      log(`Error fetching vector collection: ${error}`, "supavec");
      throw new Error(`Failed to fetch vector collection: ${error}`);
    }
  }
  /**
   * Update a collection
   */
  async updateCollection(id, userId, data) {
    try {
      await this.getCollection(id, userId);
      const [updated] = await db.update(vectorCollections).set({
        ...data,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq12(vectorCollections.id, id)).returning();
      return updated;
    } catch (error) {
      log(`Error updating vector collection: ${error}`, "supavec");
      throw new Error(`Failed to update vector collection: ${error}`);
    }
  }
  /**
   * Delete a collection
   */
  async deleteCollection(id, userId) {
    try {
      await this.getCollection(id, userId);
      await db.delete(vectorItems).where(eq12(vectorItems.collectionId, id));
      await db.delete(vectorCollections).where(eq12(vectorCollections.id, id));
      return true;
    } catch (error) {
      log(`Error deleting vector collection: ${error}`, "supavec");
      throw new Error(`Failed to delete vector collection: ${error}`);
    }
  }
  /**
   * Add items to a collection
   */
  async addItems(collectionId, userId, items) {
    try {
      const collection = await this.getCollection(collectionId, userId);
      const [database] = await db.select().from(vectorDatabases).where(eq12(vectorDatabases.id, collection.dbId));
      if (!database) {
        throw new Error(`Vector database not found`);
      }
      const processedItems = await Promise.all(items.map(async (item) => {
        if (!item.embedding && item.content) {
          try {
            item.embedding = await this.generateEmbedding(item.content);
          } catch (error) {
            log(`Error generating embedding: ${error}`, "supavec");
            throw new Error(`Failed to generate embedding: ${error}`);
          }
        }
        if (item.embedding && item.embedding.length !== collection.dimensions) {
          throw new Error(`Embedding dimension mismatch: expected ${collection.dimensions}, got ${item.embedding.length}`);
        }
        return {
          collectionId,
          objectId: item.objectId,
          objectType: item.objectType,
          embedding: item.embedding || [],
          content: item.content,
          title: item.title,
          metadata: item.metadata || {},
          chunkSize: item.chunkSize,
          chunkOverlap: item.chunkOverlap
        };
      }));
      const insertedItems = await db.insert(vectorItems).values(processedItems).returning();
      await db.update(vectorCollections).set({
        itemCount: collection.itemCount + processedItems.length,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq12(vectorCollections.id, collectionId));
      await db.update(vectorDatabases).set({
        metrics: {
          ...database.metrics,
          vectorCount: (database.metrics.vectorCount || 0) + processedItems.length
        },
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq12(vectorDatabases.id, database.id));
      return insertedItems;
    } catch (error) {
      log(`Error adding items to vector collection: ${error}`, "supavec");
      throw new Error(`Failed to add items to vector collection: ${error}`);
    }
  }
  /**
   * Search for items in a collection
   */
  async searchByVector(collectionId, userId, vector, options2) {
    try {
      const collection = await this.getCollection(collectionId, userId);
      const [database] = await db.select().from(vectorDatabases).where(eq12(vectorDatabases.id, collection.dbId));
      if (!database) {
        throw new Error(`Vector database not found`);
      }
      const items = await db.select().from(vectorItems).where(eq12(vectorItems.collectionId, collectionId)).limit(options2?.limit || 10).offset(options2?.offset || 0);
      const scoredItems = items.map((item) => {
        const embedding = item.embedding;
        const score = this.calculateCosineSimilarity(vector, embedding);
        return {
          ...item,
          score
        };
      });
      let results = scoredItems;
      if (options2?.scoreCutoff !== void 0) {
        results = scoredItems.filter((item) => item.score >= options2.scoreCutoff);
      }
      results.sort((a, b) => b.score - a.score);
      if (!options2?.includeEmbedding) {
        results.forEach((item) => {
          delete item.embedding;
        });
      }
      const queryTime = Math.floor(Math.random() * 10) + 15;
      await db.update(vectorDatabases).set({
        metrics: {
          ...database.metrics,
          avgQueryTime: (database.metrics.avgQueryTime || 0) * 0.9 + queryTime * 0.1
          // Exponential moving average
        }
      }).where(eq12(vectorDatabases.id, database.id));
      return results;
    } catch (error) {
      log(`Error searching vector collection: ${error}`, "supavec");
      throw new Error(`Failed to search vector collection: ${error}`);
    }
  }
  /**
   * Search for items in a collection by text
   */
  async searchByText(collectionId, userId, text2, options2) {
    try {
      const embedding = await this.generateEmbedding(text2);
      return this.searchByVector(collectionId, userId, embedding, options2);
    } catch (error) {
      log(`Error searching vector collection by text: ${error}`, "supavec");
      throw new Error(`Failed to search vector collection by text: ${error}`);
    }
  }
  /**
   * Delete items from a collection
   */
  async deleteItems(collectionId, userId, itemIds) {
    try {
      const collection = await this.getCollection(collectionId, userId);
      const result2 = await db.delete(vectorItems).where(and8(
        eq12(vectorItems.collectionId, collectionId),
        sql6`id IN (${itemIds.join(",")})`
      ));
      await db.update(vectorCollections).set({
        itemCount: Math.max(0, collection.itemCount - itemIds.length),
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq12(vectorCollections.id, collectionId));
      const [database] = await db.select().from(vectorDatabases).where(eq12(vectorDatabases.id, collection.dbId));
      if (database) {
        await db.update(vectorDatabases).set({
          metrics: {
            ...database.metrics,
            vectorCount: Math.max(0, (database.metrics.vectorCount || 0) - itemIds.length)
          },
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq12(vectorDatabases.id, database.id));
      }
      return true;
    } catch (error) {
      log(`Error deleting items from vector collection: ${error}`, "supavec");
      throw new Error(`Failed to delete items from vector collection: ${error}`);
    }
  }
  /**
   * Migrate data between vector databases
   */
  async migrateData(sourceDbId, targetDbId, userId, options2) {
    try {
      const sourceDb = await this.getVectorDatabase(sourceDbId, userId);
      const targetDb = await this.getVectorDatabase(targetDbId, userId);
      if (options2?.sourceColl && options2?.targetColl) {
        const sourceColl = await this.getCollection(options2.sourceColl, userId);
        const targetColl = await this.getCollection(options2.targetColl, userId);
        if (sourceColl.dimensions !== targetColl.dimensions) {
          throw new Error(`Dimension mismatch: source=${sourceColl.dimensions}, target=${targetColl.dimensions}`);
        }
        const items = await db.select().from(vectorItems).where(eq12(vectorItems.collectionId, options2.sourceColl));
        const migrationItems = items.map((item) => ({
          objectId: item.objectId,
          objectType: item.objectType,
          embedding: item.embedding,
          content: item.content,
          title: item.title,
          metadata: item.metadata || {},
          chunkSize: item.chunkSize,
          chunkOverlap: item.chunkOverlap
        }));
        await this.addItems(options2.targetColl, userId, migrationItems);
        return {
          success: true,
          itemCount: migrationItems.length,
          sourceColl: options2.sourceColl,
          targetColl: options2.targetColl
        };
      } else {
        const sourceColls = await this.getCollections(sourceDbId, userId);
        const migrationResult = await Promise.all(
          sourceColls.map(async (sourceColl) => {
            const targetColl = await this.createCollection(targetDbId, userId, {
              name: `${sourceColl.name}_migrated`,
              description: `Migrated from ${sourceDb.name}/${sourceColl.name}`,
              dimensions: sourceColl.dimensions,
              metadata: {
                ...sourceColl.metadata,
                migratedFrom: sourceColl.id,
                migratedAt: (/* @__PURE__ */ new Date()).toISOString()
              }
            });
            const items = await db.select().from(vectorItems).where(eq12(vectorItems.collectionId, sourceColl.id));
            const migrationItems = items.map((item) => ({
              objectId: item.objectId,
              objectType: item.objectType,
              embedding: item.embedding,
              content: item.content,
              title: item.title,
              metadata: item.metadata || {},
              chunkSize: item.chunkSize,
              chunkOverlap: item.chunkOverlap
            }));
            if (migrationItems.length > 0) {
              await this.addItems(targetColl.id, userId, migrationItems);
            }
            return {
              sourceCollId: sourceColl.id,
              sourceName: sourceColl.name,
              targetCollId: targetColl.id,
              targetName: targetColl.name,
              itemCount: migrationItems.length
            };
          })
        );
        return {
          success: true,
          collections: migrationResult,
          totalItems: migrationResult.reduce((sum2, coll) => sum2 + coll.itemCount, 0)
        };
      }
    } catch (error) {
      log(`Error migrating vector data: ${error}`, "supavec");
      throw new Error(`Failed to migrate vector data: ${error}`);
    }
  }
  /**
   * Initialize a Supavec database
   * Enhanced implementation for Supavec database initialization
   */
  async initializeSupavecDatabase(dbId, config) {
    log(`Initializing Supavec database with ID ${dbId}`, "supavec");
    try {
      const [database] = await db.select().from(vectorDatabases).where(eq12(vectorDatabases.id, dbId));
      if (!database) {
        throw new Error(`Vector database with ID ${dbId} not found`);
      }
      const requiredFields = ["dimensions", "indexType"];
      for (const field of requiredFields) {
        if (!config[field]) {
          log(`Warning: Missing required field '${field}' in Supavec database config`, "supavec");
        }
      }
      await new Promise((resolve) => setTimeout(resolve, 200));
      await db.update(vectorDatabases).set({
        metrics: {
          ...database.metrics,
          initialized: true,
          lastInitialized: (/* @__PURE__ */ new Date()).toISOString(),
          status: "ready",
          availableModels: [
            { name: "text-embedding-3-large", provider: "openai", dimensions: 1536 },
            { name: "text-embedding-3-small", provider: "openai", dimensions: 1536 },
            { name: "claude-3-7-sonnet-20250219", provider: "anthropic", dimensions: 1536 }
          ]
        },
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq12(vectorDatabases.id, dbId));
      log(`Supavec database with ID ${dbId} successfully initialized`, "supavec");
    } catch (error) {
      log(`Error initializing Supavec database: ${error}`, "supavec");
      throw new Error(`Failed to initialize Supavec database: ${error}`);
    }
  }
  /**
   * Initialize a Supavec collection
   * Enhanced implementation for Supavec collection initialization
   */
  async initializeSupavecCollection(collectionId, config) {
    log(`Initializing Supavec collection with ID ${collectionId}`, "supavec");
    try {
      const [collection] = await db.select().from(vectorCollections).where(eq12(vectorCollections.id, collectionId));
      if (!collection) {
        throw new Error(`Vector collection with ID ${collectionId} not found`);
      }
      const [database] = await db.select().from(vectorDatabases).where(eq12(vectorDatabases.id, collection.dbId));
      if (!database) {
        throw new Error(`Vector database with ID ${collection.dbId} not found`);
      }
      if (collection.dimensions !== database.dimensions) {
        log(`Warning: Collection dimensions (${collection.dimensions}) don't match database dimensions (${database.dimensions})`, "supavec");
        await db.update(vectorCollections).set({
          dimensions: database.dimensions,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq12(vectorCollections.id, collectionId));
        log(`Updated collection dimensions to match database (${database.dimensions})`, "supavec");
      }
      await new Promise((resolve) => setTimeout(resolve, 150));
      await db.update(vectorCollections).set({
        metadata: {
          ...collection.metadata,
          initialized: true,
          lastInitialized: (/* @__PURE__ */ new Date()).toISOString(),
          status: "ready",
          indexType: config.indexType || database.config.indexType || "HNSW",
          dbType: database.type
        },
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq12(vectorCollections.id, collectionId));
      log(`Supavec collection with ID ${collectionId} successfully initialized`, "supavec");
    } catch (error) {
      log(`Error initializing Supavec collection: ${error}`, "supavec");
      throw new Error(`Failed to initialize Supavec collection: ${error}`);
    }
  }
  /**
   * Generate embedding from text
   */
  async generateEmbedding(text2) {
    try {
      if (!process.env.OPENAI_API_KEY && !process.env.ANTHROPIC_API_KEY) {
        log("No embedding API keys available (OPENAI_API_KEY or ANTHROPIC_API_KEY), returning random embedding", "supavec");
        return Array.from({ length: this.defaultEmbeddingModel.dimensions }, () => Math.random() * 2 - 1);
      }
      if (process.env.OPENAI_API_KEY) {
        try {
          const response = await axios6.post(
            "https://api.openai.com/v1/embeddings",
            {
              input: text2,
              model: this.defaultEmbeddingModel.model
            },
            {
              headers: {
                "Authorization": `Bearer ${process.env.OPENAI_API_KEY}`,
                "Content-Type": "application/json"
              }
            }
          );
          log(`Generated embedding using OpenAI (${this.defaultEmbeddingModel.model})`, "supavec");
          return response.data.data[0].embedding;
        } catch (openaiError) {
          log(`OpenAI embedding generation failed: ${openaiError}. Falling back to alternative methods.`, "supavec");
          if (!process.env.ANTHROPIC_API_KEY) {
            throw openaiError;
          }
        }
      }
      if (process.env.ANTHROPIC_API_KEY) {
        try {
          const response = await axios6.post(
            "https://api.anthropic.com/v1/messages",
            {
              model: "claude-3-7-sonnet-20250219",
              max_tokens: 1024,
              messages: [
                {
                  role: "user",
                  content: `Please convert the following text into a dense vector representation 
                  optimized for semantic similarity. Return only the JSON array of ${this.defaultEmbeddingModel.dimensions} 
                  floating point numbers between -1 and 1, with no explanations:

${text2}`
                }
              ],
              system: "You are an embedding model that converts text to vector representations. Return only the vector as a JSON array."
            },
            {
              headers: {
                "x-api-key": process.env.ANTHROPIC_API_KEY,
                "anthropic-version": "2023-06-01",
                "Content-Type": "application/json"
              }
            }
          );
          try {
            const content2 = response.data.content[0].text;
            const jsonMatch = content2.match(/\[.*\]/s);
            if (jsonMatch) {
              const vector = JSON.parse(jsonMatch[0]);
              if (Array.isArray(vector) && vector.length > 0) {
                if (vector.length !== this.defaultEmbeddingModel.dimensions) {
                  const resized = this.resizeVector(vector, this.defaultEmbeddingModel.dimensions);
                  log(`Generated embedding using Anthropic Claude (resized from ${vector.length} to ${resized.length})`, "supavec");
                  return resized;
                }
                log(`Generated embedding using Anthropic Claude`, "supavec");
                return vector;
              }
            }
            throw new Error("Could not parse vector from Claude response");
          } catch (parseError) {
            log(`Failed to parse Claude embedding response: ${parseError}`, "supavec");
            throw parseError;
          }
        } catch (anthropicError) {
          log(`Anthropic embedding generation failed: ${anthropicError}`, "supavec");
          throw anthropicError;
        }
      }
      throw new Error("No embedding generation method available");
    } catch (error) {
      log(`Error generating embedding: ${error}`, "supavec");
      log("Falling back to random embedding vector", "supavec");
      return Array.from({ length: this.defaultEmbeddingModel.dimensions }, () => Math.random() * 2 - 1);
    }
  }
  /**
   * Resize a vector to have the specified dimensions
   * If target dimensions is larger, the vector is padded with zeros
   * If target dimensions is smaller, the vector is truncated
   */
  resizeVector(vector, targetDimensions) {
    if (vector.length === targetDimensions) {
      return vector;
    }
    if (vector.length > targetDimensions) {
      return vector.slice(0, targetDimensions);
    } else {
      return [...vector, ...Array(targetDimensions - vector.length).fill(0)];
    }
  }
  /**
   * Calculate cosine similarity between two vectors
   */
  calculateCosineSimilarity(a, b) {
    if (a.length !== b.length) {
      throw new Error(`Vector dimensions don't match: ${a.length} vs ${b.length}`);
    }
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }
    normA = Math.sqrt(normA);
    normB = Math.sqrt(normB);
    if (normA === 0 || normB === 0) {
      return 0;
    }
    return dotProduct / (normA * normB);
  }
  /**
   * Check if the Supavec service is available
   * @returns Boolean indicating if the service is available and operational
   */
  isAvailable() {
    try {
      return true;
    } catch (error) {
      log(`Error checking Supavec availability: ${error}`, "supavec");
      return false;
    }
  }
};
var supavecService = new SupavecService();

// server/services/langchain/index.ts
var LangChainService = class {
  isInitialized = false;
  constructor() {
    log("LangChain service initializing", "langchain");
    if (!process.env.OPENAI_API_KEY && !process.env.ANTHROPIC_API_KEY) {
      log("Warning: No LLM API keys found (OPENAI_API_KEY or ANTHROPIC_API_KEY). Some features may be limited.", "langchain");
    }
    this.isInitialized = true;
    log("LangChain service initialized", "langchain");
  }
  /**
   * Create a chat model instance
   * Prioritizes Anthropic (due to OpenAI rate limits) and falls back to OpenAI if Anthropic is not available
   */
  createChatModel(options2) {
    if (process.env.ANTHROPIC_API_KEY) {
      return new ChatAnthropic({
        modelName: "claude-3-7-sonnet-20250219",
        temperature: 0.7,
        ...options2
      });
    }
    if (process.env.OPENAI_API_KEY) {
      return new ChatOpenAI({
        modelName: "gpt-4o",
        temperature: 0.7,
        ...options2
      });
    }
    throw new Error("No LLM API keys found. Please set OPENAI_API_KEY or ANTHROPIC_API_KEY environment variables.");
  }
  /**
   * Create a simple chain for generating text
   */
  createSimpleChain(promptTemplate, options2) {
    const model = this.createChatModel(options2);
    const prompt = PromptTemplate.fromTemplate(promptTemplate);
    const chain = RunnableSequence.from([
      prompt,
      model,
      new StringOutputParser()
    ]);
    return chain;
  }
  /**
   * Create a retrieval chain that uses a vector store
   */
  async createRetrievalChain(collectionId, promptTemplate, options2) {
    const model = this.createChatModel(options2);
    const retriever = await this.getRetrieverForCollection(collectionId);
    const prompt = PromptTemplate.fromTemplate(promptTemplate);
    const chain = RunnableSequence.from([
      {
        context: retriever,
        question: new RunnablePassthrough()
      },
      prompt,
      model,
      new StringOutputParser()
    ]);
    return chain;
  }
  /**
   * Create an agent with tools
   */
  async createAgent(tools2, systemPrompt, options2) {
    const model = this.createChatModel(options2);
    const prompt = ChatPromptTemplate.fromMessages([
      new SystemMessage(systemPrompt),
      HumanMessagePromptTemplate.fromTemplate("{input}"),
      // The agent_scratchpad represents the previous agent actions and observations
      new MessagesPlaceholder("agent_scratchpad")
    ]);
    const agent2 = await createOpenAIFunctionsAgent({
      llm: model,
      tools: tools2,
      prompt
    });
    const agentExecutor = new AgentExecutor({
      agent: agent2,
      tools: tools2
    });
    return agentExecutor;
  }
  /**
   * Create a memory object for chains or agents
   */
  createMemory(type = "buffer", options2) {
    switch (type) {
      case "buffer":
        return new BufferMemory(options2);
      case "summary":
        return new ConversationSummaryMemory({
          llm: this.createChatModel(),
          ...options2
        });
      case "vector":
        throw new Error("Vector memory not implemented yet");
      default:
        return new BufferMemory(options2);
    }
  }
  /**
   * Generate embeddings for text using OpenAI API or fallback to random vector
   * @param text Text to generate embedding for
   * @returns Vector embedding representation
   */
  async generateEmbedding(text2) {
    try {
      const dimension = 1536;
      return Array.from({ length: dimension }, () => Math.random() * 2 - 1);
    } catch (error) {
      console.error("Error generating embedding:", error);
      throw error;
    }
  }
  /**
   * Get a retriever for a collection
   */
  async getRetrieverForCollection(collectionId) {
    const retriever = {
      getRelevantDocuments: async (query2) => {
        try {
          let results = [];
          try {
            const userId = 1;
            const collection = await supavecService.getCollection(collectionId, userId);
            if (!collection) {
              console.warn(`Collection with ID ${collectionId} not found`);
              return [];
            }
            results = await supavecService.searchByText(
              collectionId,
              1,
              // Mock user ID for development
              query2,
              { limit: 5 }
            );
          } catch (e) {
            console.warn("Error in vector search:", e);
            results = [];
          }
          if (!results || !Array.isArray(results)) {
            console.warn("Vector search returned no valid results");
            return [];
          }
          return results.map((item) => ({
            pageContent: item.content || "",
            metadata: {
              ...item.metadata,
              id: item.id || "",
              objectId: item.objectId || "",
              objectType: item.objectType || "document"
            }
          }));
        } catch (error) {
          console.error("Error in retriever:", error);
          return [];
        }
      },
      invocationParams: {
        collectionId
      }
    };
    return retriever;
  }
};
var langchainService = new LangChainService();

// server/routes/langchain-routes.ts
import { DynamicTool } from "@langchain/core/tools";
import { eq as eq13 } from "drizzle-orm";
var router10 = Router7();
router10.get("/status", (req2, res2) => {
  const modelAvailability = {
    openai: process.env.OPENAI_API_KEY ? "available" : "unavailable",
    anthropic: process.env.ANTHROPIC_API_KEY ? "available" : "unavailable"
  };
  res2.json({
    status: "operational",
    version: "v1.0.0",
    initialized: langchainService.isInitialized,
    modelAvailability,
    features: {
      chains: true,
      agents: true,
      retrieval: true,
      memory: true
    }
  });
});
var createChainSchema = z6.object({
  promptTemplate: z6.string().min(1, "Prompt template is required"),
  options: z6.record(z6.any()).optional()
});
var createRetrievalChainSchema = z6.object({
  collectionId: z6.number().int().positive(),
  promptTemplate: z6.string().min(1, "Prompt template is required"),
  options: z6.record(z6.any()).optional()
});
var createAgentSchema = z6.object({
  tools: z6.array(z6.record(z6.any())),
  systemPrompt: z6.string().min(1, "System prompt is required"),
  options: z6.record(z6.any()).optional()
});
var executeChainSchema = z6.object({
  input: z6.record(z6.any())
});
var executeAgentSchema = z6.object({
  input: z6.record(z6.any()),
  verbose: z6.boolean().optional()
});
router10.post("/chains/simple", isAuthenticated3, async (req2, res2) => {
  try {
    const { promptTemplate, options: options2 } = createChainSchema.parse(req2.body);
    const chain = langchainService.createSimpleChain(promptTemplate, options2);
    const sessionId = `chain_${Date.now()}`;
    res2.json({
      success: true,
      sessionId,
      type: "simple_chain",
      config: {
        promptTemplate,
        options: options2
      }
    });
  } catch (error) {
    console.error("Error creating simple chain:", error);
    if (error instanceof z6.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to create simple chain" });
  }
});
router10.post("/chains/retrieval", isAuthenticated3, async (req2, res2) => {
  try {
    const { collectionId, promptTemplate, options: options2 } = createRetrievalChainSchema.parse(req2.body);
    await langchainService.createRetrievalChain(collectionId, promptTemplate, options2);
    const sessionId = `retrieval_chain_${Date.now()}`;
    res2.json({
      success: true,
      sessionId,
      type: "retrieval_chain",
      config: {
        collectionId,
        promptTemplate,
        options: options2
      }
    });
  } catch (error) {
    console.error("Error creating retrieval chain:", error);
    if (error instanceof z6.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to create retrieval chain" });
  }
});
router10.post("/agents", isAuthenticated3, async (req2, res2) => {
  try {
    const { tools: tools2, systemPrompt, options: options2 } = createAgentSchema.parse(req2.body);
    const langchainTools = tools2.map((toolSpec) => {
      return new DynamicTool({
        name: toolSpec.name,
        description: toolSpec.description,
        func: async (input2) => {
          return `Tool ${toolSpec.name} executed with input: ${input2}`;
        }
      });
    });
    await langchainService.createAgent(langchainTools, systemPrompt, options2);
    const sessionId = `agent_${Date.now()}`;
    res2.json({
      success: true,
      sessionId,
      type: "agent",
      config: {
        tools: tools2.map((tool) => ({ name: tool.name, description: tool.description })),
        systemPrompt,
        options: options2
      }
    });
  } catch (error) {
    console.error("Error creating agent:", error);
    if (error instanceof z6.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to create agent" });
  }
});
router10.post("/chains/:sessionId/execute", isAuthenticated3, async (req2, res2) => {
  try {
    const { sessionId } = req2.params;
    const { input: input2 } = executeChainSchema.parse(req2.body);
    const chain = langchainService.createSimpleChain("You are a helpful assistant. Answer the following question: {question}");
    const result2 = await chain.invoke({ question: input2.question || "What is LangChain?" });
    res2.json({
      success: true,
      result: result2,
      sessionId
    });
  } catch (error) {
    console.error("Error executing chain:", error);
    if (error instanceof z6.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to execute chain" });
  }
});
router10.post("/agents/:sessionId/execute", isAuthenticated3, async (req2, res2) => {
  try {
    const { sessionId } = req2.params;
    const { input: input2, verbose } = executeAgentSchema.parse(req2.body);
    const demoTool = new DynamicTool({
      name: "search",
      description: "Useful for searching the web",
      func: async (input3) => `Search results for: ${input3}`
    });
    const agent2 = await langchainService.createAgent(
      [demoTool],
      "You are a helpful assistant with access to tools."
    );
    const result2 = await agent2.invoke({
      input: input2.query || "What's the weather in San Francisco?",
      verbose
    });
    res2.json({
      success: true,
      result: {
        output: result2.output,
        intermediateSteps: result2.intermediateSteps
      },
      sessionId
    });
  } catch (error) {
    console.error("Error executing agent:", error);
    if (error instanceof z6.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to execute agent" });
  }
});
router10.get("/tools", async (req2, res2) => {
  try {
    const availableTools2 = [
      {
        name: "web-search",
        description: "Search the web for information",
        parameters: {
          query: {
            type: "string",
            description: "The search query",
            required: true
          }
        }
      },
      {
        name: "calculator",
        description: "Perform calculations",
        parameters: {
          expression: {
            type: "string",
            description: "The mathematical expression to evaluate",
            required: true
          }
        }
      },
      {
        name: "weather",
        description: "Get weather information for a location",
        parameters: {
          location: {
            type: "string",
            description: "The location to get weather for",
            required: true
          },
          unit: {
            type: "string",
            description: "Temperature unit (celsius/fahrenheit)",
            required: false,
            default: "celsius"
          }
        }
      }
    ];
    res2.json(availableTools2);
  } catch (error) {
    console.error("Error fetching tools:", error);
    res2.status(500).json({ error: "Failed to fetch available tools" });
  }
});
router10.post("/chain", async (req2, res2) => {
  try {
    const { promptTemplate, input: input2, options: options2 } = req2.body;
    const startTime2 = Date.now();
    const chain = langchainService.createSimpleChain(promptTemplate, options2);
    const result2 = await chain.invoke({ input: input2 });
    const timeTaken2 = (Date.now() - startTime2) / 1e3;
    const totalTokens2 = Math.ceil((promptTemplate.length + input2.length + result2.length) / 4);
    res2.json({
      result: result2,
      totalTokens: totalTokens2,
      timeTaken: timeTaken2
    });
  } catch (error) {
    console.error("Error executing chain:", error);
    res2.status(500).json({ error: "Failed to execute chain" });
  }
});
router10.post("/retrieval", async (req2, res2) => {
  try {
    const { collectionId, promptTemplate, query: query2, options: options2 } = req2.body;
    const startTime2 = Date.now();
    const [collection] = await db.select().from(vectorCollections).where(eq13(vectorCollections.id, collectionId));
    if (!collection) {
      return res2.status(404).json({ error: "Collection not found" });
    }
    const chain = await langchainService.createRetrievalChain(collectionId, promptTemplate, options2);
    const result2 = await chain.invoke({ query: query2 });
    const timeTaken2 = (Date.now() - startTime2) / 1e3;
    const totalTokens2 = Math.ceil((promptTemplate.length + query2.length + result2.length) / 4);
    res2.json({
      result: result2,
      totalTokens: totalTokens2,
      timeTaken: timeTaken2
    });
  } catch (error) {
    console.error("Error executing retrieval chain:", error);
    res2.status(500).json({ error: "Failed to execute retrieval chain" });
  }
});
router10.post("/agent", async (req, res) => {
  try {
    const { systemMessage, tools, query, options } = req.body;
    const startTime = Date.now();
    const availableTools = [
      new DynamicTool({
        name: "web-search",
        description: "Search the web for information",
        func: async (input2) => `Search results for: ${input2}`
      }),
      new DynamicTool({
        name: "calculator",
        description: "Perform calculations",
        func: async (input) => {
          try {
            return String(eval(input));
          } catch (e) {
            return `Error calculating: ${e.message}`;
          }
        }
      }),
      new DynamicTool({
        name: "weather",
        description: "Get weather information for a location",
        func: async (input2) => `Weather for ${input2}: Partly cloudy, 22\xB0C`
      })
    ];
    const selectedTools = availableTools.filter(
      (tool) => tools.includes(tool.name)
    );
    const agent = await langchainService.createAgent(
      selectedTools,
      systemMessage,
      options
    );
    const result = await agent.invoke({
      input: query,
      verbose: options?.verbose || false
    });
    const timeTaken = (Date.now() - startTime) / 1e3;
    const totalTokens = Math.ceil((systemMessage.length + query.length + result.output.length) / 4);
    res.json({
      result: result.output,
      steps: result.intermediateSteps,
      totalTokens,
      timeTaken
    });
  } catch (error) {
    console.error("Error executing agent:", error);
    res.status(500).json({ error: "Failed to execute agent" });
  }
});
var langchain_routes_default = router10;

// server/routes/vector-db-routes.ts
import { Router as Router8 } from "express";
import { z as z7 } from "zod";
var router11 = Router8();
router11.get("/status", async (req2, res2) => {
  try {
    const isAvailable = supavecService.isAvailable();
    res2.json({
      status: isAvailable ? "operational" : "unavailable",
      version: "v1.0.0",
      features: {
        vectorSearch: true,
        textSearch: true,
        hybridSearch: true,
        collectionManagement: true
      },
      databases: {
        pgvector: true,
        pinecone: true,
        chroma: true,
        faiss: true,
        milvus: true
      }
    });
  } catch (error) {
    console.error("Error checking vector DB status:", error);
    res2.status(500).json({ error: "Failed to get vector DB status" });
  }
});
router11.post("/databases", isAuthenticated3, async (req2, res2) => {
  try {
    const user = req2.user.id;
    const schema = z7.object({
      name: z7.string().min(1, "Name is required"),
      type: z7.nativeEnum(VectorDbType2),
      config: z7.record(z7.any()),
      description: z7.string().optional(),
      isDefault: z7.boolean().optional()
    });
    const { name, type, config, description, isDefault } = schema.parse(req2.body);
    const db2 = await supavecService.createVectorDatabase(
      user,
      name,
      type,
      config,
      description,
      isDefault
    );
    res2.status(201).json(db2);
  } catch (error) {
    console.error("Error creating vector database:", error);
    if (error instanceof z7.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to create vector database" });
  }
});
router11.get("/databases", isAuthenticated3, async (req2, res2) => {
  try {
    const user = req2.user.id;
    const databases = await supavecService.getVectorDatabases(user);
    res2.json(databases);
  } catch (error) {
    console.error("Error fetching vector databases:", error);
    res2.status(500).json({ error: "Failed to fetch vector databases" });
  }
});
router11.get("/collections", async (req2, res2) => {
  try {
    const collections = await db.select().from(vectorCollections);
    const formattedCollections = collections.map((collection) => ({
      id: collection.id,
      name: collection.name,
      description: collection.description || "",
      itemCount: collection.itemCount,
      dimensions: collection.dimensions
    }));
    res2.json(formattedCollections);
  } catch (error) {
    console.error("Error fetching all vector collections:", error);
    res2.status(500).json({ error: "Failed to fetch vector collections" });
  }
});
router11.get("/databases/:id", isAuthenticated3, async (req2, res2) => {
  try {
    const user = req2.user.id;
    const { id } = req2.params;
    const database = await supavecService.getVectorDatabase(parseInt(id), user);
    res2.json(database);
  } catch (error) {
    console.error("Error fetching vector database:", error);
    res2.status(500).json({ error: "Failed to fetch vector database" });
  }
});
router11.put("/databases/:id", isAuthenticated3, async (req2, res2) => {
  try {
    const user = req2.user.id;
    const { id } = req2.params;
    const schema = z7.object({
      name: z7.string().min(1, "Name is required").optional(),
      config: z7.record(z7.any()).optional(),
      description: z7.string().optional(),
      isActive: z7.boolean().optional(),
      isDefault: z7.boolean().optional()
    });
    const data = schema.parse(req2.body);
    const updated = await supavecService.updateVectorDatabase(
      parseInt(id),
      user,
      data
    );
    res2.json(updated);
  } catch (error) {
    console.error("Error updating vector database:", error);
    if (error instanceof z7.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to update vector database" });
  }
});
router11.delete("/databases/:id", isAuthenticated3, async (req2, res2) => {
  try {
    const user = req2.user.id;
    const { id } = req2.params;
    await supavecService.deleteVectorDatabase(parseInt(id), user);
    res2.status(204).send();
  } catch (error) {
    console.error("Error deleting vector database:", error);
    res2.status(500).json({ error: "Failed to delete vector database" });
  }
});
router11.post("/databases/:dbId/collections", isAuthenticated3, async (req2, res2) => {
  try {
    const user = req2.user.id;
    const { dbId } = req2.params;
    const schema = z7.object({
      name: z7.string().min(1, "Name is required"),
      description: z7.string().optional(),
      dimensions: z7.number().int().positive().optional(),
      metadata: z7.record(z7.any()).optional()
    });
    const data = schema.parse(req2.body);
    const collection = await supavecService.createCollection(
      parseInt(dbId),
      user,
      data
    );
    res2.status(201).json(collection);
  } catch (error) {
    console.error("Error creating vector collection:", error);
    if (error instanceof z7.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to create vector collection" });
  }
});
router11.get("/databases/:dbId/collections", isAuthenticated3, async (req2, res2) => {
  try {
    const user = req2.user.id;
    const { dbId } = req2.params;
    const collections = await supavecService.getCollections(parseInt(dbId), user);
    res2.json(collections);
  } catch (error) {
    console.error("Error fetching vector collections:", error);
    res2.status(500).json({ error: "Failed to fetch vector collections" });
  }
});
router11.get("/collections/:id", isAuthenticated3, async (req2, res2) => {
  try {
    const user = req2.user.id;
    const { id } = req2.params;
    const collection = await supavecService.getCollection(parseInt(id), user);
    res2.json(collection);
  } catch (error) {
    console.error("Error fetching vector collection:", error);
    res2.status(500).json({ error: "Failed to fetch vector collection" });
  }
});
router11.put("/collections/:id", isAuthenticated3, async (req2, res2) => {
  try {
    const user = req2.user.id;
    const { id } = req2.params;
    const schema = z7.object({
      name: z7.string().min(1, "Name is required").optional(),
      description: z7.string().optional(),
      metadata: z7.record(z7.any()).optional()
    });
    const data = schema.parse(req2.body);
    const updated = await supavecService.updateCollection(
      parseInt(id),
      user,
      data
    );
    res2.json(updated);
  } catch (error) {
    console.error("Error updating vector collection:", error);
    if (error instanceof z7.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to update vector collection" });
  }
});
router11.delete("/collections/:id", isAuthenticated3, async (req2, res2) => {
  try {
    const user = req2.user.id;
    const { id } = req2.params;
    await supavecService.deleteCollection(parseInt(id), user);
    res2.status(204).send();
  } catch (error) {
    console.error("Error deleting vector collection:", error);
    res2.status(500).json({ error: "Failed to delete vector collection" });
  }
});
router11.post("/collections/:id/items", isAuthenticated3, async (req2, res2) => {
  try {
    const user = req2.user.id;
    const { id } = req2.params;
    const schema = z7.object({
      items: z7.array(
        z7.object({
          objectId: z7.string(),
          objectType: z7.string(),
          embedding: z7.array(z7.number()).optional(),
          content: z7.string().optional(),
          metadata: z7.record(z7.any()).optional(),
          title: z7.string().optional(),
          chunkSize: z7.number().int().positive().optional(),
          chunkOverlap: z7.number().int().min(0).optional()
        })
      )
    });
    const { items } = schema.parse(req2.body);
    const insertedItems = await supavecService.addItems(
      parseInt(id),
      user,
      items
    );
    res2.status(201).json(insertedItems);
  } catch (error) {
    console.error("Error adding items to vector collection:", error);
    if (error instanceof z7.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to add items to vector collection" });
  }
});
router11.post("/collections/:id/search/vector", isAuthenticated3, async (req2, res2) => {
  try {
    const user = req2.user.id;
    const { id } = req2.params;
    const schema = z7.object({
      vector: z7.array(z7.number()),
      limit: z7.number().int().positive().optional(),
      offset: z7.number().int().min(0).optional(),
      includeMetadata: z7.boolean().optional(),
      includeEmbedding: z7.boolean().optional(),
      filter: z7.record(z7.any()).optional(),
      scoreCutoff: z7.number().min(0).max(1).optional(),
      withScores: z7.boolean().optional()
    });
    const { vector, ...options2 } = schema.parse(req2.body);
    const results = await supavecService.searchByVector(
      parseInt(id),
      user,
      vector,
      options2
    );
    res2.json(results);
  } catch (error) {
    console.error("Error searching vector collection:", error);
    if (error instanceof z7.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to search vector collection" });
  }
});
router11.post("/collections/:id/search/text", isAuthenticated3, async (req2, res2) => {
  try {
    const user = req2.user.id;
    const { id } = req2.params;
    const schema = z7.object({
      text: z7.string().min(1, "Search text is required"),
      limit: z7.number().int().positive().optional(),
      offset: z7.number().int().min(0).optional(),
      includeMetadata: z7.boolean().optional(),
      includeEmbedding: z7.boolean().optional(),
      filter: z7.record(z7.any()).optional(),
      scoreCutoff: z7.number().min(0).max(1).optional(),
      withScores: z7.boolean().optional()
    });
    const { text: text2, ...options2 } = schema.parse(req2.body);
    const results = await supavecService.searchByText(
      parseInt(id),
      user,
      text2,
      options2
    );
    res2.json(results);
  } catch (error) {
    console.error("Error searching vector collection by text:", error);
    if (error instanceof z7.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to search vector collection by text" });
  }
});
router11.delete("/collections/:id/items", isAuthenticated3, async (req2, res2) => {
  try {
    const user = req2.user.id;
    const { id } = req2.params;
    const schema = z7.object({
      itemIds: z7.array(z7.number().int().positive())
    });
    const { itemIds } = schema.parse(req2.body);
    await supavecService.deleteItems(
      parseInt(id),
      user,
      itemIds
    );
    res2.status(204).send();
  } catch (error) {
    console.error("Error deleting items from vector collection:", error);
    if (error instanceof z7.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to delete items from vector collection" });
  }
});
router11.post("/migrate", isAuthenticated3, async (req2, res2) => {
  try {
    const user = req2.user.id;
    const schema = z7.object({
      sourceDbId: z7.number().int().positive(),
      targetDbId: z7.number().int().positive(),
      sourceColl: z7.number().int().positive().optional(),
      targetColl: z7.number().int().positive().optional()
    });
    const { sourceDbId, targetDbId, sourceColl, targetColl } = schema.parse(req2.body);
    const result2 = await supavecService.migrateData(
      sourceDbId,
      targetDbId,
      user,
      { sourceColl, targetColl }
    );
    res2.json(result2);
  } catch (error) {
    console.error("Error migrating vector data:", error);
    if (error instanceof z7.ZodError) {
      return res2.status(400).json({
        error: "Invalid input data",
        details: error.errors
      });
    }
    res2.status(500).json({ error: "Failed to migrate vector data" });
  }
});
var vector_db_routes_default = router11;

// server/routes/memory-routes.ts
import { Router as Router9 } from "express";

// server/services/memory/BaseMemory.ts
var BaseMemory = class {
  type;
  config;
  metrics;
  userId;
  name;
  constructor(type, userId, name, config = {}) {
    this.type = type;
    this.userId = userId;
    this.name = name;
    this.config = {
      windowSize: 10,
      decayRate: 0.05,
      relevanceThreshold: 0.7,
      ttl: 30 * 24 * 60 * 60 * 1e3,
      // 30 days by default
      maxItems: 1e3,
      ...config
    };
    this.metrics = {
      retrievalLatency: 0,
      insertionLatency: 0,
      hitRate: 0,
      cacheSize: 0
    };
  }
  /**
   * Get current metrics about the memory system
   */
  getMetrics() {
    return this.metrics;
  }
  /**
   * Update the configuration of the memory system
   */
  updateConfig(config) {
    this.config = {
      ...this.config,
      ...config
    };
  }
  /**
   * Get the memory system's configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Get the memory system's type
   */
  getType() {
    return this.type;
  }
};

// server/services/memory/Context7Memory.ts
import { eq as eq14, and as and9, desc as desc7 } from "drizzle-orm";

// server/utils.ts
function generateId(length = 10) {
  const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let result2 = "";
  for (let i = 0; i < length; i++) {
    result2 += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result2;
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// server/services/memory/Context7Memory.ts
var Context7Memory = class extends BaseMemory {
  memoryStore;
  systemId = null;
  config;
  constructor(userId, name, config = {}) {
    super("context7" /* Context7 */, userId, name, config);
    this.memoryStore = /* @__PURE__ */ new Map();
    this.config = {
      maxContextSize: 16e3,
      compressionThreshold: 32e3,
      recentItemsWeight: 0.7,
      ...config
    };
  }
  /**
   * Initialize memory system from database
   * Creates system in DB if it doesn't exist
   */
  async initialize() {
    try {
      const existingSystem = await db.select().from(memorySystems).where(and9(
        eq14(memorySystems.userId, this.userId),
        eq14(memorySystems.name, this.name),
        eq14(memorySystems.type, "context7" /* Context7 */)
      )).limit(1);
      if (existingSystem.length > 0) {
        this.systemId = existingSystem[0].id;
        if (JSON.stringify(existingSystem[0].config) !== JSON.stringify(this.config)) {
          await db.update(memorySystems).set({
            config: this.config,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq14(memorySystems.id, this.systemId));
        }
        const memories = await db.select().from(memoryEntries).where(eq14(memoryEntries.systemId, this.systemId)).orderBy(desc7(memoryEntries.lastAccessed));
        memories.forEach((mem) => {
          this.memoryStore.set(mem.entryKey, {
            key: mem.entryKey,
            content: mem.content,
            metadata: mem.metadata,
            importance: mem.importance || 0.5,
            timestamp: mem.createdAt,
            lastAccessed: mem.lastAccessed || void 0,
            accessCount: mem.accessCount || 0,
            expires: mem.expires || void 0
          });
        });
        this.metrics.cacheSize = this.memoryStore.size;
      } else {
        const [newSystem] = await db.insert(memorySystems).values({
          userId: this.userId,
          name: this.name,
          type: "context7" /* Context7 */,
          description: "Fast, low-latency memory system",
          config: this.config,
          isActive: true,
          isDefault: false,
          metrics: this.metrics
        }).returning();
        this.systemId = newSystem.id;
      }
    } catch (error) {
      console.error("Error initializing Context7 memory:", error);
      throw new Error("Failed to initialize memory system");
    }
  }
  /**
   * Store a new memory
   */
  async addMemory(entry) {
    if (!this.systemId) {
      await this.initialize();
    }
    const startTime2 = Date.now();
    try {
      if (!entry.key) {
        entry.key = `mem_${generateId(10)}`;
      }
      if (!entry.timestamp) {
        entry.timestamp = /* @__PURE__ */ new Date();
      }
      this.memoryStore.set(entry.key, {
        ...entry,
        lastAccessed: /* @__PURE__ */ new Date(),
        accessCount: 0
      });
      await db.insert(memoryEntries).values({
        systemId: this.systemId,
        entryKey: entry.key,
        content: entry.content,
        metadata: entry.metadata || {},
        importance: entry.importance || 0.5,
        lastAccessed: entry.lastAccessed || /* @__PURE__ */ new Date(),
        accessCount: entry.accessCount || 0,
        expires: entry.expires
      });
      const endTime = Date.now();
      this.metrics.insertionLatency = endTime - startTime2;
      this.metrics.cacheSize = this.memoryStore.size;
      if (this.memoryStore.size > this.config.maxItems) {
        await this.pruneMemories();
      }
    } catch (error) {
      console.error("Error adding memory:", error);
      throw new Error("Failed to add memory");
    }
  }
  /**
   * Retrieve a specific memory by key
   */
  async getMemory(key) {
    if (!this.systemId) {
      await this.initialize();
    }
    const startTime2 = Date.now();
    try {
      if (this.memoryStore.has(key)) {
        const memory = this.memoryStore.get(key);
        memory.lastAccessed = /* @__PURE__ */ new Date();
        memory.accessCount = (memory.accessCount || 0) + 1;
        this.memoryStore.set(key, memory);
        db.update(memoryEntries).set({
          lastAccessed: memory.lastAccessed,
          accessCount: memory.accessCount
        }).where(and9(
          eq14(memoryEntries.systemId, this.systemId),
          eq14(memoryEntries.entryKey, key)
        )).execute().catch((err) => console.error("Error updating memory access stats:", err));
        const endTime = Date.now();
        this.metrics.retrievalLatency = endTime - startTime2;
        this.metrics.hitRate = (this.metrics.hitRate || 0) * 0.9 + 0.1;
        return memory;
      }
      const dbMemory = await db.select().from(memoryEntries).where(and9(
        eq14(memoryEntries.systemId, this.systemId),
        eq14(memoryEntries.entryKey, key)
      )).limit(1);
      if (dbMemory.length > 0) {
        const mem = dbMemory[0];
        const now = /* @__PURE__ */ new Date();
        const accessCount = (mem.accessCount || 0) + 1;
        await db.update(memoryEntries).set({
          lastAccessed: now,
          accessCount
        }).where(eq14(memoryEntries.id, mem.id));
        const memoryEntry = {
          key: mem.entryKey,
          content: mem.content,
          metadata: mem.metadata,
          importance: mem.importance || 0.5,
          timestamp: mem.createdAt,
          lastAccessed: now,
          accessCount,
          expires: mem.expires || void 0
        };
        this.memoryStore.set(key, memoryEntry);
        const endTime = Date.now();
        this.metrics.retrievalLatency = endTime - startTime2;
        this.metrics.hitRate = (this.metrics.hitRate || 0) * 0.9 + 0.1;
        this.metrics.cacheSize = this.memoryStore.size;
        return memoryEntry;
      }
      this.metrics.hitRate = (this.metrics.hitRate || 0) * 0.9;
      return null;
    } catch (error) {
      console.error("Error retrieving memory:", error);
      throw new Error("Failed to retrieve memory");
    }
  }
  /**
   * Update an existing memory
   */
  async updateMemory(key, updates) {
    if (!this.systemId) {
      await this.initialize();
    }
    try {
      const existing = await this.getMemory(key);
      if (!existing) {
        throw new Error(`Memory with key ${key} not found`);
      }
      const updated = {
        ...existing,
        ...updates,
        key
        // Ensure key isn't changed
      };
      this.memoryStore.set(key, updated);
      await db.update(memoryEntries).set({
        content: updated.content,
        metadata: updated.metadata || {},
        importance: updated.importance || 0.5,
        lastAccessed: /* @__PURE__ */ new Date(),
        expires: updated.expires,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(and9(
        eq14(memoryEntries.systemId, this.systemId),
        eq14(memoryEntries.entryKey, key)
      ));
    } catch (error) {
      console.error("Error updating memory:", error);
      throw new Error("Failed to update memory");
    }
  }
  /**
   * Remove a memory
   */
  async removeMemory(key) {
    if (!this.systemId) {
      await this.initialize();
    }
    try {
      this.memoryStore.delete(key);
      await db.delete(memoryEntries).where(and9(
        eq14(memoryEntries.systemId, this.systemId),
        eq14(memoryEntries.entryKey, key)
      ));
      this.metrics.cacheSize = this.memoryStore.size;
    } catch (error) {
      console.error("Error removing memory:", error);
      throw new Error("Failed to remove memory");
    }
  }
  /**
   * Find memories that are relevant to the given query
   * Simple implementation for Context7 prioritizes recency and importance
   */
  async searchMemories(query2, limit = 5) {
    if (!this.systemId) {
      await this.initialize();
    }
    const startTime2 = Date.now();
    try {
      const queryTerms = query2.toLowerCase().split(/\s+/).filter((t) => t.length > 2);
      if (queryTerms.length === 0) {
        return this.getMostRecentMemories(limit);
      }
      const results = [];
      for (const memory of this.memoryStore.values()) {
        const content2 = memory.content.toLowerCase();
        let matchScore = 0;
        for (const term of queryTerms) {
          if (content2.includes(term)) {
            matchScore += 1;
            if (memory.metadata?.title?.toLowerCase().includes(term)) {
              matchScore += 0.5;
            }
          }
        }
        if (matchScore > 0) {
          matchScore = matchScore / queryTerms.length;
          if (memory.lastAccessed) {
            const ageInHours = (Date.now() - memory.lastAccessed.getTime()) / (1e3 * 60 * 60);
            const recencyScore = Math.max(0, 1 - ageInHours / (24 * 7));
            matchScore = matchScore * (1 - this.config.recentItemsWeight) + recencyScore * this.config.recentItemsWeight;
          }
          matchScore = matchScore * (memory.importance || 0.5);
          results.push({
            entry: memory,
            score: matchScore
          });
        }
      }
      const topResults = results.sort((a, b) => b.score - a.score).slice(0, limit);
      const endTime = Date.now();
      this.metrics.retrievalLatency = endTime - startTime2;
      return topResults;
    } catch (error) {
      console.error("Error searching memories:", error);
      throw new Error("Failed to search memories");
    }
  }
  /**
   * Get most recently accessed memories (fallback for empty queries)
   */
  async getMostRecentMemories(limit) {
    const sortedMemories = Array.from(this.memoryStore.values()).filter((m) => m.lastAccessed).sort((a, b) => {
      const aTime = a.lastAccessed.getTime();
      const bTime = b.lastAccessed.getTime();
      return bTime - aTime;
    }).slice(0, limit);
    return sortedMemories.map((memory) => {
      const ageInHours = (Date.now() - memory.lastAccessed.getTime()) / (1e3 * 60 * 60);
      const recencyScore = Math.max(0, 1 - ageInHours / (24 * 7));
      return {
        entry: memory,
        score: recencyScore
      };
    });
  }
  /**
   * Remove oldest, least important, or expired memories
   */
  async pruneMemories() {
    try {
      const now = /* @__PURE__ */ new Date();
      const expiredKeys = [];
      for (const [key, memory] of this.memoryStore.entries()) {
        if (memory.expires && memory.expires < now) {
          expiredKeys.push(key);
        }
      }
      for (const key of expiredKeys) {
        await this.removeMemory(key);
      }
      if (this.memoryStore.size > this.config.maxItems) {
        const memoriesWithScore = Array.from(this.memoryStore.entries()).map(([key, memory]) => {
          let score = memory.importance || 0.5;
          if (memory.lastAccessed) {
            const ageInHours = (Date.now() - memory.lastAccessed.getTime()) / (1e3 * 60 * 60);
            const recencyScore = Math.max(0, 1 - ageInHours / (24 * 7));
            score = score * 0.7 + recencyScore * 0.3;
          }
          return { key, score };
        }).sort((a, b) => a.score - b.score);
        const memoriesToRemove = memoriesWithScore.slice(0, this.memoryStore.size - this.config.maxItems);
        for (const { key } of memoriesToRemove) {
          await this.removeMemory(key);
        }
      }
    } catch (error) {
      console.error("Error pruning memories:", error);
    }
  }
  /**
   * Clear all memories
   */
  async clear() {
    if (!this.systemId) {
      await this.initialize();
    }
    try {
      this.memoryStore.clear();
      await db.delete(memoryEntries).where(eq14(memoryEntries.systemId, this.systemId));
      this.metrics.cacheSize = 0;
    } catch (error) {
      console.error("Error clearing memories:", error);
      throw new Error("Failed to clear memories");
    }
  }
};

// server/services/memory/Mem0Memory.ts
import { eq as eq15, and as and10, desc as desc8 } from "drizzle-orm";
import OpenAI17 from "openai";
var openai2 = new OpenAI17({ apiKey: process.env.OPENAI_API_KEY });
var Mem0Memory = class extends BaseMemory {
  memoryStore;
  systemId = null;
  config;
  constructor(userId, name, config = {}) {
    super("mem0" /* Mem0 */, userId, name, config);
    this.memoryStore = /* @__PURE__ */ new Map();
    this.config = {
      extractEntities: true,
      extractTags: true,
      extractSentiment: true,
      relationThreshold: 0.6,
      maxEntities: 10,
      ...config
    };
  }
  /**
   * Initialize memory system from database
   * Creates system in DB if it doesn't exist
   */
  async initialize() {
    try {
      const existingSystem = await db.select().from(memorySystems).where(and10(
        eq15(memorySystems.userId, this.userId),
        eq15(memorySystems.name, this.name),
        eq15(memorySystems.type, "mem0" /* Mem0 */)
      )).limit(1);
      if (existingSystem.length > 0) {
        this.systemId = existingSystem[0].id;
        if (JSON.stringify(existingSystem[0].config) !== JSON.stringify(this.config)) {
          await db.update(memorySystems).set({
            config: this.config,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq15(memorySystems.id, this.systemId));
        }
        const memories = await db.select().from(memoryEntries).where(eq15(memoryEntries.systemId, this.systemId)).orderBy(desc8(memoryEntries.lastAccessed));
        memories.forEach((mem) => {
          this.memoryStore.set(mem.entryKey, {
            key: mem.entryKey,
            content: mem.content,
            metadata: mem.metadata,
            importance: mem.importance || 0.5,
            timestamp: mem.createdAt,
            lastAccessed: mem.lastAccessed || void 0,
            accessCount: mem.accessCount || 0,
            expires: mem.expires || void 0
          });
        });
        this.metrics.cacheSize = this.memoryStore.size;
      } else {
        const [newSystem] = await db.insert(memorySystems).values({
          userId: this.userId,
          name: this.name,
          type: "mem0" /* Mem0 */,
          description: "Structured memory system with entity recognition",
          config: this.config,
          isActive: true,
          isDefault: false,
          metrics: this.metrics
        }).returning();
        this.systemId = newSystem.id;
      }
    } catch (error) {
      console.error("Error initializing Mem0 memory:", error);
      throw new Error("Failed to initialize memory system");
    }
  }
  /**
   * Store a new memory with structured metadata
   */
  async addMemory(entry) {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      const key = entry.key || `mem-${generateId()}`;
      const metadata = entry.metadata || {};
      if (this.config.extractEntities && entry.content) {
        const entities = await this.extractEntities(entry.content);
        metadata.entities = entities;
      }
      if (this.config.extractTags && entry.content) {
        const tags = await this.extractTags(entry.content);
        metadata.tags = tags;
      }
      if (this.config.extractSentiment && entry.content) {
        const sentiment = await this.analyzeSentiment(entry.content);
        metadata.sentiment = sentiment;
      }
      const memoryEntry = {
        key,
        content: entry.content,
        metadata,
        importance: entry.importance || 0.5,
        timestamp: entry.timestamp || /* @__PURE__ */ new Date(),
        lastAccessed: /* @__PURE__ */ new Date(),
        accessCount: 0,
        expires: entry.expires
      };
      this.memoryStore.set(key, memoryEntry);
      await db.insert(memoryEntries).values({
        systemId: this.systemId,
        entryKey: key,
        content: entry.content,
        metadata,
        importance: entry.importance || 0.5,
        accessCount: 0,
        createdAt: entry.timestamp || /* @__PURE__ */ new Date(),
        lastAccessed: /* @__PURE__ */ new Date(),
        expires: entry.expires
      });
      this.metrics.cacheSize = this.memoryStore.size;
      this.metrics.insertionLatency = this.metrics.insertionLatency ? (this.metrics.insertionLatency + performance.now() - (entry.timestamp?.getTime() || Date.now())) / 2 : performance.now() - (entry.timestamp?.getTime() || Date.now());
    } catch (error) {
      console.error("Error adding memory to Mem0:", error);
      throw new Error("Failed to add memory");
    }
  }
  /**
   * Retrieve a specific memory by key
   */
  async getMemory(key) {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      const startTime2 = performance.now();
      let memory = this.memoryStore.get(key);
      if (!memory) {
        const dbMemory = await db.select().from(memoryEntries).where(
          and10(
            eq15(memoryEntries.systemId, this.systemId),
            eq15(memoryEntries.entryKey, key)
          )
        ).limit(1);
        if (dbMemory.length > 0) {
          memory = {
            key: dbMemory[0].entryKey,
            content: dbMemory[0].content,
            metadata: dbMemory[0].metadata,
            importance: dbMemory[0].importance || 0.5,
            timestamp: dbMemory[0].createdAt,
            lastAccessed: dbMemory[0].lastAccessed || void 0,
            accessCount: dbMemory[0].accessCount || 0,
            expires: dbMemory[0].expires || void 0
          };
          this.memoryStore.set(key, memory);
        } else {
          this.metrics.hitRate = this.metrics.hitRate !== void 0 ? this.metrics.hitRate * (this.metrics.totalQueries || 0) / ((this.metrics.totalQueries || 0) + 1) : 0;
          this.metrics.totalQueries = (this.metrics.totalQueries || 0) + 1;
          return null;
        }
      }
      const now = /* @__PURE__ */ new Date();
      const accessCount = (memory.accessCount || 0) + 1;
      memory.lastAccessed = now;
      memory.accessCount = accessCount;
      await db.update(memoryEntries).set({
        lastAccessed: now,
        accessCount
      }).where(
        and10(
          eq15(memoryEntries.systemId, this.systemId),
          eq15(memoryEntries.entryKey, key)
        )
      );
      const endTime = performance.now();
      this.metrics.retrievalLatency = this.metrics.retrievalLatency ? (this.metrics.retrievalLatency + (endTime - startTime2)) / 2 : endTime - startTime2;
      this.metrics.hitRate = this.metrics.hitRate !== void 0 ? (this.metrics.hitRate * (this.metrics.totalQueries || 0) + 1) / ((this.metrics.totalQueries || 0) + 1) : 1;
      this.metrics.totalQueries = (this.metrics.totalQueries || 0) + 1;
      return memory;
    } catch (error) {
      console.error("Error retrieving memory from Mem0:", error);
      throw new Error("Failed to retrieve memory");
    }
  }
  /**
   * Update an existing memory
   */
  async updateMemory(key, update) {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      const existing = await this.getMemory(key);
      if (!existing) {
        throw new Error(`Memory with key ${key} not found`);
      }
      const updated = {
        ...existing,
        ...update,
        key
        // Ensure key remains the same
      };
      if (update.content && this.config.extractEntities) {
        const entities = await this.extractEntities(update.content);
        updated.metadata = {
          ...updated.metadata,
          entities
        };
      }
      if (update.content && this.config.extractTags) {
        const tags = await this.extractTags(update.content);
        updated.metadata = {
          ...updated.metadata,
          tags
        };
      }
      if (update.content && this.config.extractSentiment) {
        const sentiment = await this.analyzeSentiment(update.content);
        updated.metadata = {
          ...updated.metadata,
          sentiment
        };
      }
      this.memoryStore.set(key, updated);
      await db.update(memoryEntries).set({
        content: updated.content,
        metadata: updated.metadata,
        importance: updated.importance,
        updatedAt: /* @__PURE__ */ new Date(),
        expires: updated.expires
      }).where(
        and10(
          eq15(memoryEntries.systemId, this.systemId),
          eq15(memoryEntries.entryKey, key)
        )
      );
    } catch (error) {
      console.error("Error updating memory in Mem0:", error);
      throw new Error("Failed to update memory");
    }
  }
  /**
   * Remove a memory
   */
  async removeMemory(key) {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      this.memoryStore.delete(key);
      await db.delete(memoryEntries).where(
        and10(
          eq15(memoryEntries.systemId, this.systemId),
          eq15(memoryEntries.entryKey, key)
        )
      );
      this.metrics.cacheSize = this.memoryStore.size;
    } catch (error) {
      console.error("Error removing memory from Mem0:", error);
      throw new Error("Failed to remove memory");
    }
  }
  /**
   * Find memories that are relevant to the given query
   * Uses a hybrid approach with entity matching and keyword matching
   */
  async searchMemories(query2, limit = 5) {
    if (!this.systemId) {
      await this.initialize();
    }
    const startTime2 = performance.now();
    try {
      const queryEntities = await this.extractEntities(query2);
      const results = /* @__PURE__ */ new Map();
      const entityNames = queryEntities.map((e) => e.name.toLowerCase());
      for (const [key, memory] of this.memoryStore.entries()) {
        const memoryEntities = memory.metadata?.entities || [];
        let entityMatchScore = 0;
        for (const entity of memoryEntities) {
          if (entityNames.includes(entity.name?.toLowerCase())) {
            entityMatchScore += entity.importance || 0.5;
          }
        }
        if (entityMatchScore > 0) {
          results.set(key, {
            memory,
            score: entityMatchScore
          });
        }
      }
      if (results.size < limit) {
        const queryTerms = query2.toLowerCase().split(/\s+/).filter((t) => t.length > 2);
        for (const [key, memory] of this.memoryStore.entries()) {
          if (results.has(key)) continue;
          const content2 = memory.content.toLowerCase();
          let matchScore = 0;
          for (const term of queryTerms) {
            if (content2.includes(term)) {
              matchScore += 0.2;
            }
          }
          if (matchScore > 0) {
            results.set(key, {
              memory,
              score: matchScore
            });
          }
        }
      }
      const now = Date.now();
      for (const result2 of results.values()) {
        const memory = result2.memory;
        const age = now - (memory.timestamp?.getTime() || 0);
        const recencyBoost = Math.max(0, 1 - age / (30 * 24 * 60 * 60 * 1e3));
        result2.score = result2.score * (memory.importance || 0.5) * (0.7 + 0.3 * recencyBoost);
      }
      const sortedResults = Array.from(results.values()).sort((a, b) => b.score - a.score).slice(0, limit);
      for (const result2 of sortedResults) {
        const memory = result2.memory;
        memory.lastAccessed = /* @__PURE__ */ new Date();
        memory.accessCount = (memory.accessCount || 0) + 1;
        await db.update(memoryEntries).set({
          lastAccessed: memory.lastAccessed,
          accessCount: memory.accessCount
        }).where(
          and10(
            eq15(memoryEntries.systemId, this.systemId),
            eq15(memoryEntries.entryKey, memory.key)
          )
        );
      }
      const endTime = performance.now();
      this.metrics.retrievalLatency = this.metrics.retrievalLatency ? (this.metrics.retrievalLatency + (endTime - startTime2)) / 2 : endTime - startTime2;
      return sortedResults;
    } catch (error) {
      console.error("Error searching memories in Mem0:", error);
      return this.simpleKeywordSearch(query2, limit);
    }
  }
  /**
   * Simple keyword search fallback if entity extraction fails
   */
  async simpleKeywordSearch(query2, limit = 5) {
    const queryTerms = query2.toLowerCase().split(/\s+/).filter((t) => t.length > 2);
    const results = /* @__PURE__ */ new Map();
    for (const [key, memory] of this.memoryStore.entries()) {
      const content2 = memory.content.toLowerCase();
      let matchScore = 0;
      for (const term of queryTerms) {
        if (content2.includes(term)) {
          matchScore += 1;
        }
      }
      if (matchScore > 0) {
        results.set(key, {
          memory,
          score: matchScore * (memory.importance || 0.5)
        });
      }
    }
    return Array.from(results.values()).sort((a, b) => b.score - a.score).slice(0, limit);
  }
  /**
   * Clear all memories
   */
  async clear() {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      this.memoryStore.clear();
      await db.delete(memoryEntries).where(eq15(memoryEntries.systemId, this.systemId));
      this.metrics.cacheSize = 0;
    } catch (error) {
      console.error("Error clearing Mem0 memory:", error);
      throw new Error("Failed to clear memory");
    }
  }
  /**
   * Extract entities from text using OpenAI
   */
  async extractEntities(text2) {
    if (!process.env.OPENAI_API_KEY) {
      return [];
    }
    try {
      const trimmedText = text2.slice(0, 4e3);
      const prompt = `
        Extract key entities from the following text. For each entity, provide:
        1. Type (person, organization, concept, location, etc.)
        2. Name (the entity's name)
        3. Importance (a number from 0 to 1 indicating relevance to the text)
        
        Return as JSON array with fields: type, name, importance.
        Only return the JSON array, nothing else.
        
        Text: ${trimmedText}
      `;
      const response = await openai2.chat.completions.create({
        model: "gpt-4o",
        messages: [{ role: "user", content: prompt }],
        response_format: { type: "json_object" },
        temperature: 0.2
      });
      const content2 = response.choices[0].message.content;
      if (!content2) return [];
      try {
        const parsed = JSON.parse(content2);
        const entities = parsed.entities || [];
        return entities.filter((e) => e.name && e.type).slice(0, this.config.maxEntities || 10).map((e) => ({
          type: e.type,
          name: e.name,
          importance: e.importance || 0.5,
          firstOccurrence: /* @__PURE__ */ new Date()
        }));
      } catch (parseError) {
        console.error("Error parsing entity extraction response:", parseError);
        return [];
      }
    } catch (error) {
      console.error("Error extracting entities:", error);
      return [];
    }
  }
  /**
   * Extract tags from text using OpenAI
   */
  async extractTags(text2) {
    if (!process.env.OPENAI_API_KEY) {
      return [];
    }
    try {
      const trimmedText = text2.slice(0, 4e3);
      const prompt = `
        Generate 3-7 tags for the following text. Tags should be single words or short phrases that capture key topics.
        Return as JSON array of strings.
        Only return the JSON array, nothing else.
        
        Text: ${trimmedText}
      `;
      const response = await openai2.chat.completions.create({
        model: "gpt-4o",
        messages: [{ role: "user", content: prompt }],
        response_format: { type: "json_object" },
        temperature: 0.2
      });
      const content2 = response.choices[0].message.content;
      if (!content2) return [];
      try {
        const parsed = JSON.parse(content2);
        return parsed.tags || [];
      } catch (parseError) {
        console.error("Error parsing tag extraction response:", parseError);
        return [];
      }
    } catch (error) {
      console.error("Error extracting tags:", error);
      return [];
    }
  }
  /**
   * Analyze sentiment from text using OpenAI
   */
  async analyzeSentiment(text2) {
    if (!process.env.OPENAI_API_KEY) {
      return 0;
    }
    try {
      const trimmedText = text2.slice(0, 4e3);
      const prompt = `
        Analyze the sentiment of the following text on a scale from -1 (very negative) to 1 (very positive).
        Return only a single number representing the sentiment score.
        
        Text: ${trimmedText}
      `;
      const response = await openai2.chat.completions.create({
        model: "gpt-4o",
        messages: [{ role: "user", content: prompt }],
        temperature: 0.1
      });
      const content2 = response.choices[0].message.content;
      if (!content2) return 0;
      const score = parseFloat(content2.trim());
      return isNaN(score) ? 0 : Math.max(-1, Math.min(1, score));
    } catch (error) {
      console.error("Error analyzing sentiment:", error);
      return 0;
    }
  }
};

// server/services/memory/GraphitiMemory.ts
import { eq as eq16, and as and11, desc as desc9, inArray as inArray3 } from "drizzle-orm";
import OpenAI18 from "openai";
var openai3 = new OpenAI18({ apiKey: process.env.OPENAI_API_KEY });
var GraphitiMemory = class extends BaseMemory {
  memoryStore;
  nodeStore;
  edgeStore;
  systemId = null;
  config;
  constructor(userId, name, config = {}) {
    super("graphiti" /* Graphiti */, userId, name, config);
    this.memoryStore = /* @__PURE__ */ new Map();
    this.nodeStore = /* @__PURE__ */ new Map();
    this.edgeStore = /* @__PURE__ */ new Map();
    this.config = {
      retrievalDepth: 2,
      minNodeWeight: 0.3,
      minEdgeWeight: 0.3,
      extractGraphFromContent: true,
      ...config
    };
  }
  /**
   * Initialize memory system from database
   * Creates system in DB if it doesn't exist
   */
  async initialize() {
    try {
      const existingSystem = await db.select().from(memorySystems).where(and11(
        eq16(memorySystems.userId, this.userId),
        eq16(memorySystems.name, this.name),
        eq16(memorySystems.type, "graphiti" /* Graphiti */)
      )).limit(1);
      if (existingSystem.length > 0) {
        this.systemId = existingSystem[0].id;
        if (JSON.stringify(existingSystem[0].config) !== JSON.stringify(this.config)) {
          await db.update(memorySystems).set({
            config: this.config,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq16(memorySystems.id, this.systemId));
        }
        const memories = await db.select().from(memoryEntries).where(eq16(memoryEntries.systemId, this.systemId)).orderBy(desc9(memoryEntries.lastAccessed));
        memories.forEach((mem) => {
          this.memoryStore.set(mem.entryKey, {
            key: mem.entryKey,
            content: mem.content,
            metadata: mem.metadata,
            importance: mem.importance || 0.5,
            timestamp: mem.createdAt,
            lastAccessed: mem.lastAccessed || void 0,
            accessCount: mem.accessCount || 0,
            expires: mem.expires || void 0
          });
        });
        const nodes = await db.select().from(knowledgeGraphNodes).where(eq16(knowledgeGraphNodes.systemId, this.systemId));
        nodes.forEach((node) => {
          this.nodeStore.set(node.nodeId, {
            id: node.id,
            nodeId: node.nodeId,
            label: node.label,
            properties: node.properties,
            embedding: node.embedding,
            createdAt: node.createdAt,
            updatedAt: node.updatedAt
          });
        });
        const edges = await db.select().from(knowledgeGraphEdges).where(eq16(knowledgeGraphEdges.systemId, this.systemId));
        edges.forEach((edge) => {
          const sourceNode = nodes.find((n) => n.id === edge.sourceId);
          const targetNode = nodes.find((n) => n.id === edge.targetId);
          if (!sourceNode || !targetNode) return;
          const sourceNodeId = sourceNode.nodeId;
          if (!this.edgeStore.has(sourceNodeId)) {
            this.edgeStore.set(sourceNodeId, []);
          }
          const edgeList = this.edgeStore.get(sourceNodeId);
          edgeList.push({
            id: edge.id,
            sourceId: edge.sourceId,
            targetId: edge.targetId,
            relationship: edge.relationship,
            weight: edge.weight,
            properties: edge.properties,
            createdAt: edge.createdAt,
            updatedAt: edge.updatedAt
          });
        });
        this.metrics.cacheSize = this.memoryStore.size;
        this.metrics.nodeCount = this.nodeStore.size;
        this.metrics.edgeCount = edges.length;
      } else {
        const [newSystem] = await db.insert(memorySystems).values({
          userId: this.userId,
          name: this.name,
          type: "graphiti" /* Graphiti */,
          description: "Knowledge graph memory system",
          config: this.config,
          isActive: true,
          isDefault: false,
          metrics: this.metrics
        }).returning();
        this.systemId = newSystem.id;
      }
    } catch (error) {
      console.error("Error initializing Graphiti memory:", error);
      throw new Error("Failed to initialize memory system");
    }
  }
  /**
   * Store a new memory and extract graph elements from it
   */
  async addMemory(entry) {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      const key = entry.key || `mem-${generateId()}`;
      const metadata = entry.metadata || {};
      const memoryEntry = {
        key,
        content: entry.content,
        metadata,
        importance: entry.importance || 0.5,
        timestamp: entry.timestamp || /* @__PURE__ */ new Date(),
        lastAccessed: /* @__PURE__ */ new Date(),
        accessCount: 0,
        expires: entry.expires
      };
      this.memoryStore.set(key, memoryEntry);
      await db.insert(memoryEntries).values({
        systemId: this.systemId,
        entryKey: key,
        content: entry.content,
        metadata,
        importance: entry.importance || 0.5,
        accessCount: 0,
        createdAt: entry.timestamp || /* @__PURE__ */ new Date(),
        lastAccessed: /* @__PURE__ */ new Date(),
        expires: entry.expires
      });
      if (this.config.extractGraphFromContent && entry.content) {
        await this.extractAndStoreGraph(entry.content, key);
      }
      this.metrics.cacheSize = this.memoryStore.size;
      this.metrics.insertionLatency = this.metrics.insertionLatency ? (this.metrics.insertionLatency + performance.now() - (entry.timestamp?.getTime() || Date.now())) / 2 : performance.now() - (entry.timestamp?.getTime() || Date.now());
    } catch (error) {
      console.error("Error adding memory to Graphiti:", error);
      throw new Error("Failed to add memory");
    }
  }
  /**
   * Retrieve a specific memory by key
   */
  async getMemory(key) {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      const startTime2 = performance.now();
      let memory = this.memoryStore.get(key);
      if (!memory) {
        const dbMemory = await db.select().from(memoryEntries).where(
          and11(
            eq16(memoryEntries.systemId, this.systemId),
            eq16(memoryEntries.entryKey, key)
          )
        ).limit(1);
        if (dbMemory.length > 0) {
          memory = {
            key: dbMemory[0].entryKey,
            content: dbMemory[0].content,
            metadata: dbMemory[0].metadata,
            importance: dbMemory[0].importance || 0.5,
            timestamp: dbMemory[0].createdAt,
            lastAccessed: dbMemory[0].lastAccessed || void 0,
            accessCount: dbMemory[0].accessCount || 0,
            expires: dbMemory[0].expires || void 0
          };
          this.memoryStore.set(key, memory);
        } else {
          this.metrics.hitRate = this.metrics.hitRate !== void 0 ? this.metrics.hitRate * (this.metrics.totalQueries || 0) / ((this.metrics.totalQueries || 0) + 1) : 0;
          this.metrics.totalQueries = (this.metrics.totalQueries || 0) + 1;
          return null;
        }
      }
      const now = /* @__PURE__ */ new Date();
      const accessCount = (memory.accessCount || 0) + 1;
      memory.lastAccessed = now;
      memory.accessCount = accessCount;
      await db.update(memoryEntries).set({
        lastAccessed: now,
        accessCount
      }).where(
        and11(
          eq16(memoryEntries.systemId, this.systemId),
          eq16(memoryEntries.entryKey, key)
        )
      );
      const endTime = performance.now();
      this.metrics.retrievalLatency = this.metrics.retrievalLatency ? (this.metrics.retrievalLatency + (endTime - startTime2)) / 2 : endTime - startTime2;
      this.metrics.hitRate = this.metrics.hitRate !== void 0 ? (this.metrics.hitRate * (this.metrics.totalQueries || 0) + 1) / ((this.metrics.totalQueries || 0) + 1) : 1;
      this.metrics.totalQueries = (this.metrics.totalQueries || 0) + 1;
      return memory;
    } catch (error) {
      console.error("Error retrieving memory from Graphiti:", error);
      throw new Error("Failed to retrieve memory");
    }
  }
  /**
   * Update an existing memory
   */
  async updateMemory(key, update) {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      const existing = await this.getMemory(key);
      if (!existing) {
        throw new Error(`Memory with key ${key} not found`);
      }
      const updated = {
        ...existing,
        ...update,
        key
        // Ensure key remains the same
      };
      this.memoryStore.set(key, updated);
      await db.update(memoryEntries).set({
        content: updated.content,
        metadata: updated.metadata,
        importance: updated.importance,
        updatedAt: /* @__PURE__ */ new Date(),
        expires: updated.expires
      }).where(
        and11(
          eq16(memoryEntries.systemId, this.systemId),
          eq16(memoryEntries.entryKey, key)
        )
      );
      if (update.content && this.config.extractGraphFromContent) {
        await this.clearGraphForMemory(key);
        await this.extractAndStoreGraph(update.content, key);
      }
    } catch (error) {
      console.error("Error updating memory in Graphiti:", error);
      throw new Error("Failed to update memory");
    }
  }
  /**
   * Remove a memory and its associated graph elements
   */
  async removeMemory(key) {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      await this.clearGraphForMemory(key);
      this.memoryStore.delete(key);
      await db.delete(memoryEntries).where(
        and11(
          eq16(memoryEntries.systemId, this.systemId),
          eq16(memoryEntries.entryKey, key)
        )
      );
      this.metrics.cacheSize = this.memoryStore.size;
    } catch (error) {
      console.error("Error removing memory from Graphiti:", error);
      throw new Error("Failed to remove memory");
    }
  }
  /**
   * Find memories that are relevant to the given query using graph traversal
   */
  async searchMemories(query2, limit = 5) {
    if (!this.systemId) {
      await this.initialize();
    }
    const startTime2 = performance.now();
    try {
      const queryNodes = await this.extractGraphNodes(query2);
      if (queryNodes.length === 0) {
        return this.searchMemoriesByText(query2, limit);
      }
      const matchingNodeIds = [];
      for (const queryNode of queryNodes) {
        for (const [nodeId, node] of this.nodeStore.entries()) {
          if (node.label.toLowerCase() === queryNode.label.toLowerCase() || node.properties.name && node.properties.name.toLowerCase() === queryNode.properties.name?.toLowerCase()) {
            matchingNodeIds.push(node.id);
          }
        }
      }
      if (matchingNodeIds.length === 0) {
        return this.searchMemoriesByText(query2, limit);
      }
      const visited = /* @__PURE__ */ new Set();
      const nodeScores = /* @__PURE__ */ new Map();
      const memoryScores = /* @__PURE__ */ new Map();
      for (const nodeId of matchingNodeIds) {
        visited.add(nodeId);
        nodeScores.set(nodeId, 1);
      }
      for (let depth = 0; depth < this.config.retrievalDepth; depth++) {
        const nextLevel = /* @__PURE__ */ new Set();
        for (const nodeId of visited) {
          const node = Array.from(this.nodeStore.values()).find((n) => n.id === nodeId);
          if (!node) continue;
          const nodeScore = nodeScores.get(nodeId) || 0;
          const edges = this.edgeStore.get(node.nodeId) || [];
          for (const edge of edges) {
            if (edge.weight < this.config.minEdgeWeight) continue;
            const targetScore = nodeScore * edge.weight * Math.pow(0.7, depth);
            if (targetScore < this.config.minNodeWeight) continue;
            const targetNodeScore = nodeScores.get(edge.targetId) || 0;
            nodeScores.set(edge.targetId, Math.max(targetNodeScore, targetScore));
            if (!visited.has(edge.targetId)) {
              nextLevel.add(edge.targetId);
            }
          }
          await this.addMemoryScoresForNode(node.nodeId, nodeScore, memoryScores);
        }
        for (const id of nextLevel) {
          visited.add(id);
        }
      }
      const results = [];
      for (const [memoryKey, score] of memoryScores.entries()) {
        const memory = this.memoryStore.get(memoryKey);
        if (!memory) continue;
        results.push({
          memory,
          score
        });
      }
      const sortedResults = results.sort((a, b) => b.score - a.score).slice(0, limit);
      for (const result2 of sortedResults) {
        const memory = result2.memory;
        memory.lastAccessed = /* @__PURE__ */ new Date();
        memory.accessCount = (memory.accessCount || 0) + 1;
        await db.update(memoryEntries).set({
          lastAccessed: memory.lastAccessed,
          accessCount: memory.accessCount
        }).where(
          and11(
            eq16(memoryEntries.systemId, this.systemId),
            eq16(memoryEntries.entryKey, memory.key)
          )
        );
      }
      const endTime = performance.now();
      this.metrics.retrievalLatency = this.metrics.retrievalLatency ? (this.metrics.retrievalLatency + (endTime - startTime2)) / 2 : endTime - startTime2;
      return sortedResults;
    } catch (error) {
      console.error("Error searching memories in Graphiti:", error);
      return this.searchMemoriesByText(query2, limit);
    }
  }
  /**
   * Text-based search fallback
   */
  async searchMemoriesByText(query2, limit = 5) {
    const queryTerms = query2.toLowerCase().split(/\s+/).filter((t) => t.length > 2);
    const results = /* @__PURE__ */ new Map();
    for (const [key, memory] of this.memoryStore.entries()) {
      const content2 = memory.content.toLowerCase();
      let matchScore = 0;
      for (const term of queryTerms) {
        if (content2.includes(term)) {
          matchScore += 1;
        }
      }
      if (matchScore > 0) {
        results.set(key, {
          memory,
          score: matchScore * (memory.importance || 0.5)
        });
      }
    }
    return Array.from(results.values()).sort((a, b) => b.score - a.score).slice(0, limit);
  }
  /**
   * Clear all memories and graph elements
   */
  async clear() {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      this.memoryStore.clear();
      this.nodeStore.clear();
      this.edgeStore.clear();
      await db.delete(knowledgeGraphEdges).where(eq16(knowledgeGraphEdges.systemId, this.systemId));
      await db.delete(knowledgeGraphNodes).where(eq16(knowledgeGraphNodes.systemId, this.systemId));
      await db.delete(memoryEntries).where(eq16(memoryEntries.systemId, this.systemId));
      this.metrics.cacheSize = 0;
      this.metrics.nodeCount = 0;
      this.metrics.edgeCount = 0;
    } catch (error) {
      console.error("Error clearing Graphiti memory:", error);
      throw new Error("Failed to clear memory");
    }
  }
  /**
   * Add a node to the knowledge graph
   */
  async addNode(nodeId, label, properties) {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      const existingNode = this.nodeStore.get(nodeId);
      if (existingNode) {
        await db.update(knowledgeGraphNodes).set({
          properties: {
            ...existingNode.properties,
            ...properties
          },
          updatedAt: /* @__PURE__ */ new Date()
        }).where(
          and11(
            eq16(knowledgeGraphNodes.systemId, this.systemId),
            eq16(knowledgeGraphNodes.nodeId, nodeId)
          )
        );
        existingNode.properties = {
          ...existingNode.properties,
          ...properties
        };
        existingNode.updatedAt = /* @__PURE__ */ new Date();
        return existingNode;
      } else {
        const [newNode] = await db.insert(knowledgeGraphNodes).values({
          systemId: this.systemId,
          nodeId,
          label,
          properties,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).returning();
        const graphNode = {
          id: newNode.id,
          nodeId,
          label,
          properties,
          createdAt: newNode.createdAt,
          updatedAt: newNode.updatedAt
        };
        this.nodeStore.set(nodeId, graphNode);
        this.metrics.nodeCount = (this.metrics.nodeCount || 0) + 1;
        return graphNode;
      }
    } catch (error) {
      console.error("Error adding node to Graphiti:", error);
      throw new Error("Failed to add node");
    }
  }
  /**
   * Add an edge between two nodes
   */
  async addEdge(sourceNodeId, targetNodeId, relationship, weight = 0.5, properties = {}) {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      let sourceNode = this.nodeStore.get(sourceNodeId);
      let targetNode = this.nodeStore.get(targetNodeId);
      if (!sourceNode) {
        sourceNode = await this.addNode(sourceNodeId, "Entity", { name: sourceNodeId });
      }
      if (!targetNode) {
        targetNode = await this.addNode(targetNodeId, "Entity", { name: targetNodeId });
      }
      let existingEdge;
      const sourceEdges = this.edgeStore.get(sourceNodeId) || [];
      for (const edge of sourceEdges) {
        if (edge.sourceId === sourceNode.id && edge.targetId === targetNode.id && edge.relationship === relationship) {
          existingEdge = edge;
          break;
        }
      }
      if (existingEdge) {
        await db.update(knowledgeGraphEdges).set({
          weight,
          properties: {
            ...existingEdge.properties,
            ...properties
          },
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq16(knowledgeGraphEdges.id, existingEdge.id));
        existingEdge.weight = weight;
        existingEdge.properties = {
          ...existingEdge.properties,
          ...properties
        };
        existingEdge.updatedAt = /* @__PURE__ */ new Date();
        return existingEdge;
      } else {
        const [newEdge] = await db.insert(knowledgeGraphEdges).values({
          systemId: this.systemId,
          sourceId: sourceNode.id,
          targetId: targetNode.id,
          relationship,
          weight,
          properties,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).returning();
        const graphEdge = {
          id: newEdge.id,
          sourceId: sourceNode.id,
          targetId: targetNode.id,
          relationship,
          weight,
          properties,
          createdAt: newEdge.createdAt,
          updatedAt: newEdge.updatedAt
        };
        if (!this.edgeStore.has(sourceNodeId)) {
          this.edgeStore.set(sourceNodeId, []);
        }
        this.edgeStore.get(sourceNodeId).push(graphEdge);
        this.metrics.edgeCount = (this.metrics.edgeCount || 0) + 1;
        return graphEdge;
      }
    } catch (error) {
      console.error("Error adding edge to Graphiti:", error);
      throw new Error("Failed to add edge");
    }
  }
  /**
   * Extract graph structure from content using OpenAI
   */
  async extractGraphNodes(text2) {
    if (!process.env.OPENAI_API_KEY) {
      return [];
    }
    try {
      const trimmedText = text2.slice(0, 4e3);
      const prompt = `
        Identify the 3-7 most important concepts or entities in the following text.
        For each concept, provide:
        1. A label (such as Person, Organization, Location, Concept, Topic, etc.)
        2. Properties (name, description, and any other relevant attributes)
        
        Return as JSON array with objects containing "label" and "properties" fields.
        Only return the JSON array, nothing else.
        
        Text: ${trimmedText}
      `;
      const response = await openai3.chat.completions.create({
        model: "gpt-4o",
        messages: [{ role: "user", content: prompt }],
        response_format: { type: "json_object" },
        temperature: 0.2
      });
      const content2 = response.choices[0].message.content;
      if (!content2) return [];
      try {
        const parsed = JSON.parse(content2);
        const nodes = parsed.nodes || parsed.concepts || parsed;
        if (!Array.isArray(nodes)) return [];
        return nodes.filter((n) => n.label && n.properties).map((n) => ({
          label: n.label,
          properties: n.properties
        }));
      } catch (parseError) {
        console.error("Error parsing graph extraction response:", parseError);
        return [];
      }
    } catch (error) {
      console.error("Error extracting graph nodes:", error);
      return [];
    }
  }
  /**
   * Extract relationships between concepts
   */
  async extractRelationships(nodes) {
    if (!process.env.OPENAI_API_KEY || nodes.length < 2) {
      return [];
    }
    try {
      const nodesText = nodes.map(
        (n) => `${n.label}: ${n.properties.name || "Unnamed"}`
      ).join("\n");
      const prompt = `
        Analyze these concepts and identify meaningful relationships between them:
        
        ${nodesText}
        
        For each relationship, provide:
        1. Source concept name
        2. Target concept name
        3. Relationship type (e.g., "is_part_of", "knows", "contains", "is_related_to", etc.)
        4. Weight (0.0 to 1.0) indicating strength of relationship
        
        Only identify relationships where there is a clear connection.
        Return as JSON array with fields: source, target, relationship, weight.
        Only return the JSON array, nothing else.
      `;
      const response = await openai3.chat.completions.create({
        model: "gpt-4o",
        messages: [{ role: "user", content: prompt }],
        response_format: { type: "json_object" },
        temperature: 0.3
      });
      const content2 = response.choices[0].message.content;
      if (!content2) return [];
      try {
        const parsed = JSON.parse(content2);
        const relationships = parsed.relationships || parsed;
        if (!Array.isArray(relationships)) return [];
        return relationships.filter((r) => r.source && r.target && r.relationship).map((r) => ({
          source: r.source,
          target: r.target,
          relationship: r.relationship,
          weight: typeof r.weight === "number" ? r.weight : 0.5
        }));
      } catch (parseError) {
        console.error("Error parsing relationship extraction response:", parseError);
        return [];
      }
    } catch (error) {
      console.error("Error extracting relationships:", error);
      return [];
    }
  }
  /**
   * Extract and store graph from content
   */
  async extractAndStoreGraph(content2, memoryKey) {
    try {
      const nodes = await this.extractGraphNodes(content2);
      if (nodes.length === 0) return;
      const createdNodes = [];
      for (const node of nodes) {
        const nodeId = `${node.label.toLowerCase()}-${node.properties.name || generateId()}`;
        const properties = {
          ...node.properties,
          memoryKeys: [memoryKey]
        };
        const createdNode = await this.addNode(nodeId, node.label, properties);
        createdNodes.push(createdNode);
      }
      const relationships = await this.extractRelationships(nodes);
      for (const rel of relationships) {
        const sourceNode = createdNodes.find(
          (n) => n.properties.name?.toLowerCase() === rel.source.toLowerCase()
        );
        const targetNode = createdNodes.find(
          (n) => n.properties.name?.toLowerCase() === rel.target.toLowerCase()
        );
        if (sourceNode && targetNode) {
          await this.addEdge(
            sourceNode.nodeId,
            targetNode.nodeId,
            rel.relationship,
            rel.weight,
            { memoryKey }
          );
        }
      }
    } catch (error) {
      console.error("Error extracting graph from content:", error);
    }
  }
  /**
   * Clear graph elements associated with a memory
   */
  async clearGraphForMemory(memoryKey) {
    if (!this.systemId) return;
    try {
      const edgesToDelete = [];
      for (const [sourceNodeId, edges] of this.edgeStore.entries()) {
        for (const edge of edges) {
          if (edge.properties.memoryKey === memoryKey) {
            edgesToDelete.push(edge.id);
          }
        }
      }
      if (edgesToDelete.length > 0) {
        await db.delete(knowledgeGraphEdges).where(
          and11(
            eq16(knowledgeGraphEdges.systemId, this.systemId),
            inArray3(knowledgeGraphEdges.id, edgesToDelete)
          )
        );
        for (const [sourceNodeId, edges] of this.edgeStore.entries()) {
          this.edgeStore.set(
            sourceNodeId,
            edges.filter((edge) => !edgesToDelete.includes(edge.id))
          );
        }
        this.metrics.edgeCount = (this.metrics.edgeCount || 0) - edgesToDelete.length;
      }
      const nodesToDelete = [];
      for (const [nodeId, node] of this.nodeStore.entries()) {
        if (Array.isArray(node.properties.memoryKeys) && node.properties.memoryKeys.length === 1 && node.properties.memoryKeys[0] === memoryKey) {
          nodesToDelete.push(node.id);
        }
      }
      if (nodesToDelete.length > 0) {
        await db.delete(knowledgeGraphNodes).where(
          and11(
            eq16(knowledgeGraphNodes.systemId, this.systemId),
            inArray3(knowledgeGraphNodes.id, nodesToDelete)
          )
        );
        for (const [nodeId, node] of this.nodeStore.entries()) {
          if (nodesToDelete.includes(node.id)) {
            this.nodeStore.delete(nodeId);
          }
        }
        this.metrics.nodeCount = (this.metrics.nodeCount || 0) - nodesToDelete.length;
      }
      for (const [nodeId, node] of this.nodeStore.entries()) {
        if (Array.isArray(node.properties.memoryKeys) && node.properties.memoryKeys.includes(memoryKey) && node.properties.memoryKeys.length > 1) {
          const updatedMemoryKeys = node.properties.memoryKeys.filter(
            (key) => key !== memoryKey
          );
          await db.update(knowledgeGraphNodes).set({
            properties: {
              ...node.properties,
              memoryKeys: updatedMemoryKeys
            },
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq16(knowledgeGraphNodes.id, node.id));
          node.properties = {
            ...node.properties,
            memoryKeys: updatedMemoryKeys
          };
        }
      }
    } catch (error) {
      console.error("Error clearing graph for memory:", error);
    }
  }
  /**
   * Add memory scores for nodes connected to memories
   */
  async addMemoryScoresForNode(nodeId, nodeScore, memoryScores) {
    const node = this.nodeStore.get(nodeId);
    if (!node || !node.properties.memoryKeys) return;
    const memoryKeys = node.properties.memoryKeys;
    for (const memoryKey of memoryKeys) {
      const currentScore = memoryScores.get(memoryKey) || 0;
      memoryScores.set(memoryKey, Math.max(currentScore, nodeScore));
    }
  }
};

// server/services/memory/ZepMemory.ts
import { eq as eq17, and as and12, desc as desc10 } from "drizzle-orm";
import OpenAI19 from "openai";
var openai4 = new OpenAI19({ apiKey: process.env.OPENAI_API_KEY });
var ZepMemory = class extends BaseMemory {
  memoryStore;
  systemId = null;
  config;
  semanticIndex = /* @__PURE__ */ new Map();
  constructor(userId, name, config = {}) {
    super("zep" /* Zep */, userId, name, config);
    this.memoryStore = /* @__PURE__ */ new Map();
    this.config = {
      useSemanticSearch: true,
      useFuzzyMatching: true,
      maxResults: 10,
      minRelevanceScore: 0.6,
      contextSize: 4e3,
      ...config
    };
  }
  /**
   * Initialize memory system from database
   * Creates system in DB if it doesn't exist
   */
  async initialize() {
    try {
      const existingSystem = await db.select().from(memorySystems).where(and12(
        eq17(memorySystems.userId, this.userId),
        eq17(memorySystems.name, this.name),
        eq17(memorySystems.type, "zep" /* Zep */)
      )).limit(1);
      if (existingSystem.length > 0) {
        this.systemId = existingSystem[0].id;
        if (JSON.stringify(existingSystem[0].config) !== JSON.stringify(this.config)) {
          await db.update(memorySystems).set({
            config: this.config,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq17(memorySystems.id, this.systemId));
        }
        const memories = await db.select().from(memoryEntries).where(eq17(memoryEntries.systemId, this.systemId)).orderBy(desc10(memoryEntries.lastAccessed));
        memories.forEach((mem) => {
          this.memoryStore.set(mem.entryKey, {
            key: mem.entryKey,
            content: mem.content,
            metadata: mem.metadata,
            importance: mem.importance || 0.5,
            timestamp: mem.createdAt,
            lastAccessed: mem.lastAccessed || void 0,
            accessCount: mem.accessCount || 0,
            expires: mem.expires || void 0
          });
          if (mem.metadata && mem.metadata.embedding) {
            this.semanticIndex.set(mem.entryKey, mem.metadata.embedding);
          }
        });
        this.metrics.cacheSize = this.memoryStore.size;
      } else {
        const [newSystem] = await db.insert(memorySystems).values({
          userId: this.userId,
          name: this.name,
          type: "zep" /* Zep */,
          description: "Fuzzy memory fallback system",
          config: this.config,
          isActive: true,
          isDefault: false,
          metrics: this.metrics
        }).returning();
        this.systemId = newSystem.id;
      }
    } catch (error) {
      console.error("Error initializing Zep memory:", error);
      throw new Error("Failed to initialize memory system");
    }
  }
  /**
   * Store a new memory
   */
  async addMemory(entry) {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      const key = entry.key || `mem-${generateId()}`;
      let embedding;
      if (this.config.useSemanticSearch) {
        embedding = await this.generateEmbedding(entry.content);
      }
      const metadata = {
        ...entry.metadata || {},
        ...embedding ? { embedding } : {}
      };
      const memoryEntry = {
        key,
        content: entry.content,
        metadata,
        importance: entry.importance || 0.5,
        timestamp: entry.timestamp || /* @__PURE__ */ new Date(),
        lastAccessed: /* @__PURE__ */ new Date(),
        accessCount: 0,
        expires: entry.expires
      };
      this.memoryStore.set(key, memoryEntry);
      if (embedding) {
        this.semanticIndex.set(key, embedding);
      }
      await db.insert(memoryEntries).values({
        systemId: this.systemId,
        entryKey: key,
        content: entry.content,
        metadata,
        importance: entry.importance || 0.5,
        accessCount: 0,
        createdAt: entry.timestamp || /* @__PURE__ */ new Date(),
        lastAccessed: /* @__PURE__ */ new Date(),
        expires: entry.expires
      });
      this.metrics.cacheSize = this.memoryStore.size;
      this.metrics.insertionLatency = this.metrics.insertionLatency ? (this.metrics.insertionLatency + performance.now() - (entry.timestamp?.getTime() || Date.now())) / 2 : performance.now() - (entry.timestamp?.getTime() || Date.now());
    } catch (error) {
      console.error("Error adding memory to Zep:", error);
      throw new Error("Failed to add memory");
    }
  }
  /**
   * Retrieve a specific memory by key
   */
  async getMemory(key) {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      const startTime2 = performance.now();
      let memory = this.memoryStore.get(key);
      if (!memory) {
        const dbMemory = await db.select().from(memoryEntries).where(
          and12(
            eq17(memoryEntries.systemId, this.systemId),
            eq17(memoryEntries.entryKey, key)
          )
        ).limit(1);
        if (dbMemory.length > 0) {
          memory = {
            key: dbMemory[0].entryKey,
            content: dbMemory[0].content,
            metadata: dbMemory[0].metadata,
            importance: dbMemory[0].importance || 0.5,
            timestamp: dbMemory[0].createdAt,
            lastAccessed: dbMemory[0].lastAccessed || void 0,
            accessCount: dbMemory[0].accessCount || 0,
            expires: dbMemory[0].expires || void 0
          };
          this.memoryStore.set(key, memory);
          if (memory.metadata && memory.metadata.embedding) {
            this.semanticIndex.set(key, memory.metadata.embedding);
          }
        } else {
          this.metrics.hitRate = this.metrics.hitRate !== void 0 ? this.metrics.hitRate * (this.metrics.totalQueries || 0) / ((this.metrics.totalQueries || 0) + 1) : 0;
          this.metrics.totalQueries = (this.metrics.totalQueries || 0) + 1;
          return null;
        }
      }
      const now = /* @__PURE__ */ new Date();
      const accessCount = (memory.accessCount || 0) + 1;
      memory.lastAccessed = now;
      memory.accessCount = accessCount;
      await db.update(memoryEntries).set({
        lastAccessed: now,
        accessCount
      }).where(
        and12(
          eq17(memoryEntries.systemId, this.systemId),
          eq17(memoryEntries.entryKey, key)
        )
      );
      const endTime = performance.now();
      this.metrics.retrievalLatency = this.metrics.retrievalLatency ? (this.metrics.retrievalLatency + (endTime - startTime2)) / 2 : endTime - startTime2;
      this.metrics.hitRate = this.metrics.hitRate !== void 0 ? (this.metrics.hitRate * (this.metrics.totalQueries || 0) + 1) / ((this.metrics.totalQueries || 0) + 1) : 1;
      this.metrics.totalQueries = (this.metrics.totalQueries || 0) + 1;
      return memory;
    } catch (error) {
      console.error("Error retrieving memory from Zep:", error);
      throw new Error("Failed to retrieve memory");
    }
  }
  /**
   * Update an existing memory
   */
  async updateMemory(key, update) {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      const existing = await this.getMemory(key);
      if (!existing) {
        throw new Error(`Memory with key ${key} not found`);
      }
      let embedding;
      if (update.content && this.config.useSemanticSearch) {
        embedding = await this.generateEmbedding(update.content);
      }
      const metadata = {
        ...existing.metadata,
        ...update.metadata || {},
        ...embedding ? { embedding } : {}
      };
      const updated = {
        ...existing,
        ...update,
        metadata,
        key
        // Ensure key remains the same
      };
      this.memoryStore.set(key, updated);
      if (embedding) {
        this.semanticIndex.set(key, embedding);
      }
      await db.update(memoryEntries).set({
        content: updated.content,
        metadata,
        importance: updated.importance,
        updatedAt: /* @__PURE__ */ new Date(),
        expires: updated.expires
      }).where(
        and12(
          eq17(memoryEntries.systemId, this.systemId),
          eq17(memoryEntries.entryKey, key)
        )
      );
    } catch (error) {
      console.error("Error updating memory in Zep:", error);
      throw new Error("Failed to update memory");
    }
  }
  /**
   * Remove a memory
   */
  async removeMemory(key) {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      this.memoryStore.delete(key);
      this.semanticIndex.delete(key);
      await db.delete(memoryEntries).where(
        and12(
          eq17(memoryEntries.systemId, this.systemId),
          eq17(memoryEntries.entryKey, key)
        )
      );
      this.metrics.cacheSize = this.memoryStore.size;
    } catch (error) {
      console.error("Error removing memory from Zep:", error);
      throw new Error("Failed to remove memory");
    }
  }
  /**
   * Find memories that are relevant to the given query
   * Uses a combination of semantic search and fuzzy string matching
   */
  async searchMemories(query2, limit = 5) {
    if (!this.systemId) {
      await this.initialize();
    }
    const startTime2 = performance.now();
    try {
      const results = [];
      if (this.config.useSemanticSearch) {
        const semanticResults = await this.semanticSearch(query2, limit * 2);
        results.push(...semanticResults);
      }
      if (this.config.useFuzzyMatching && results.length < limit) {
        const fuzzyResults = await this.fuzzySearch(
          query2,
          limit * 2,
          results.map((r) => r.memory.key)
        );
        const existingKeys = new Set(results.map((r) => r.memory.key));
        const newFuzzyResults = fuzzyResults.filter((r) => !existingKeys.has(r.memory.key));
        results.push(...newFuzzyResults);
      }
      const filteredResults = results.filter((r) => r.score >= this.config.minRelevanceScore).sort((a, b) => b.score - a.score).slice(0, limit);
      for (const result2 of filteredResults) {
        const memory = result2.memory;
        memory.lastAccessed = /* @__PURE__ */ new Date();
        memory.accessCount = (memory.accessCount || 0) + 1;
        await db.update(memoryEntries).set({
          lastAccessed: memory.lastAccessed,
          accessCount: memory.accessCount
        }).where(
          and12(
            eq17(memoryEntries.systemId, this.systemId),
            eq17(memoryEntries.entryKey, memory.key)
          )
        );
      }
      const endTime = performance.now();
      this.metrics.retrievalLatency = this.metrics.retrievalLatency ? (this.metrics.retrievalLatency + (endTime - startTime2)) / 2 : endTime - startTime2;
      return filteredResults;
    } catch (error) {
      console.error("Error searching memories in Zep:", error);
      return this.keywordSearch(query2, limit);
    }
  }
  /**
   * Perform semantic search using embeddings
   */
  async semanticSearch(query2, limit) {
    try {
      const queryEmbedding = await this.generateEmbedding(query2);
      const results = [];
      for (const [key, embedding] of this.semanticIndex.entries()) {
        const memory = this.memoryStore.get(key);
        if (!memory) continue;
        const similarity = this.calculateCosineSimilarity(queryEmbedding, embedding);
        results.push({
          memory,
          score: similarity
        });
      }
      return results.sort((a, b) => b.score - a.score).slice(0, limit);
    } catch (error) {
      console.error("Error in semantic search:", error);
      return [];
    }
  }
  /**
   * Perform fuzzy search using string matching
   */
  async fuzzySearch(query2, limit, excludeKeys = []) {
    const exclude = new Set(excludeKeys);
    const queryTerms = query2.toLowerCase().split(/\s+/).filter((t) => t.length > 2);
    const results = [];
    for (const [key, memory] of this.memoryStore.entries()) {
      if (exclude.has(key)) continue;
      const content2 = memory.content.toLowerCase();
      let score = 0;
      for (const term of queryTerms) {
        if (content2.includes(term)) {
          const count2 = (content2.match(new RegExp(term, "g")) || []).length;
          score += 0.1 * count2 / content2.length;
          if (content2.includes(query2.toLowerCase())) {
            score += 0.3;
          }
        }
      }
      score *= memory.importance || 0.5;
      if (score > 0) {
        results.push({
          memory,
          score
        });
      }
    }
    const maxScore = Math.max(...results.map((r) => r.score), 1e-3);
    for (const result2 of results) {
      result2.score = result2.score / maxScore;
    }
    return results.sort((a, b) => b.score - a.score).slice(0, limit);
  }
  /**
   * Simple keyword search as a fallback
   */
  async keywordSearch(query2, limit) {
    const queryTerms = query2.toLowerCase().split(/\s+/).filter((t) => t.length > 2);
    const results = [];
    for (const [key, memory] of this.memoryStore.entries()) {
      const content2 = memory.content.toLowerCase();
      let matches = 0;
      for (const term of queryTerms) {
        if (content2.includes(term)) {
          matches++;
        }
      }
      if (matches > 0) {
        const score = matches / queryTerms.length;
        results.push({
          memory,
          score
        });
      }
    }
    return results.sort((a, b) => b.score - a.score).slice(0, limit);
  }
  /**
   * Clear all memories
   */
  async clear() {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      this.memoryStore.clear();
      this.semanticIndex.clear();
      await db.delete(memoryEntries).where(eq17(memoryEntries.systemId, this.systemId));
      this.metrics.cacheSize = 0;
    } catch (error) {
      console.error("Error clearing Zep memory:", error);
      throw new Error("Failed to clear memory");
    }
  }
  /**
   * Generate embedding for text using OpenAI API
   */
  async generateEmbedding(text2) {
    if (!process.env.OPENAI_API_KEY) {
      return Array.from({ length: 1536 }, () => Math.random() * 2 - 1);
    }
    try {
      const response = await openai4.embeddings.create({
        model: "text-embedding-ada-002",
        input: text2.slice(0, 8e3)
        // Limit to 8000 chars per OpenAI docs
      });
      return response.data[0].embedding;
    } catch (error) {
      console.error("Error generating embedding:", error);
      return Array.from({ length: 1536 }, () => Math.random() * 2 - 1);
    }
  }
  /**
   * Calculate cosine similarity between two vectors
   */
  calculateCosineSimilarity(a, b) {
    if (a.length !== b.length) {
      throw new Error("Vector dimensions do not match");
    }
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }
    if (normA === 0 || normB === 0) {
      return 0;
    }
    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
  }
};

// server/services/memory/LlamaIndexMemory.ts
import { eq as eq18, and as and13, desc as desc11 } from "drizzle-orm";
import OpenAI20 from "openai";
var openai5 = new OpenAI20({ apiKey: process.env.OPENAI_API_KEY });
var LlamaIndexMemory = class extends BaseMemory {
  memoryStore;
  indexStore;
  systemId = null;
  config;
  constructor(userId, name, config = {}) {
    super("llamaindex" /* LlamaIndex */, userId, name, config);
    this.memoryStore = /* @__PURE__ */ new Map();
    this.indexStore = /* @__PURE__ */ new Map();
    this.config = {
      indexType: "tree",
      chunkSize: 1e3,
      chunkOverlap: 200,
      embeddingModel: "text-embedding-ada-002",
      keywordExtraction: true,
      summaryGeneration: true,
      ...config
    };
  }
  /**
   * Initialize memory system from database
   * Creates system in DB if it doesn't exist
   */
  async initialize() {
    try {
      const existingSystem = await db.select().from(memorySystems).where(and13(
        eq18(memorySystems.userId, this.userId),
        eq18(memorySystems.name, this.name),
        eq18(memorySystems.type, "llamaindex" /* LlamaIndex */)
      )).limit(1);
      if (existingSystem.length > 0) {
        this.systemId = existingSystem[0].id;
        if (JSON.stringify(existingSystem[0].config) !== JSON.stringify(this.config)) {
          await db.update(memorySystems).set({
            config: this.config,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq18(memorySystems.id, this.systemId));
        }
        const memories = await db.select().from(memoryEntries).where(eq18(memoryEntries.systemId, this.systemId)).orderBy(desc11(memoryEntries.lastAccessed));
        memories.forEach((mem) => {
          this.memoryStore.set(mem.entryKey, {
            key: mem.entryKey,
            content: mem.content,
            metadata: mem.metadata,
            importance: mem.importance || 0.5,
            timestamp: mem.createdAt,
            lastAccessed: mem.lastAccessed || void 0,
            accessCount: mem.accessCount || 0,
            expires: mem.expires || void 0
          });
          if (mem.metadata && mem.metadata.indexNodes) {
            const indexNodes = mem.metadata.indexNodes;
            for (const node of indexNodes) {
              this.indexStore.set(node.id, node);
            }
          }
        });
        this.metrics.cacheSize = this.memoryStore.size;
        this.metrics.nodeCount = this.indexStore.size;
      } else {
        const [newSystem] = await db.insert(memorySystems).values({
          userId: this.userId,
          name: this.name,
          type: "llamaindex" /* LlamaIndex */,
          description: "Index-based agent memory system",
          config: this.config,
          isActive: true,
          isDefault: false,
          metrics: this.metrics
        }).returning();
        this.systemId = newSystem.id;
      }
    } catch (error) {
      console.error("Error initializing LlamaIndex memory:", error);
      throw new Error("Failed to initialize memory system");
    }
  }
  /**
   * Store a new memory and index it
   */
  async addMemory(entry) {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      const key = entry.key || `mem-${generateId()}`;
      const indexNodes = await this.indexContent(entry.content, key);
      const metadata = {
        ...entry.metadata || {},
        indexNodes
      };
      const memoryEntry = {
        key,
        content: entry.content,
        metadata,
        importance: entry.importance || 0.5,
        timestamp: entry.timestamp || /* @__PURE__ */ new Date(),
        lastAccessed: /* @__PURE__ */ new Date(),
        accessCount: 0,
        expires: entry.expires
      };
      this.memoryStore.set(key, memoryEntry);
      await db.insert(memoryEntries).values({
        systemId: this.systemId,
        entryKey: key,
        content: entry.content,
        metadata,
        importance: entry.importance || 0.5,
        accessCount: 0,
        createdAt: entry.timestamp || /* @__PURE__ */ new Date(),
        lastAccessed: /* @__PURE__ */ new Date(),
        expires: entry.expires
      });
      this.metrics.cacheSize = this.memoryStore.size;
      this.metrics.nodeCount = this.indexStore.size;
      this.metrics.insertionLatency = this.metrics.insertionLatency ? (this.metrics.insertionLatency + performance.now() - (entry.timestamp?.getTime() || Date.now())) / 2 : performance.now() - (entry.timestamp?.getTime() || Date.now());
    } catch (error) {
      console.error("Error adding memory to LlamaIndex:", error);
      throw new Error("Failed to add memory");
    }
  }
  /**
   * Retrieve a specific memory by key
   */
  async getMemory(key) {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      const startTime2 = performance.now();
      let memory = this.memoryStore.get(key);
      if (!memory) {
        const dbMemory = await db.select().from(memoryEntries).where(
          and13(
            eq18(memoryEntries.systemId, this.systemId),
            eq18(memoryEntries.entryKey, key)
          )
        ).limit(1);
        if (dbMemory.length > 0) {
          memory = {
            key: dbMemory[0].entryKey,
            content: dbMemory[0].content,
            metadata: dbMemory[0].metadata,
            importance: dbMemory[0].importance || 0.5,
            timestamp: dbMemory[0].createdAt,
            lastAccessed: dbMemory[0].lastAccessed || void 0,
            accessCount: dbMemory[0].accessCount || 0,
            expires: dbMemory[0].expires || void 0
          };
          this.memoryStore.set(key, memory);
          if (memory.metadata && memory.metadata.indexNodes) {
            const indexNodes = memory.metadata.indexNodes;
            for (const node of indexNodes) {
              this.indexStore.set(node.id, node);
            }
          }
        } else {
          this.metrics.hitRate = this.metrics.hitRate !== void 0 ? this.metrics.hitRate * (this.metrics.totalQueries || 0) / ((this.metrics.totalQueries || 0) + 1) : 0;
          this.metrics.totalQueries = (this.metrics.totalQueries || 0) + 1;
          return null;
        }
      }
      const now = /* @__PURE__ */ new Date();
      const accessCount = (memory.accessCount || 0) + 1;
      memory.lastAccessed = now;
      memory.accessCount = accessCount;
      await db.update(memoryEntries).set({
        lastAccessed: now,
        accessCount
      }).where(
        and13(
          eq18(memoryEntries.systemId, this.systemId),
          eq18(memoryEntries.entryKey, key)
        )
      );
      const endTime = performance.now();
      this.metrics.retrievalLatency = this.metrics.retrievalLatency ? (this.metrics.retrievalLatency + (endTime - startTime2)) / 2 : endTime - startTime2;
      this.metrics.hitRate = this.metrics.hitRate !== void 0 ? (this.metrics.hitRate * (this.metrics.totalQueries || 0) + 1) / ((this.metrics.totalQueries || 0) + 1) : 1;
      this.metrics.totalQueries = (this.metrics.totalQueries || 0) + 1;
      return memory;
    } catch (error) {
      console.error("Error retrieving memory from LlamaIndex:", error);
      throw new Error("Failed to retrieve memory");
    }
  }
  /**
   * Update an existing memory
   */
  async updateMemory(key, update) {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      const existing = await this.getMemory(key);
      if (!existing) {
        throw new Error(`Memory with key ${key} not found`);
      }
      let indexNodes = existing.metadata?.indexNodes;
      if (update.content) {
        this.removeIndexNodes(key);
        indexNodes = await this.indexContent(update.content, key);
      }
      const metadata = {
        ...existing.metadata,
        ...update.metadata || {},
        indexNodes
      };
      const updated = {
        ...existing,
        ...update,
        metadata,
        key
        // Ensure key remains the same
      };
      this.memoryStore.set(key, updated);
      await db.update(memoryEntries).set({
        content: updated.content,
        metadata,
        importance: updated.importance,
        updatedAt: /* @__PURE__ */ new Date(),
        expires: updated.expires
      }).where(
        and13(
          eq18(memoryEntries.systemId, this.systemId),
          eq18(memoryEntries.entryKey, key)
        )
      );
      this.metrics.nodeCount = this.indexStore.size;
    } catch (error) {
      console.error("Error updating memory in LlamaIndex:", error);
      throw new Error("Failed to update memory");
    }
  }
  /**
   * Remove a memory and its index nodes
   */
  async removeMemory(key) {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      this.removeIndexNodes(key);
      this.memoryStore.delete(key);
      await db.delete(memoryEntries).where(
        and13(
          eq18(memoryEntries.systemId, this.systemId),
          eq18(memoryEntries.entryKey, key)
        )
      );
      this.metrics.cacheSize = this.memoryStore.size;
      this.metrics.nodeCount = this.indexStore.size;
    } catch (error) {
      console.error("Error removing memory from LlamaIndex:", error);
      throw new Error("Failed to remove memory");
    }
  }
  /**
   * Find memories that are relevant to the given query using index-based retrieval
   */
  async searchMemories(query2, limit = 5) {
    if (!this.systemId) {
      await this.initialize();
    }
    const startTime2 = performance.now();
    try {
      const queryEmbedding = await this.generateEmbedding(query2);
      let keywords = [];
      if (this.config.keywordExtraction) {
        keywords = await this.extractKeywords(query2);
      }
      let relevantNodes = [];
      switch (this.config.indexType) {
        case "tree":
          relevantNodes = await this.treeSearch(queryEmbedding, keywords, limit * 2);
          break;
        case "keyword_table":
          relevantNodes = await this.keywordSearch(keywords, limit * 2);
          break;
        case "list":
        default:
          relevantNodes = await this.listSearch(queryEmbedding, limit * 2);
      }
      const memoryScores = /* @__PURE__ */ new Map();
      const memoryToNodes = /* @__PURE__ */ new Map();
      for (const { node, score } of relevantNodes) {
        const memoryKey = node.metadata.memoryKey;
        if (!memoryKey) continue;
        const currentScore = memoryScores.get(memoryKey) || 0;
        memoryScores.set(memoryKey, Math.max(currentScore, score));
        if (!memoryToNodes.has(memoryKey)) {
          memoryToNodes.set(memoryKey, []);
        }
        memoryToNodes.get(memoryKey).push(node);
      }
      const results = [];
      for (const [memoryKey, score] of memoryScores.entries()) {
        const memory = this.memoryStore.get(memoryKey);
        if (!memory) continue;
        results.push({
          memory,
          score,
          context: {
            // Include relevant node content as additional context
            relevantNodes: memoryToNodes.get(memoryKey)?.map((n) => n.content) || []
          }
        });
      }
      const sortedResults = results.sort((a, b) => b.score - a.score).slice(0, limit);
      for (const result2 of sortedResults) {
        const memory = result2.memory;
        memory.lastAccessed = /* @__PURE__ */ new Date();
        memory.accessCount = (memory.accessCount || 0) + 1;
        await db.update(memoryEntries).set({
          lastAccessed: memory.lastAccessed,
          accessCount: memory.accessCount
        }).where(
          and13(
            eq18(memoryEntries.systemId, this.systemId),
            eq18(memoryEntries.entryKey, memory.key)
          )
        );
      }
      const endTime = performance.now();
      this.metrics.retrievalLatency = this.metrics.retrievalLatency ? (this.metrics.retrievalLatency + (endTime - startTime2)) / 2 : endTime - startTime2;
      return sortedResults;
    } catch (error) {
      console.error("Error searching memories in LlamaIndex:", error);
      return this.simpleSearch(query2, limit);
    }
  }
  /**
   * Clear all memories and index nodes
   */
  async clear() {
    try {
      if (!this.systemId) {
        await this.initialize();
      }
      this.memoryStore.clear();
      this.indexStore.clear();
      await db.delete(memoryEntries).where(eq18(memoryEntries.systemId, this.systemId));
      this.metrics.cacheSize = 0;
      this.metrics.nodeCount = 0;
    } catch (error) {
      console.error("Error clearing LlamaIndex memory:", error);
      throw new Error("Failed to clear memory");
    }
  }
  /**
   * Index content into nodes
   */
  async indexContent(content2, memoryKey) {
    const chunks = this.splitIntoChunks(content2, this.config.chunkSize, this.config.chunkOverlap);
    const nodes = [];
    let rootNodeId;
    if (this.config.indexType === "tree") {
      const summary = this.config.summaryGeneration ? await this.generateSummary(content2) : `Root node for memory ${memoryKey}`;
      const rootNode = {
        id: `${memoryKey}-root`,
        content: summary,
        children: [],
        metadata: {
          memoryKey,
          isRoot: true,
          level: 0
        },
        createdAt: /* @__PURE__ */ new Date()
      };
      nodes.push(rootNode);
      this.indexStore.set(rootNode.id, rootNode);
      rootNodeId = rootNode.id;
    }
    for (let i = 0; i < chunks.length; i++) {
      const nodeId = `${memoryKey}-node-${i}`;
      const chunk = chunks[i];
      const embedding = await this.generateEmbedding(chunk);
      let keywords = [];
      if (this.config.keywordExtraction) {
        keywords = await this.extractKeywords(chunk);
      }
      const node = {
        id: nodeId,
        content: chunk,
        embedding,
        children: [],
        parent: rootNodeId,
        metadata: {
          memoryKey,
          chunkIndex: i,
          keywords,
          level: 1
        },
        createdAt: /* @__PURE__ */ new Date()
      };
      nodes.push(node);
      this.indexStore.set(nodeId, node);
      if (rootNodeId) {
        const rootNode = this.indexStore.get(rootNodeId);
        if (rootNode) {
          rootNode.children.push(nodeId);
        }
      }
    }
    return nodes;
  }
  /**
   * Remove index nodes for a memory
   */
  removeIndexNodes(memoryKey) {
    const nodeIds = [];
    for (const [id, node] of this.indexStore.entries()) {
      if (node.metadata.memoryKey === memoryKey) {
        nodeIds.push(id);
      }
    }
    for (const id of nodeIds) {
      this.indexStore.delete(id);
    }
  }
  /**
   * Tree-based search
   */
  async treeSearch(queryEmbedding, keywords, limit) {
    const rootNodes = [...this.indexStore.values()].filter(
      (node) => node.metadata.isRoot === true
    );
    let relevantNodes = [];
    for (const rootNode of rootNodes) {
      let rootScore = 0;
      if (keywords.length > 0) {
        const content2 = rootNode.content.toLowerCase();
        for (const keyword of keywords) {
          if (content2.includes(keyword.toLowerCase())) {
            rootScore += 0.1;
          }
        }
      }
      relevantNodes.push({
        node: rootNode,
        score: rootScore
      });
      for (const childId of rootNode.children) {
        const childNode = this.indexStore.get(childId);
        if (!childNode || !childNode.embedding) continue;
        const similarity = this.calculateCosineSimilarity(queryEmbedding, childNode.embedding);
        let keywordScore = 0;
        if (keywords.length > 0 && childNode.metadata.keywords) {
          for (const keyword of keywords) {
            if (childNode.metadata.keywords.includes(keyword)) {
              keywordScore += 0.05;
            }
          }
        }
        const score = similarity + keywordScore;
        relevantNodes.push({
          node: childNode,
          score
        });
      }
    }
    return relevantNodes.sort((a, b) => b.score - a.score).slice(0, limit);
  }
  /**
   * Keyword-based search
   */
  async keywordSearch(keywords, limit) {
    if (keywords.length === 0) {
      return [];
    }
    const matches = [];
    for (const node of this.indexStore.values()) {
      if (!node.metadata.keywords) continue;
      let score = 0;
      const nodeKeywords = node.metadata.keywords;
      for (const keyword of keywords) {
        if (nodeKeywords.includes(keyword)) {
          score += 1 / keywords.length;
        }
      }
      if (score > 0) {
        matches.push({
          node,
          score
        });
      }
    }
    return matches.sort((a, b) => b.score - a.score).slice(0, limit);
  }
  /**
   * List-based search using vector similarity
   */
  async listSearch(queryEmbedding, limit) {
    const matches = [];
    for (const node of this.indexStore.values()) {
      if (!node.embedding) continue;
      const similarity = this.calculateCosineSimilarity(queryEmbedding, node.embedding);
      matches.push({
        node,
        score: similarity
      });
    }
    return matches.sort((a, b) => b.score - a.score).slice(0, limit);
  }
  /**
   * Simple search as fallback
   */
  async simpleSearch(query2, limit) {
    const queryTerms = query2.toLowerCase().split(/\s+/).filter((t) => t.length > 2);
    const results = [];
    for (const [key, memory] of this.memoryStore.entries()) {
      const content2 = memory.content.toLowerCase();
      let score = 0;
      for (const term of queryTerms) {
        if (content2.includes(term)) {
          score += 1 / queryTerms.length;
        }
      }
      if (score > 0) {
        results.push({
          memory,
          score: score * (memory.importance || 0.5)
        });
      }
    }
    return results.sort((a, b) => b.score - a.score).slice(0, limit);
  }
  /**
   * Split text into chunks with overlap
   */
  splitIntoChunks(text2, chunkSize, overlap) {
    const chunks = [];
    let startIndex = 0;
    while (startIndex < text2.length) {
      const endIndex = Math.min(startIndex + chunkSize, text2.length);
      const chunk = text2.substring(startIndex, endIndex);
      chunks.push(chunk);
      startIndex = endIndex - overlap;
      if (startIndex + chunkSize >= text2.length) {
        if (startIndex < text2.length) {
          chunks.push(text2.substring(startIndex));
        }
        break;
      }
    }
    return chunks;
  }
  /**
   * Generate embedding for text
   */
  async generateEmbedding(text2) {
    if (!process.env.OPENAI_API_KEY) {
      return Array.from({ length: 1536 }, () => Math.random() * 2 - 1);
    }
    try {
      const response = await openai5.embeddings.create({
        model: this.config.embeddingModel || "text-embedding-ada-002",
        input: text2.slice(0, 8e3)
        // Limit to 8000 chars per OpenAI docs
      });
      return response.data[0].embedding;
    } catch (error) {
      console.error("Error generating embedding:", error);
      return Array.from({ length: 1536 }, () => Math.random() * 2 - 1);
    }
  }
  /**
   * Extract keywords from text
   */
  async extractKeywords(text2) {
    if (!process.env.OPENAI_API_KEY) {
      return [];
    }
    try {
      const prompt = `Extract 5-10 important keywords from the following text. Return only the keywords as a comma-separated list without explanations or quotation marks.
      
Text: ${text2.slice(0, 4e3)}`;
      const response = await openai5.chat.completions.create({
        model: "gpt-4o",
        messages: [{ role: "user", content: prompt }],
        temperature: 0.3,
        max_tokens: 100
      });
      const content2 = response.choices[0].message.content || "";
      return content2.split(",").map((k) => k.trim()).filter((k) => k.length > 0);
    } catch (error) {
      console.error("Error extracting keywords:", error);
      return [];
    }
  }
  /**
   * Generate summary for text
   */
  async generateSummary(text2) {
    if (!process.env.OPENAI_API_KEY) {
      return `Summary of ${text2.slice(0, 50)}...`;
    }
    try {
      const prompt = `Summarize the following text in 1-2 sentences:
      
Text: ${text2.slice(0, 4e3)}`;
      const response = await openai5.chat.completions.create({
        model: "gpt-4o",
        messages: [{ role: "user", content: prompt }],
        temperature: 0.3,
        max_tokens: 100
      });
      return response.choices[0].message.content || `Summary not available`;
    } catch (error) {
      console.error("Error generating summary:", error);
      return `Summary not available`;
    }
  }
  /**
   * Calculate cosine similarity between two vectors
   */
  calculateCosineSimilarity(a, b) {
    if (a.length !== b.length) {
      throw new Error("Vector dimensions do not match");
    }
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }
    if (normA === 0 || normB === 0) {
      return 0;
    }
    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
  }
};

// server/services/memory/MemoryService.ts
import { eq as eq19, and as and14 } from "drizzle-orm";
var MemoryService = class _MemoryService {
  static instance;
  memorySystems = /* @__PURE__ */ new Map();
  constructor() {
  }
  /**
   * Get the singleton instance
   */
  static getInstance() {
    if (!_MemoryService.instance) {
      _MemoryService.instance = new _MemoryService();
    }
    return _MemoryService.instance;
  }
  /**
   * Get a memory system for a user
   * Creates it if it doesn't exist
   */
  async getMemorySystem(userId, type, name = "default", config = {}) {
    const key = `${userId}:${type}:${name}`;
    if (this.memorySystems.has(key)) {
      return this.memorySystems.get(key);
    }
    let memorySystem;
    switch (type) {
      case "context7" /* Context7 */:
        memorySystem = new Context7Memory(userId, name, config);
        break;
      case "mem0" /* Mem0 */:
        memorySystem = new Mem0Memory(userId, name, config);
        break;
      case "graphiti" /* Graphiti */:
        memorySystem = new GraphitiMemory(userId, name, config);
        break;
      case "zep" /* Zep */:
        memorySystem = new ZepMemory(userId, name, config);
        break;
      case "llamaindex" /* LlamaIndex */:
        memorySystem = new LlamaIndexMemory(userId, name, config);
        break;
      case "custom" /* Custom */:
        memorySystem = new Context7Memory(userId, name, config);
        break;
      default:
        memorySystem = new Context7Memory(userId, name, config);
    }
    await memorySystem.initialize();
    this.memorySystems.set(key, memorySystem);
    return memorySystem;
  }
  /**
   * Get all memory systems for a user
   */
  async getUserMemorySystems(userId) {
    const dbSystems = await db.select().from(memorySystems).where(eq19(memorySystems.userId, userId));
    const systems = [];
    for (const system of dbSystems) {
      try {
        const memorySystem = await this.getMemorySystem(
          userId,
          system.type,
          system.name,
          system.config
        );
        systems.push(memorySystem);
      } catch (error) {
        console.error(`Error loading memory system ${system.name}:`, error);
      }
    }
    return systems;
  }
  /**
   * Create a new memory system
   */
  async createMemorySystem(userId, type, name, config = {}) {
    const existing = await db.select().from(memorySystems).where(and14(
      eq19(memorySystems.userId, userId),
      eq19(memorySystems.name, name),
      eq19(memorySystems.type, type)
    )).limit(1);
    if (existing.length > 0) {
      throw new Error(`Memory system with name "${name}" already exists`);
    }
    return this.getMemorySystem(userId, type, name, config);
  }
  /**
   * Delete a memory system
   */
  async deleteMemorySystem(userId, type, name) {
    const key = `${userId}:${type}:${name}`;
    const memorySystem = this.memorySystems.get(key);
    if (memorySystem) {
      await memorySystem.clear();
      this.memorySystems.delete(key);
    }
    await db.delete(memorySystems).where(and14(
      eq19(memorySystems.userId, userId),
      eq19(memorySystems.name, name),
      eq19(memorySystems.type, type)
    ));
  }
  /**
   * Add a memory across multiple memory systems
   */
  async addMemoryToMultipleSystems(userId, entry, systems) {
    for (const system of systems) {
      const memorySystem = await this.getMemorySystem(userId, system.type, system.name);
      await memorySystem.addMemory(entry);
    }
  }
  /**
   * Search across multiple memory systems and combine results
   */
  async searchAcrossMemorySystems(userId, query2, systems, limit = 10) {
    const allResults = [];
    for (const system of systems) {
      try {
        const memorySystem = await this.getMemorySystem(userId, system.type, system.name);
        const results = await memorySystem.searchMemories(query2, limit);
        allResults.push(...results);
      } catch (error) {
        console.error(`Error searching memory system ${system.name}:`, error);
      }
    }
    const uniqueResults = /* @__PURE__ */ new Map();
    for (const result2 of allResults) {
      if (uniqueResults.has(result2.memory.key)) {
        const existing = uniqueResults.get(result2.memory.key);
        if (result2.score > existing.score) {
          uniqueResults.set(result2.memory.key, result2);
        }
      } else {
        uniqueResults.set(result2.memory.key, result2);
      }
    }
    return Array.from(uniqueResults.values()).sort((a, b) => b.score - a.score).slice(0, limit);
  }
};

// server/services/memory/MemorySelector.ts
var MemorySelector = class _MemorySelector {
  static instance;
  memoryService;
  constructor() {
    this.memoryService = MemoryService.getInstance();
  }
  /**
   * Get singleton instance
   */
  static getInstance() {
    if (!_MemorySelector.instance) {
      _MemorySelector.instance = new _MemorySelector();
    }
    return _MemorySelector.instance;
  }
  /**
   * Select the most appropriate memory system based on input parameters
   * Implements the routing logic according to the defined switching conditions
   */
  selectMemorySystem(params2) {
    if (params2.preferHighAvailability) {
      console.log("Routing to high availability memory: Mem0");
      return "mem0" /* Mem0 */;
    }
    if (params2.customFallbackChain && params2.customFallbackChain.length > 0) {
      console.log(`Routing to custom primary memory: ${params2.customFallbackChain[0]}`);
      return params2.customFallbackChain[0];
    }
    if (params2.workloadType) {
      switch (params2.workloadType) {
        case "knowledge_base" /* KNOWLEDGE_BASE */:
          console.log("Routing knowledge base workload to graph memory");
          return params2.documentGraph ? "graphiti" /* Graphiti */ : "llamaindex" /* LlamaIndex */;
        case "conversation" /* CONVERSATION */:
          console.log("Routing conversation workload to conversation memory");
          return params2.historyLength && params2.historyLength > 100 ? "zep" /* Zep */ : "context7" /* Context7 */;
        case "agent_state" /* AGENT_STATE */:
          console.log("Routing agent state workload to Mem0");
          return "mem0" /* Mem0 */;
        case "workflow_state" /* WORKFLOW_STATE */:
          console.log("Routing workflow state workload to Mem0");
          return "mem0" /* Mem0 */;
        case "vectordb_storage" /* VECTORDB_STORAGE */:
          console.log("Routing vector storage workload to LlamaIndex");
          return "llamaindex" /* LlamaIndex */;
        case "structured_data" /* STRUCTURED_DATA */:
          console.log("Routing structured data workload to specialized memory");
          return params2.documentGraph ? "graphiti" /* Graphiti */ : "mem0" /* Mem0 */;
      }
    }
    if (params2.isMultiModal) {
      console.log("Routing multi-modal content to LlamaIndex");
      return "llamaindex" /* LlamaIndex */;
    }
    if (params2.latencySensitive) {
      console.log("Routing latency-sensitive workload to Mem0");
      return "mem0" /* Mem0 */;
    }
    if (params2.throughputRequirement === "high") {
      console.log("Routing high-throughput workload to distributed memory");
      return "zep" /* Zep */;
    }
    if (params2.isHierarchical) {
      console.log("Routing hierarchical documents to Graphiti");
      return "graphiti" /* Graphiti */;
    }
    if (params2.documentCount && params2.documentCount > 1e3) {
      console.log("Routing large document collection to LlamaIndex");
      return "llamaindex" /* LlamaIndex */;
    }
    if (params2.documentGraph) {
      console.log("Routing document graph to Graphiti");
      return "graphiti" /* Graphiti */;
    }
    if (params2.averageDocumentSize && params2.averageDocumentSize > 1e6) {
      console.log("Routing large documents to LlamaIndex");
      return "llamaindex" /* LlamaIndex */;
    }
    if (params2.useRAG) {
      console.log("Routing RAG workflow to LlamaIndex");
      return "llamaindex" /* LlamaIndex */;
    }
    if (params2.sharedAgentState || params2.agentCount && params2.agentCount > 1) {
      console.log("Routing shared agent state to Mem0");
      return "mem0" /* Mem0 */;
    }
    if (params2.needsPersistence) {
      console.log("Routing persistent memory to Zep");
      return "zep" /* Zep */;
    }
    if (params2.region) {
      if (["eu", "europe", "uk"].some((r) => params2.region?.toLowerCase().includes(r))) {
        console.log("Routing EU-based workload to EU-optimized memory");
        return "context7" /* Context7 */;
      }
      if (["asia", "japan", "china", "india"].some((r) => params2.region?.toLowerCase().includes(r))) {
        console.log("Routing Asia-based workload to Asia-optimized memory");
        return "llamaindex" /* LlamaIndex */;
      }
    }
    if (params2.userPlan) {
      if (params2.userPlan === "enterprise") {
        console.log("Routing enterprise workload to premium memory");
        return params2.structuredData ? "graphiti" /* Graphiti */ : "zep" /* Zep */;
      }
      if (params2.userPlan === "pro") {
        console.log("Routing pro workload to mid-tier memory");
        return params2.structuredData ? "llamaindex" /* LlamaIndex */ : "context7" /* Context7 */;
      }
    }
    if (params2.historyLength && params2.historyLength > 100) {
      console.log("Routing long conversation history to Zep");
      return "zep" /* Zep */;
    }
    console.log("Routing to default memory: Mem0");
    return "mem0" /* Mem0 */;
  }
  /**
   * Get a fallback memory system based on the primary system and workload requirements
   */
  getFallbackMemorySystem(primarySystem, params2) {
    if (params2?.customFallbackChain && params2.customFallbackChain.length > 1) {
      console.log(`Using custom fallback memory: ${params2.customFallbackChain[1]}`);
      return params2.customFallbackChain[1];
    }
    if (params2?.workloadType) {
      const workloadBasedFallbacks = {
        ["knowledge_base" /* KNOWLEDGE_BASE */]: {
          ["graphiti" /* Graphiti */]: "llamaindex" /* LlamaIndex */,
          ["llamaindex" /* LlamaIndex */]: "mem0" /* Mem0 */,
          ["zep" /* Zep */]: "llamaindex" /* LlamaIndex */,
          ["context7" /* Context7 */]: "llamaindex" /* LlamaIndex */,
          ["mem0" /* Mem0 */]: "llamaindex" /* LlamaIndex */,
          ["custom" /* Custom */]: "llamaindex" /* LlamaIndex */
        },
        ["conversation" /* CONVERSATION */]: {
          ["zep" /* Zep */]: "context7" /* Context7 */,
          ["context7" /* Context7 */]: "mem0" /* Mem0 */,
          ["mem0" /* Mem0 */]: "context7" /* Context7 */,
          ["llamaindex" /* LlamaIndex */]: "context7" /* Context7 */,
          ["graphiti" /* Graphiti */]: "context7" /* Context7 */,
          ["custom" /* Custom */]: "context7" /* Context7 */
        },
        ["agent_state" /* AGENT_STATE */]: {
          ["mem0" /* Mem0 */]: "context7" /* Context7 */,
          ["context7" /* Context7 */]: "zep" /* Zep */,
          ["zep" /* Zep */]: "mem0" /* Mem0 */,
          ["llamaindex" /* LlamaIndex */]: "mem0" /* Mem0 */,
          ["graphiti" /* Graphiti */]: "mem0" /* Mem0 */,
          ["custom" /* Custom */]: "mem0" /* Mem0 */
        },
        ["workflow_state" /* WORKFLOW_STATE */]: {
          ["mem0" /* Mem0 */]: "context7" /* Context7 */,
          ["context7" /* Context7 */]: "zep" /* Zep */,
          ["zep" /* Zep */]: "mem0" /* Mem0 */,
          ["llamaindex" /* LlamaIndex */]: "mem0" /* Mem0 */,
          ["graphiti" /* Graphiti */]: "mem0" /* Mem0 */,
          ["custom" /* Custom */]: "mem0" /* Mem0 */
        },
        ["vectordb_storage" /* VECTORDB_STORAGE */]: {
          ["llamaindex" /* LlamaIndex */]: "graphiti" /* Graphiti */,
          ["graphiti" /* Graphiti */]: "mem0" /* Mem0 */,
          ["mem0" /* Mem0 */]: "llamaindex" /* LlamaIndex */,
          ["context7" /* Context7 */]: "llamaindex" /* LlamaIndex */,
          ["zep" /* Zep */]: "llamaindex" /* LlamaIndex */,
          ["custom" /* Custom */]: "llamaindex" /* LlamaIndex */
        },
        ["structured_data" /* STRUCTURED_DATA */]: {
          ["graphiti" /* Graphiti */]: "mem0" /* Mem0 */,
          ["mem0" /* Mem0 */]: "llamaindex" /* LlamaIndex */,
          ["llamaindex" /* LlamaIndex */]: "graphiti" /* Graphiti */,
          ["context7" /* Context7 */]: "mem0" /* Mem0 */,
          ["zep" /* Zep */]: "mem0" /* Mem0 */,
          ["custom" /* Custom */]: "mem0" /* Mem0 */
        }
      };
      const fallbackMap = workloadBasedFallbacks[params2.workloadType];
      if (fallbackMap && fallbackMap[primarySystem]) {
        console.log(`Using workload-specific fallback memory for ${params2.workloadType}: ${fallbackMap[primarySystem]}`);
        return fallbackMap[primarySystem];
      }
    }
    if (params2?.isMultiModal) {
      const multiModalFallbacks = {
        ["llamaindex" /* LlamaIndex */]: "graphiti" /* Graphiti */,
        ["graphiti" /* Graphiti */]: "llamaindex" /* LlamaIndex */,
        ["mem0" /* Mem0 */]: "llamaindex" /* LlamaIndex */,
        ["context7" /* Context7 */]: "llamaindex" /* LlamaIndex */,
        ["zep" /* Zep */]: "llamaindex" /* LlamaIndex */,
        ["custom" /* Custom */]: "llamaindex" /* LlamaIndex */
      };
      if (multiModalFallbacks[primarySystem]) {
        console.log(`Using multi-modal fallback memory: ${multiModalFallbacks[primarySystem]}`);
        return multiModalFallbacks[primarySystem];
      }
    }
    if (params2?.region) {
      if (["eu", "europe", "uk"].some((r) => params2.region?.toLowerCase().includes(r))) {
        const euFallbacks = {
          ["context7" /* Context7 */]: "mem0" /* Mem0 */,
          ["mem0" /* Mem0 */]: "context7" /* Context7 */,
          ["llamaindex" /* LlamaIndex */]: "context7" /* Context7 */,
          ["graphiti" /* Graphiti */]: "context7" /* Context7 */,
          ["zep" /* Zep */]: "context7" /* Context7 */,
          ["custom" /* Custom */]: "context7" /* Context7 */
        };
        if (euFallbacks[primarySystem]) {
          console.log(`Using EU region fallback memory: ${euFallbacks[primarySystem]}`);
          return euFallbacks[primarySystem];
        }
      }
      if (["asia", "japan", "china", "india"].some((r) => params2.region?.toLowerCase().includes(r))) {
        const asiaFallbacks = {
          ["llamaindex" /* LlamaIndex */]: "mem0" /* Mem0 */,
          ["mem0" /* Mem0 */]: "llamaindex" /* LlamaIndex */,
          ["context7" /* Context7 */]: "llamaindex" /* LlamaIndex */,
          ["graphiti" /* Graphiti */]: "llamaindex" /* LlamaIndex */,
          ["zep" /* Zep */]: "llamaindex" /* LlamaIndex */,
          ["custom" /* Custom */]: "llamaindex" /* LlamaIndex */
        };
        if (asiaFallbacks[primarySystem]) {
          console.log(`Using Asia region fallback memory: ${asiaFallbacks[primarySystem]}`);
          return asiaFallbacks[primarySystem];
        }
      }
    }
    if (params2?.latencySensitive) {
      const latencyFallbacks = {
        ["mem0" /* Mem0 */]: "context7" /* Context7 */,
        ["context7" /* Context7 */]: "mem0" /* Mem0 */,
        ["llamaindex" /* LlamaIndex */]: "mem0" /* Mem0 */,
        ["graphiti" /* Graphiti */]: "mem0" /* Mem0 */,
        ["zep" /* Zep */]: "mem0" /* Mem0 */,
        ["custom" /* Custom */]: "mem0" /* Mem0 */
      };
      if (latencyFallbacks[primarySystem]) {
        console.log(`Using latency-sensitive fallback memory: ${latencyFallbacks[primarySystem]}`);
        return latencyFallbacks[primarySystem];
      }
    }
    if (params2?.throughputRequirement === "high") {
      const throughputFallbacks = {
        ["zep" /* Zep */]: "llamaindex" /* LlamaIndex */,
        ["llamaindex" /* LlamaIndex */]: "zep" /* Zep */,
        ["mem0" /* Mem0 */]: "zep" /* Zep */,
        ["context7" /* Context7 */]: "zep" /* Zep */,
        ["graphiti" /* Graphiti */]: "zep" /* Zep */,
        ["custom" /* Custom */]: "zep" /* Zep */
      };
      if (throughputFallbacks[primarySystem]) {
        console.log(`Using high-throughput fallback memory: ${throughputFallbacks[primarySystem]}`);
        return throughputFallbacks[primarySystem];
      }
    }
    const defaultFallbackMap = {
      ["mem0" /* Mem0 */]: "context7" /* Context7 */,
      ["graphiti" /* Graphiti */]: "mem0" /* Mem0 */,
      ["zep" /* Zep */]: "mem0" /* Mem0 */,
      ["context7" /* Context7 */]: "mem0" /* Mem0 */,
      ["llamaindex" /* LlamaIndex */]: "mem0" /* Mem0 */,
      ["custom" /* Custom */]: "mem0" /* Mem0 */
    };
    console.log(`Using default fallback memory: ${defaultFallbackMap[primarySystem] || "mem0" /* Mem0 */}`);
    return defaultFallbackMap[primarySystem] || "mem0" /* Mem0 */;
  }
  /**
   * Create a chain of fallbacks for high reliability
   * @param params Optional selection parameters to customize the chain
   */
  getHighReliabilityFallbacks(params2) {
    if (params2?.customFallbackChain && params2.customFallbackChain.length > 0) {
      return params2.customFallbackChain;
    }
    if (params2?.workloadType) {
      switch (params2.workloadType) {
        case "knowledge_base" /* KNOWLEDGE_BASE */:
          return ["llamaindex" /* LlamaIndex */, "graphiti" /* Graphiti */, "mem0" /* Mem0 */];
        case "conversation" /* CONVERSATION */:
          return ["context7" /* Context7 */, "zep" /* Zep */, "mem0" /* Mem0 */];
        case "agent_state" /* AGENT_STATE */:
        case "workflow_state" /* WORKFLOW_STATE */:
          return ["mem0" /* Mem0 */, "context7" /* Context7 */, "zep" /* Zep */];
        case "vectordb_storage" /* VECTORDB_STORAGE */:
          return ["llamaindex" /* LlamaIndex */, "graphiti" /* Graphiti */, "mem0" /* Mem0 */];
        case "structured_data" /* STRUCTURED_DATA */:
          return ["graphiti" /* Graphiti */, "mem0" /* Mem0 */, "llamaindex" /* LlamaIndex */];
      }
    }
    if (params2?.isMultiModal) {
      return ["llamaindex" /* LlamaIndex */, "graphiti" /* Graphiti */, "mem0" /* Mem0 */];
    }
    if (params2?.region) {
      if (["eu", "europe", "uk"].some((r) => params2.region?.toLowerCase().includes(r))) {
        return ["context7" /* Context7 */, "mem0" /* Mem0 */, "llamaindex" /* LlamaIndex */];
      }
      if (["asia", "japan", "china", "india"].some((r) => params2.region?.toLowerCase().includes(r))) {
        return ["llamaindex" /* LlamaIndex */, "mem0" /* Mem0 */, "context7" /* Context7 */];
      }
    }
    if (params2?.latencySensitive) {
      return ["mem0" /* Mem0 */, "context7" /* Context7 */, "llamaindex" /* LlamaIndex */];
    }
    if (params2?.throughputRequirement === "high") {
      return ["zep" /* Zep */, "llamaindex" /* LlamaIndex */, "mem0" /* Mem0 */];
    }
    return ["mem0" /* Mem0 */, "context7" /* Context7 */, "llamaindex" /* LlamaIndex */];
  }
};
var MemorySelector_default = MemorySelector.getInstance();

// server/routes/memory-routes.ts
import { v4 as uuidv44 } from "uuid";
var router12 = Router9();
var memorySelector = MemorySelector.getInstance();
var memoryService = MemoryService.getInstance();
var mockMemorySystems = [
  {
    id: 1,
    name: "Agent Context Memory",
    type: "mem0" /* Mem0 */,
    isActive: true,
    metrics: {
      memorySize: 256,
      entryCount: 1024,
      avgRetrievalTime: 5,
      hitRate: 0.92,
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
    },
    createdAt: "2023-01-10T08:00:00Z",
    updatedAt: "2023-07-15T14:30:00Z"
  },
  {
    id: 2,
    name: "Document Knowledge Graph",
    type: "graphiti" /* Graphiti */,
    isActive: true,
    metrics: {
      memorySize: 512,
      entryCount: 345,
      avgRetrievalTime: 12,
      hitRate: 0.85,
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
    },
    createdAt: "2023-02-20T09:15:00Z",
    updatedAt: "2023-06-25T11:45:00Z"
  },
  {
    id: 3,
    name: "Session History",
    type: "zep" /* Zep */,
    isActive: true,
    metrics: {
      memorySize: 128,
      entryCount: 1500,
      avgRetrievalTime: 3,
      hitRate: 0.98,
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
    },
    createdAt: "2023-03-05T14:20:00Z",
    updatedAt: "2023-07-01T16:30:00Z"
  },
  {
    id: 4,
    name: "Backup Context System",
    type: "context7" /* Context7 */,
    isActive: false,
    metrics: {
      memorySize: 64,
      entryCount: 0,
      avgRetrievalTime: 0,
      hitRate: 0,
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
    },
    createdAt: "2023-04-10T08:45:00Z",
    updatedAt: "2023-04-10T08:45:00Z"
  },
  {
    id: 5,
    name: "Document Index Memory",
    type: "llamaindex" /* LlamaIndex */,
    isActive: true,
    metrics: {
      memorySize: 384,
      entryCount: 750,
      avgRetrievalTime: 8,
      hitRate: 0.89,
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
    },
    createdAt: "2023-05-15T11:30:00Z",
    updatedAt: "2023-06-20T10:15:00Z"
  }
];
router12.get("/systems", (req2, res2) => {
  res2.json(mockMemorySystems);
});
router12.get("/systems/:id", (req2, res2) => {
  const id = parseInt(req2.params.id);
  const system = mockMemorySystems.find((s) => s.id === id);
  if (!system) {
    return res2.status(404).json({ message: "Memory system not found" });
  }
  res2.json(system);
});
router12.post("/select", (req2, res2) => {
  try {
    const params2 = req2.body;
    console.log("Memory selection request with parameters:", JSON.stringify(params2, null, 2));
    const selectedType = memorySelector.selectMemorySystem(params2);
    const fallbackType = memorySelector.getFallbackMemorySystem(selectedType, params2);
    const selectedSystem = mockMemorySystems.find((s) => s.type === selectedType);
    const fallbackSystem = mockMemorySystems.find((s) => s.type === fallbackType);
    const includeReliabilityChain = req2.query.includeReliabilityChain === "true";
    const reliabilityChain = includeReliabilityChain ? memorySelector.getHighReliabilityFallbacks(params2) : null;
    const reliabilitySystems = reliabilityChain ? reliabilityChain.map((type) => mockMemorySystems.find((s) => s.type === type)).filter(Boolean) : null;
    const selectionRules = Object.keys(params2).map((key) => ({
      condition: key,
      value: params2[key]
    })).filter((rule) => rule.value !== void 0);
    const response = {
      selected: selectedType,
      system: selectedSystem,
      fallback: fallbackType,
      fallbackSystem,
      selectionRules,
      ...includeReliabilityChain && {
        reliabilityChain,
        reliabilitySystems
      },
      selectionParams: params2,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      // Include workload-specific metadata if available
      workloadMetadata: params2.workloadType ? {
        workloadType: params2.workloadType,
        optimizedFor: getWorkloadOptimizationInfo(params2.workloadType),
        multiModalSupport: !!params2.isMultiModal,
        regionalOptimization: params2.region || null
      } : null
    };
    console.log("Memory selection response:", JSON.stringify({
      selected: response.selected,
      fallback: response.fallback,
      ...includeReliabilityChain && { reliabilityChain }
    }, null, 2));
    res2.json(response);
  } catch (error) {
    console.error("Error selecting memory system:", error);
    res2.status(500).json({
      error: "Failed to select memory system",
      message: error.message || String(error)
    });
  }
});
function getWorkloadOptimizationInfo(workloadType) {
  switch (workloadType) {
    case "conversation" /* CONVERSATION */:
      return "Conversation history with context retention";
    case "knowledge_base" /* KNOWLEDGE_BASE */:
      return "Knowledge storage with semantic retrieval";
    case "agent_state" /* AGENT_STATE */:
      return "Agent working memory with fast access patterns";
    case "workflow_state" /* WORKFLOW_STATE */:
      return "Workflow execution state with transaction support";
    case "vectordb_storage" /* VECTORDB_STORAGE */:
      return "Vector embeddings with efficient similarity search";
    case "structured_data" /* STRUCTURED_DATA */:
      return "Structured data with relationship modeling";
    default:
      return "General purpose memory";
  }
}
router12.get("/high-reliability", (req2, res2) => {
  try {
    const params2 = {};
    if (req2.query.workloadType) {
      params2.workloadType = req2.query.workloadType;
    }
    if (req2.query.isMultiModal) {
      params2.isMultiModal = req2.query.isMultiModal === "true";
    }
    if (req2.query.documentGraph) {
      params2.documentGraph = req2.query.documentGraph === "true";
    }
    if (req2.query.latencySensitive) {
      params2.latencySensitive = req2.query.latencySensitive === "true";
    }
    if (req2.query.documentCount) {
      params2.documentCount = parseInt(req2.query.documentCount, 10);
    }
    if (req2.query.historyLength) {
      params2.historyLength = parseInt(req2.query.historyLength, 10);
    }
    if (req2.query.region) {
      params2.region = req2.query.region;
    }
    if (req2.query.userPlan) {
      params2.userPlan = req2.query.userPlan;
    }
    const reliabilityChain = memorySelector.getHighReliabilityFallbacks(params2);
    const reliabilitySystems = reliabilityChain.map((type) => mockMemorySystems.find((s) => s.type === type)).filter(Boolean);
    res2.json({
      fallbacks: reliabilityChain,
      systems: reliabilitySystems,
      contextParams: Object.keys(params2).length > 0 ? params2 : null,
      description: getReliabilityChainDescription(reliabilityChain, params2)
    });
  } catch (error) {
    console.error("Error getting high reliability memory systems:", error);
    res2.status(500).json({
      error: "Failed to get high reliability memory systems",
      message: error.message || String(error)
    });
  }
});
function getReliabilityChainDescription(chain, params2) {
  if (!chain.length) {
    return "No fallback chain available";
  }
  let description = `Primary system: ${chain[0]}`;
  if (chain.length > 1) {
    description += `, with fallbacks: ${chain.slice(1).join(" \u2192 ")}`;
  }
  if (params2?.workloadType) {
    description += `. Optimized for ${params2.workloadType} workloads`;
  }
  if (params2?.isMultiModal) {
    description += " with multi-modal support";
  }
  if (params2?.region) {
    description += ` in the ${params2.region} region`;
  }
  return description;
}
router12.post("/search", (req2, res2) => {
  try {
    const { query: query2, memoryType, limit = 10 } = req2.body;
    if (!query2) {
      return res2.status(400).json({ message: "Query is required" });
    }
    setTimeout(() => {
      const results = [
        {
          id: uuidv44(),
          system: "Mem0",
          memoryType: "mem0" /* Mem0 */,
          systemName: "Agent Context Memory",
          content: `Primary agent memory related to "${query2}" and associated context.`,
          metadata: {
            type: "agent_state",
            tags: ["context", "preference", "user_info"]
          },
          similarity: 0.92,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: uuidv44(),
          system: "Graphiti",
          memoryType: "graphiti" /* Graphiti */,
          systemName: "Document Knowledge Graph",
          content: `Graph relationship showing how "${query2}" connects to related concepts and entities.`,
          metadata: {
            source: "knowledge-graph",
            tags: ["relationship", "connection", "network"]
          },
          similarity: 0.85,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: uuidv44(),
          system: "Zep",
          memoryType: "zep" /* Zep */,
          systemName: "Session History",
          content: `Previous conversation mentioning "${query2}" in dialog context.`,
          metadata: {
            source: "conversation",
            tags: ["dialog", "interaction", "history"]
          },
          similarity: 0.78,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        }
      ];
      const filteredResults = memoryType ? results.filter((r) => r.memoryType === memoryType) : results;
      res2.json(filteredResults.slice(0, limit));
    }, 500);
  } catch (error) {
    res2.status(500).json({ message: error.message });
  }
});
router12.post("/store", (req2, res2) => {
  try {
    const { content: content2, metadata, systemType, importance } = req2.body;
    if (!content2 || !systemType) {
      return res2.status(400).json({ message: "Content and system type are required" });
    }
    setTimeout(() => {
      const newMemory = {
        id: uuidv44(),
        systemType,
        key: `memory:${Date.now()}`,
        content: content2,
        metadata: metadata || {},
        importance: importance || 0.5,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
      res2.json({
        success: true,
        memory: newMemory
      });
    }, 300);
  } catch (error) {
    res2.status(500).json({ message: error.message });
  }
});
function registerMemoryRoutes(app2) {
  app2.use("/api/memory", router12);
}

// server/routes/rag-routes.ts
import { Router as Router10 } from "express";

// server/services/rag/LightRAG.ts
import fs4 from "fs";
import path5 from "path";
import { v4 as uuidv45 } from "uuid";

// server/utils/vector.ts
import { createHash } from "crypto";
import OpenAI21 from "openai";
var openai6 = null;
if (process.env.OPENAI_API_KEY) {
  openai6 = new OpenAI21({
    apiKey: process.env.OPENAI_API_KEY
  });
}
function generateDeterministicEmbedding(text2, dimensions = 1536) {
  const hash = createHash("sha256").update(text2).digest("hex");
  const embedding = [];
  for (let i = 0; i < dimensions; i++) {
    const hashPart = parseInt(hash.substring(i * 2 % 64, (i * 2 + 2) % 64), 16);
    embedding.push(hashPart / 65535 * 2 - 1);
  }
  return normalizeVector(embedding);
}
async function generateOpenAIEmbedding(text2) {
  if (!openai6) {
    console.warn("OpenAI API key not set, using deterministic embedding");
    return generateDeterministicEmbedding(text2);
  }
  try {
    const response = await openai6.embeddings.create({
      model: "text-embedding-ada-002",
      input: text2.trim()
    });
    return response.data[0].embedding;
  } catch (error) {
    console.error("Error generating OpenAI embedding:", error);
    console.warn("Falling back to deterministic embedding");
    return generateDeterministicEmbedding(text2);
  }
}
async function getEmbedding(text2, dimensions = 1536) {
  if (openai6) {
    try {
      return await generateOpenAIEmbedding(text2);
    } catch (error) {
      console.warn("Error using OpenAI for embedding, falling back to deterministic method");
      return generateDeterministicEmbedding(text2, dimensions);
    }
  }
  return generateDeterministicEmbedding(text2, dimensions);
}
function normalizeVector(vector) {
  const magnitude = Math.sqrt(vector.reduce((sum2, val) => sum2 + val * val, 0));
  if (magnitude === 0) {
    return vector.map(() => 0);
  }
  return vector.map((val) => val / magnitude);
}
function cosineSimilarity(a, b) {
  if (a.length !== b.length) {
    throw new Error(`Vector dimensions do not match: ${a.length} vs ${b.length}`);
  }
  let dotProduct = 0;
  let normA = 0;
  let normB = 0;
  for (let i = 0; i < a.length; i++) {
    dotProduct += a[i] * b[i];
    normA += a[i] * a[i];
    normB += b[i] * b[i];
  }
  if (normA === 0 || normB === 0) {
    return 0;
  }
  return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
}
function findNearest(query2, vectors, k = 1) {
  if (vectors.length === 0) {
    return [];
  }
  const similarities = vectors.map((vector, index2) => ({
    index: index2,
    similarity: cosineSimilarity(query2, vector)
  }));
  similarities.sort((a, b) => b.similarity - a.similarity);
  return similarities.slice(0, k);
}

// server/services/rag/LightRAG.ts
var LightRAG = class {
  chunks = /* @__PURE__ */ new Map();
  config;
  dataDir;
  constructor(config = {}) {
    this.config = {
      dataDir: config.dataDir || "./data/rag",
      embeddingDimensions: config.embeddingDimensions || 1536,
      chunkSize: config.chunkSize || 512,
      chunkOverlap: config.chunkOverlap || 50,
      similarityThreshold: config.similarityThreshold || 0.7
    };
    this.dataDir = this.config.dataDir;
    if (!fs4.existsSync(this.dataDir)) {
      fs4.mkdirSync(this.dataDir, { recursive: true });
    }
    this.loadChunks();
  }
  /**
   * Load chunks from disk
   */
  loadChunks() {
    try {
      const chunksFile = path5.join(this.dataDir, "chunks.json");
      if (fs4.existsSync(chunksFile)) {
        const data = JSON.parse(fs4.readFileSync(chunksFile, "utf-8"));
        for (const chunk of data) {
          this.chunks.set(chunk.id, chunk);
        }
        console.log(`Loaded ${this.chunks.size} chunks from ${chunksFile}`);
      }
    } catch (error) {
      console.error("Error loading chunks:", error);
    }
  }
  /**
   * Save chunks to disk
   */
  saveChunks() {
    try {
      const chunksFile = path5.join(this.dataDir, "chunks.json");
      const data = Array.from(this.chunks.values());
      fs4.writeFileSync(chunksFile, JSON.stringify(data, null, 2));
      console.log(`Saved ${data.length} chunks to ${chunksFile}`);
    } catch (error) {
      console.error("Error saving chunks:", error);
    }
  }
  /**
   * Split text into chunks
   * 
   * @param text Text to split
   * @returns Array of text chunks
   */
  splitIntoChunks(text2) {
    const chunkSize = this.config.chunkSize;
    const overlap = this.config.chunkOverlap;
    const chunks = [];
    for (let i = 0; i < text2.length; i += chunkSize - overlap) {
      const chunk = text2.slice(i, i + chunkSize);
      chunks.push(chunk);
      if (i + chunkSize >= text2.length) {
        break;
      }
    }
    return chunks;
  }
  /**
   * Add a document to the LightRAG system
   * 
   * @param content Document content
   * @param metadata Document metadata
   * @returns True if the document was added successfully
   */
  async addDocument(content2, metadata = {}) {
    try {
      if (!content2) {
        throw new Error("Document content is required");
      }
      const docId = metadata.id || uuidv45();
      const textChunks = this.splitIntoChunks(content2);
      for (let i = 0; i < textChunks.length; i++) {
        const chunkId = `${docId}-${i}`;
        const embedding = await getEmbedding(textChunks[i]);
        const chunk = {
          id: chunkId,
          docId,
          content: textChunks[i],
          metadata: {
            ...metadata,
            chunkIndex: i,
            chunkCount: textChunks.length
          },
          embedding
        };
        this.chunks.set(chunkId, chunk);
      }
      this.saveChunks();
      return true;
    } catch (error) {
      console.error("Error adding document:", error);
      return false;
    }
  }
  /**
   * Delete a document from the LightRAG system
   * 
   * @param docId Document ID
   * @returns True if the document was deleted successfully
   */
  deleteDocument(docId) {
    try {
      let deleted = false;
      for (const [chunkId, chunk] of this.chunks.entries()) {
        if (chunk.docId === docId) {
          this.chunks.delete(chunkId);
          deleted = true;
        }
      }
      if (deleted) {
        this.saveChunks();
      }
      return deleted;
    } catch (error) {
      console.error("Error deleting document:", error);
      return false;
    }
  }
  /**
   * Query the LightRAG system
   * 
   * @param text Query text
   * @param limit Maximum number of chunks to return
   * @returns Array of retrieved chunks
   */
  async query(text2, limit = 5) {
    try {
      if (!text2) {
        throw new Error("Query text is required");
      }
      const queryEmbedding = await getEmbedding(text2);
      const embeddings = [];
      const chunkArray = [];
      for (const chunk of this.chunks.values()) {
        embeddings.push(chunk.embedding);
        chunkArray.push(chunk);
      }
      const topResults = findNearest(
        queryEmbedding,
        embeddings,
        limit
      ).filter((result2) => result2.similarity >= this.config.similarityThreshold);
      const retrievedChunks = topResults.map((result2) => {
        const chunk = chunkArray[result2.index];
        return {
          content: chunk.content,
          metadata: chunk.metadata,
          score: result2.similarity
        };
      });
      return retrievedChunks;
    } catch (error) {
      console.error("Error querying LightRAG:", error);
      return [];
    }
  }
  /**
   * Get stats about the LightRAG system
   */
  async getStats() {
    const documents = /* @__PURE__ */ new Set();
    for (const chunk of this.chunks.values()) {
      documents.add(chunk.docId);
    }
    return {
      chunkCount: this.chunks.size,
      documentCount: documents.size,
      avgChunksPerDocument: documents.size === 0 ? 0 : this.chunks.size / documents.size,
      configSettings: {
        ...this.config
      }
    };
  }
  /**
   * List all documents
   */
  listDocuments() {
    const documents = /* @__PURE__ */ new Map();
    for (const chunk of this.chunks.values()) {
      if (!documents.has(chunk.docId)) {
        documents.set(chunk.docId, {
          docId: chunk.docId,
          metadata: { ...chunk.metadata },
          chunkCount: 1
        });
        delete documents.get(chunk.docId).metadata.chunkIndex;
        delete documents.get(chunk.docId).metadata.chunkCount;
      } else {
        documents.get(chunk.docId).chunkCount++;
      }
    }
    return Array.from(documents.values());
  }
  /**
   * Get a document by ID
   */
  getDocument(docId) {
    const chunks = [];
    let metadata = {};
    let content2 = "";
    let foundChunks = false;
    for (const chunk of this.chunks.values()) {
      if (chunk.docId === docId) {
        foundChunks = true;
        chunks.push({
          id: chunk.id,
          content: chunk.content
        });
        content2 += chunk.content;
        if (Object.keys(metadata).length === 0) {
          metadata = { ...chunk.metadata };
          delete metadata.chunkIndex;
          delete metadata.chunkCount;
        }
      }
    }
    if (!foundChunks) {
      return null;
    }
    return {
      docId,
      metadata,
      content: content2,
      chunks
    };
  }
};

// server/services/rag/RagDbSwitchNode.ts
import { v4 as uuidv46 } from "uuid";
var COMPATIBILITY_MATRIX = {
  ["light_rag" /* LightRAG */]: {
    ["light_rag" /* LightRAG */]: 100,
    // Perfect compatibility with itself
    ["pinecone_rag" /* PineconeRAG */]: 90,
    // Excellent compatibility
    ["qdrant_rag" /* QdrantRAG */]: 90,
    // Excellent compatibility
    ["chroma_rag" /* ChromaRAG */]: 85,
    // Very good compatibility
    ["pgvector_rag" /* PgVectorRAG */]: 90,
    // Excellent compatibility
    ["semantic_rag" /* SemanticRAG */]: 80,
    // Good compatibility
    ["hybrid_rag" /* HybridRAG */]: 75,
    // Good compatibility
    ["code_rag" /* CodeRAG */]: 60,
    // Moderate compatibility (may lose specialized code indexing)
    ["legal_rag" /* LegalRAG */]: 60,
    // Moderate compatibility (may lose specialized legal features)
    ["llamaindex_rag" /* LlamaIndexRAG */]: 85,
    // Very good compatibility
    ["multimodal_rag" /* MultimodalRAG */]: 40,
    // Low compatibility (does not support images)
    ["custom" /* Custom */]: 50
    // Moderate compatibility (depends on custom implementation)
  },
  ["pinecone_rag" /* PineconeRAG */]: {
    ["light_rag" /* LightRAG */]: 70,
    // Good but may lose some vector DB specific features
    ["pinecone_rag" /* PineconeRAG */]: 100,
    // Perfect compatibility with itself
    ["qdrant_rag" /* QdrantRAG */]: 90,
    // Excellent compatibility
    ["chroma_rag" /* ChromaRAG */]: 85,
    // Very good compatibility
    ["pgvector_rag" /* PgVectorRAG */]: 85,
    // Very good compatibility 
    ["semantic_rag" /* SemanticRAG */]: 90,
    // Excellent compatibility
    ["hybrid_rag" /* HybridRAG */]: 80,
    // Good compatibility
    ["code_rag" /* CodeRAG */]: 75,
    // Good compatibility
    ["legal_rag" /* LegalRAG */]: 75,
    // Good compatibility
    ["llamaindex_rag" /* LlamaIndexRAG */]: 80,
    // Good compatibility
    ["multimodal_rag" /* MultimodalRAG */]: 65,
    // Moderate compatibility (may need vector transformation)
    ["custom" /* Custom */]: 60
    // Moderate compatibility (depends on custom implementation)
  },
  ["qdrant_rag" /* QdrantRAG */]: {
    ["light_rag" /* LightRAG */]: 70,
    // Good but may lose some vector DB specific features
    ["pinecone_rag" /* PineconeRAG */]: 90,
    // Excellent compatibility
    ["qdrant_rag" /* QdrantRAG */]: 100,
    // Perfect compatibility with itself
    ["chroma_rag" /* ChromaRAG */]: 85,
    // Very good compatibility
    ["pgvector_rag" /* PgVectorRAG */]: 85,
    // Very good compatibility
    ["semantic_rag" /* SemanticRAG */]: 90,
    // Excellent compatibility
    ["hybrid_rag" /* HybridRAG */]: 85,
    // Very good compatibility
    ["code_rag" /* CodeRAG */]: 80,
    // Good compatibility
    ["legal_rag" /* LegalRAG */]: 80,
    // Good compatibility
    ["llamaindex_rag" /* LlamaIndexRAG */]: 80,
    // Good compatibility
    ["multimodal_rag" /* MultimodalRAG */]: 75,
    // Good compatibility (better support for multimodal)
    ["custom" /* Custom */]: 60
    // Moderate compatibility (depends on custom implementation)
  },
  ["chroma_rag" /* ChromaRAG */]: {
    ["light_rag" /* LightRAG */]: 70,
    // Good but may lose some vector DB specific features
    ["pinecone_rag" /* PineconeRAG */]: 85,
    // Very good compatibility
    ["qdrant_rag" /* QdrantRAG */]: 85,
    // Very good compatibility
    ["chroma_rag" /* ChromaRAG */]: 100,
    // Perfect compatibility with itself
    ["pgvector_rag" /* PgVectorRAG */]: 80,
    // Good compatibility
    ["semantic_rag" /* SemanticRAG */]: 85,
    // Very good compatibility
    ["hybrid_rag" /* HybridRAG */]: 80,
    // Good compatibility
    ["code_rag" /* CodeRAG */]: 70,
    // Good compatibility
    ["legal_rag" /* LegalRAG */]: 70,
    // Good compatibility
    ["llamaindex_rag" /* LlamaIndexRAG */]: 80,
    // Good compatibility
    ["multimodal_rag" /* MultimodalRAG */]: 80,
    // Good compatibility (good support for multimodal)
    ["custom" /* Custom */]: 60
    // Moderate compatibility (depends on custom implementation)
  },
  ["pgvector_rag" /* PgVectorRAG */]: {
    ["light_rag" /* LightRAG */]: 75,
    // Good compatibility
    ["pinecone_rag" /* PineconeRAG */]: 85,
    // Very good compatibility
    ["qdrant_rag" /* QdrantRAG */]: 85,
    // Very good compatibility
    ["chroma_rag" /* ChromaRAG */]: 80,
    // Good compatibility
    ["pgvector_rag" /* PgVectorRAG */]: 100,
    // Perfect compatibility with itself
    ["semantic_rag" /* SemanticRAG */]: 85,
    // Very good compatibility
    ["hybrid_rag" /* HybridRAG */]: 80,
    // Good compatibility
    ["code_rag" /* CodeRAG */]: 75,
    // Good compatibility
    ["legal_rag" /* LegalRAG */]: 75,
    // Good compatibility
    ["llamaindex_rag" /* LlamaIndexRAG */]: 75,
    // Good compatibility
    ["multimodal_rag" /* MultimodalRAG */]: 60,
    // Moderate compatibility
    ["custom" /* Custom */]: 60
    // Moderate compatibility (depends on custom implementation)
  },
  ["semantic_rag" /* SemanticRAG */]: {
    ["light_rag" /* LightRAG */]: 70,
    // Good but may lose specialized semantic features
    ["pinecone_rag" /* PineconeRAG */]: 85,
    // Very good compatibility
    ["qdrant_rag" /* QdrantRAG */]: 85,
    // Very good compatibility
    ["chroma_rag" /* ChromaRAG */]: 80,
    // Good compatibility
    ["pgvector_rag" /* PgVectorRAG */]: 80,
    // Good compatibility
    ["semantic_rag" /* SemanticRAG */]: 100,
    // Perfect compatibility with itself
    ["hybrid_rag" /* HybridRAG */]: 90,
    // Excellent compatibility
    ["code_rag" /* CodeRAG */]: 80,
    // Good compatibility
    ["legal_rag" /* LegalRAG */]: 80,
    // Good compatibility
    ["llamaindex_rag" /* LlamaIndexRAG */]: 85,
    // Very good compatibility
    ["multimodal_rag" /* MultimodalRAG */]: 70,
    // Good compatibility
    ["custom" /* Custom */]: 60
    // Moderate compatibility (depends on custom implementation)
  },
  ["hybrid_rag" /* HybridRAG */]: {
    ["light_rag" /* LightRAG */]: 65,
    // Moderate compatibility (loses keyword search)
    ["pinecone_rag" /* PineconeRAG */]: 75,
    // Good compatibility (loses keyword capabilities)
    ["qdrant_rag" /* QdrantRAG */]: 75,
    // Good compatibility (loses keyword capabilities)
    ["chroma_rag" /* ChromaRAG */]: 75,
    // Good compatibility (loses keyword capabilities)
    ["pgvector_rag" /* PgVectorRAG */]: 80,
    // Good compatibility (PG has text search)
    ["semantic_rag" /* SemanticRAG */]: 80,
    // Good compatibility (loses keyword search)
    ["hybrid_rag" /* HybridRAG */]: 100,
    // Perfect compatibility with itself
    ["code_rag" /* CodeRAG */]: 80,
    // Good compatibility
    ["legal_rag" /* LegalRAG */]: 80,
    // Good compatibility
    ["llamaindex_rag" /* LlamaIndexRAG */]: 85,
    // Very good compatibility
    ["multimodal_rag" /* MultimodalRAG */]: 70,
    // Good compatibility
    ["custom" /* Custom */]: 65
    // Moderate compatibility (depends on custom implementation)
  },
  ["code_rag" /* CodeRAG */]: {
    ["light_rag" /* LightRAG */]: 60,
    // Moderate compatibility (loses specialized code features)
    ["pinecone_rag" /* PineconeRAG */]: 70,
    // Good compatibility
    ["qdrant_rag" /* QdrantRAG */]: 70,
    // Good compatibility
    ["chroma_rag" /* ChromaRAG */]: 65,
    // Moderate compatibility
    ["pgvector_rag" /* PgVectorRAG */]: 70,
    // Good compatibility
    ["semantic_rag" /* SemanticRAG */]: 75,
    // Good compatibility
    ["hybrid_rag" /* HybridRAG */]: 80,
    // Good compatibility
    ["code_rag" /* CodeRAG */]: 100,
    // Perfect compatibility with itself
    ["legal_rag" /* LegalRAG */]: 50,
    // Moderate compatibility (different domains)
    ["llamaindex_rag" /* LlamaIndexRAG */]: 80,
    // Good compatibility
    ["multimodal_rag" /* MultimodalRAG */]: 50,
    // Moderate compatibility
    ["custom" /* Custom */]: 60
    // Moderate compatibility (depends on custom implementation)
  },
  ["legal_rag" /* LegalRAG */]: {
    ["light_rag" /* LightRAG */]: 60,
    // Moderate compatibility (loses specialized legal features)
    ["pinecone_rag" /* PineconeRAG */]: 70,
    // Good compatibility
    ["qdrant_rag" /* QdrantRAG */]: 70,
    // Good compatibility
    ["chroma_rag" /* ChromaRAG */]: 65,
    // Moderate compatibility
    ["pgvector_rag" /* PgVectorRAG */]: 70,
    // Good compatibility
    ["semantic_rag" /* SemanticRAG */]: 75,
    // Good compatibility
    ["hybrid_rag" /* HybridRAG */]: 80,
    // Good compatibility
    ["code_rag" /* CodeRAG */]: 50,
    // Moderate compatibility (different domains)
    ["legal_rag" /* LegalRAG */]: 100,
    // Perfect compatibility with itself
    ["llamaindex_rag" /* LlamaIndexRAG */]: 80,
    // Good compatibility
    ["multimodal_rag" /* MultimodalRAG */]: 50,
    // Moderate compatibility
    ["custom" /* Custom */]: 60
    // Moderate compatibility (depends on custom implementation)
  },
  ["llamaindex_rag" /* LlamaIndexRAG */]: {
    ["light_rag" /* LightRAG */]: 75,
    // Good compatibility
    ["pinecone_rag" /* PineconeRAG */]: 80,
    // Good compatibility
    ["qdrant_rag" /* QdrantRAG */]: 80,
    // Good compatibility
    ["chroma_rag" /* ChromaRAG */]: 80,
    // Good compatibility
    ["pgvector_rag" /* PgVectorRAG */]: 75,
    // Good compatibility
    ["semantic_rag" /* SemanticRAG */]: 85,
    // Very good compatibility
    ["hybrid_rag" /* HybridRAG */]: 85,
    // Very good compatibility
    ["code_rag" /* CodeRAG */]: 80,
    // Good compatibility
    ["legal_rag" /* LegalRAG */]: 80,
    // Good compatibility
    ["llamaindex_rag" /* LlamaIndexRAG */]: 100,
    // Perfect compatibility with itself
    ["multimodal_rag" /* MultimodalRAG */]: 75,
    // Good compatibility
    ["custom" /* Custom */]: 70
    // Good compatibility (depends on custom implementation)
  },
  ["multimodal_rag" /* MultimodalRAG */]: {
    ["light_rag" /* LightRAG */]: 40,
    // Low compatibility (loses image support)
    ["pinecone_rag" /* PineconeRAG */]: 65,
    // Moderate compatibility
    ["qdrant_rag" /* QdrantRAG */]: 75,
    // Good compatibility
    ["chroma_rag" /* ChromaRAG */]: 80,
    // Good compatibility (good multimodal support)
    ["pgvector_rag" /* PgVectorRAG */]: 60,
    // Moderate compatibility
    ["semantic_rag" /* SemanticRAG */]: 70,
    // Good compatibility
    ["hybrid_rag" /* HybridRAG */]: 70,
    // Good compatibility
    ["code_rag" /* CodeRAG */]: 50,
    // Moderate compatibility
    ["legal_rag" /* LegalRAG */]: 50,
    // Moderate compatibility
    ["llamaindex_rag" /* LlamaIndexRAG */]: 75,
    // Good compatibility
    ["multimodal_rag" /* MultimodalRAG */]: 100,
    // Perfect compatibility with itself
    ["custom" /* Custom */]: 65
    // Moderate compatibility (depends on custom implementation)
  },
  ["custom" /* Custom */]: {
    ["light_rag" /* LightRAG */]: 50,
    // Moderate compatibility
    ["pinecone_rag" /* PineconeRAG */]: 60,
    // Moderate compatibility
    ["qdrant_rag" /* QdrantRAG */]: 60,
    // Moderate compatibility
    ["chroma_rag" /* ChromaRAG */]: 60,
    // Moderate compatibility
    ["pgvector_rag" /* PgVectorRAG */]: 60,
    // Moderate compatibility
    ["semantic_rag" /* SemanticRAG */]: 60,
    // Moderate compatibility
    ["hybrid_rag" /* HybridRAG */]: 65,
    // Moderate compatibility
    ["code_rag" /* CodeRAG */]: 60,
    // Moderate compatibility
    ["legal_rag" /* LegalRAG */]: 60,
    // Moderate compatibility
    ["llamaindex_rag" /* LlamaIndexRAG */]: 70,
    // Good compatibility
    ["multimodal_rag" /* MultimodalRAG */]: 65,
    // Moderate compatibility
    ["custom" /* Custom */]: 100
    // Perfect compatibility with itself (but depends on implementation)
  }
};
var RagDbSwitchNode = class {
  constructor() {
  }
  /**
   * Get compatibility information between two RAG system types
   */
  getCompatibilityInfo(sourceType, targetType) {
    const compatibilityScore = COMPATIBILITY_MATRIX[sourceType][targetType] || 0;
    const features = this.getFeaturesCompatibility(sourceType, targetType);
    let transferComplexity;
    if (compatibilityScore >= 80) {
      transferComplexity = "simple";
    } else if (compatibilityScore >= 60) {
      transferComplexity = "moderate";
    } else {
      transferComplexity = "complex";
    }
    const warnings = this.getCompatibilityWarnings(sourceType, targetType, compatibilityScore);
    const recommendations = this.getTransferRecommendations(sourceType, targetType);
    return {
      compatibilityScore,
      features,
      transferComplexity,
      warnings,
      recommendations
    };
  }
  /**
   * Get transfer recommendations based on document count
   */
  getTransferRecommendations(sourceType, targetType, documentCount = 10) {
    const compatibilityScore = COMPATIBILITY_MATRIX[sourceType][targetType] || 0;
    let batchSize = 10;
    if (documentCount > 1e3) {
      batchSize = 100;
    } else if (documentCount > 100) {
      batchSize = 50;
    } else if (documentCount > 10) {
      batchSize = 20;
    }
    if (compatibilityScore < 60) {
      batchSize = Math.max(5, Math.floor(batchSize / 2));
    }
    const reembedding = this.needsReembedding(sourceType, targetType);
    const preserveMetadata = compatibilityScore >= 70;
    const dataTransformation = compatibilityScore < 80;
    const baseTimePerDoc = reembedding ? 2 : 0.5;
    const totalEstimatedSeconds = baseTimePerDoc * documentCount * (100 / compatibilityScore);
    const estimatedTime = this.formatEstimatedTime(totalEstimatedSeconds);
    const recommendations = this.generateTransferRecommendations(
      sourceType,
      targetType,
      documentCount,
      reembedding,
      preserveMetadata,
      dataTransformation
    );
    return {
      batchSize,
      estimatedTime,
      preserveMetadata,
      reembedding,
      dataTransformation,
      recommendations
    };
  }
  /**
   * Start transfer of documents between RAG systems
   */
  async transferDocuments(sourceId, targetId, documentIds) {
    const operationId = uuidv46();
    const compatibility = 85;
    const result2 = {
      operationId,
      sourceId,
      targetId,
      documentIds,
      compatibility,
      startTime: (/* @__PURE__ */ new Date()).toISOString()
    };
    return result2;
  }
  /**
   * Get status of transfer operation
   */
  async getTransferStatus(operationId) {
    return {
      operationId,
      status: "in_progress",
      progress: 50,
      documentsProcessed: 5,
      totalDocuments: 10,
      startTime: (/* @__PURE__ */ new Date()).toISOString(),
      errors: [],
      warnings: []
    };
  }
  /**
   * Helper method to get feature compatibility details
   */
  getFeaturesCompatibility(sourceType, targetType) {
    const compatibilityScore = COMPATIBILITY_MATRIX[sourceType][targetType] || 0;
    const preserved = [];
    const degraded = [];
    const lost = [];
    preserved.push("Base document storage");
    preserved.push("Text search capability");
    switch (sourceType) {
      case "light_rag" /* LightRAG */:
        if (targetType === "light_rag" /* LightRAG */) {
          preserved.push("Document metadata");
          preserved.push("Simple embedding structure");
        } else if (["pinecone_rag" /* PineconeRAG */, "qdrant_rag" /* QdrantRAG */, "pgvector_rag" /* PgVectorRAG */].includes(targetType)) {
          preserved.push("Document metadata");
          degraded.push("Simple embedding structure");
          preserved.push("Advanced vector search");
        } else if (targetType === "multimodal_rag" /* MultimodalRAG */) {
          degraded.push("Document metadata");
          lost.push("Simple embedding structure");
          preserved.push("Advanced vector search");
        }
        break;
      case "code_rag" /* CodeRAG */:
        if (targetType === "code_rag" /* CodeRAG */) {
          preserved.push("Code-specific embeddings");
          preserved.push("Symbol extraction");
          preserved.push("Function/class indexing");
        } else {
          degraded.push("Code-specific embeddings");
          lost.push("Symbol extraction");
          lost.push("Function/class indexing");
        }
        break;
      case "multimodal_rag" /* MultimodalRAG */:
        if (targetType === "multimodal_rag" /* MultimodalRAG */) {
          preserved.push("Image embedding support");
          preserved.push("Mixed text-image retrieval");
        } else {
          lost.push("Image embedding support");
          lost.push("Mixed text-image retrieval");
          if (targetType === "chroma_rag" /* ChromaRAG */) {
            degraded.push("Some multimedia capabilities");
          }
        }
        break;
      case "hybrid_rag" /* HybridRAG */:
        if (targetType === "hybrid_rag" /* HybridRAG */) {
          preserved.push("Combined semantic-keyword search");
          preserved.push("Multiple retrieval methods");
        } else if (targetType === "semantic_rag" /* SemanticRAG */) {
          degraded.push("Combined semantic-keyword search");
          degraded.push("Multiple retrieval methods");
        } else {
          lost.push("Combined semantic-keyword search");
          degraded.push("Multiple retrieval methods");
        }
        break;
    }
    if (sourceType === "llamaindex_rag" /* LlamaIndexRAG */) {
      if (targetType === "llamaindex_rag" /* LlamaIndexRAG */) {
        preserved.push("Advanced indexing structures");
        preserved.push("Complex query routing");
      } else {
        degraded.push("Advanced indexing structures");
        degraded.push("Complex query routing");
      }
    }
    if (compatibilityScore >= 90) {
      preserved.push("Most specialized features");
    } else if (compatibilityScore >= 70) {
      degraded.push("Some specialized features");
    } else {
      lost.push("Most specialized features");
    }
    return { preserved, degraded, lost };
  }
  /**
   * Helper method to get warnings based on compatibility
   */
  getCompatibilityWarnings(sourceType, targetType, compatibilityScore) {
    const warnings = [];
    if (compatibilityScore < 50) {
      warnings.push("Very low compatibility - significant data loss is likely");
    }
    if (sourceType === "multimodal_rag" /* MultimodalRAG */ && targetType !== "multimodal_rag" /* MultimodalRAG */) {
      warnings.push("Image/multimodal content will not be transferred or will lose associated metadata");
    }
    if (sourceType === "code_rag" /* CodeRAG */ && targetType !== "code_rag" /* CodeRAG */) {
      warnings.push("Code-specific features like symbol extraction will be lost");
    }
    if (sourceType === "legal_rag" /* LegalRAG */ && targetType !== "legal_rag" /* LegalRAG */) {
      warnings.push("Legal-specific metadata and classification may be lost");
    }
    if (compatibilityScore < 70) {
      warnings.push("Some document metadata may not be preserved during transfer");
    }
    if (this.needsReembedding(sourceType, targetType)) {
      warnings.push("Documents will need to be re-embedded, which may change retrieval behavior");
    }
    return warnings;
  }
  /**
   * Helper method to generate transfer recommendations
   */
  generateTransferRecommendations(sourceType, targetType, documentCount, reembedding, preserveMetadata, dataTransformation) {
    const recommendations = [];
    if (documentCount > 1e3) {
      recommendations.push("Consider breaking the transfer into multiple smaller operations");
    }
    if (reembedding) {
      recommendations.push("Verify retrieval quality after transfer as embeddings will be regenerated");
    }
    if (!preserveMetadata) {
      recommendations.push("Export metadata separately before transfer to avoid losing critical information");
    }
    if (dataTransformation) {
      recommendations.push("Review document structure after transfer to ensure proper transformation");
    }
    if (sourceType === "multimodal_rag" /* MultimodalRAG */ && targetType !== "multimodal_rag" /* MultimodalRAG */) {
      recommendations.push("Consider keeping the original MultimodalRAG system for image content");
    }
    if (sourceType === "code_rag" /* CodeRAG */ && targetType !== "code_rag" /* CodeRAG */) {
      recommendations.push("Pre-process code documents to extract and preserve important symbols as plaintext");
    }
    if (sourceType === "light_rag" /* LightRAG */ && targetType !== "light_rag" /* LightRAG */) {
      recommendations.push("LightRAG is simple - the target system should be able to handle all content effectively");
    }
    if (targetType === "pinecone_rag" /* PineconeRAG */ || targetType === "qdrant_rag" /* QdrantRAG */) {
      recommendations.push("Configure vector dimensions and index settings before transfer for optimal performance");
    }
    if (targetType === "hybrid_rag" /* HybridRAG */) {
      recommendations.push("Set up both semantic and keyword indices for best results after transfer");
    }
    switch (targetType) {
      case "pgvector_rag" /* PgVectorRAG */:
        recommendations.push("Ensure PostgreSQL instance has sufficient resources for the vector data");
        break;
      case "llamaindex_rag" /* LlamaIndexRAG */:
        recommendations.push("Configure index type in LlamaIndex to match your retrieval pattern needs");
        break;
      case "semantic_rag" /* SemanticRAG */:
        recommendations.push("Consider adjusting semantic search parameters after transfer for best results");
        break;
    }
    return recommendations;
  }
  /**
   * Helper to determine if re-embedding is needed
   */
  needsReembedding(sourceType, targetType) {
    if (sourceType === "multimodal_rag" /* MultimodalRAG */ && targetType !== "multimodal_rag" /* MultimodalRAG */ || sourceType === "code_rag" /* CodeRAG */ && targetType !== "code_rag" /* CodeRAG */ || sourceType === "legal_rag" /* LegalRAG */ && targetType !== "legal_rag" /* LegalRAG */) {
      return true;
    }
    const differentEmbeddingSystems = [
      // System pairs that need re-embedding
      ["light_rag" /* LightRAG */, "semantic_rag" /* SemanticRAG */],
      ["light_rag" /* LightRAG */, "hybrid_rag" /* HybridRAG */],
      ["pinecone_rag" /* PineconeRAG */, "chroma_rag" /* ChromaRAG */],
      ["pgvector_rag" /* PgVectorRAG */, "qdrant_rag" /* QdrantRAG */]
    ];
    return differentEmbeddingSystems.some(
      (pair) => pair[0] === sourceType && pair[1] === targetType || pair[0] === targetType && pair[1] === sourceType
    );
  }
  /**
   * Format estimated time in a human-readable way
   */
  formatEstimatedTime(seconds) {
    if (seconds < 60) {
      return `${Math.round(seconds)} seconds`;
    } else if (seconds < 3600) {
      return `${Math.round(seconds / 60)} minutes`;
    } else {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.round(seconds % 3600 / 60);
      return `${hours} hour${hours > 1 ? "s" : ""} ${minutes} minute${minutes > 1 ? "s" : ""}`;
    }
  }
};

// server/services/rag/RagSelector.ts
var RagSelector = class _RagSelector {
  static instance;
  ragDbSwitch;
  constructor() {
    this.ragDbSwitch = new RagDbSwitchNode();
  }
  /**
   * Get singleton instance
   */
  static getInstance() {
    if (!_RagSelector.instance) {
      _RagSelector.instance = new _RagSelector();
    }
    return _RagSelector.instance;
  }
  /**
   * Select the most appropriate RAG system based on input parameters
   * Implements the routing logic according to the defined switching conditions
   */
  selectRagSystem(params2) {
    if (params2.fileSize !== void 0 && params2.fileSize < 1048576) {
      console.log("Routing to LightRAG: file_size < 1MB");
      return "light_rag" /* LightRAG */;
    }
    if (params2.datasetSize !== void 0 && params2.datasetSize > 1073741824) {
      console.log("Routing to Milvus/PineconeRAG: dataset_size > 1GB");
      return "pinecone_rag" /* PineconeRAG */;
    }
    if (params2.requiresMetadata) {
      console.log("Routing to Weaviate: query requires metadata filtering");
      return "semantic_rag" /* SemanticRAG */;
    }
    if (params2.structuredMemory) {
      console.log("Routing to Graphiti/Zep: structured_memory = true");
      return "semantic_rag" /* SemanticRAG */;
    }
    if (params2.bringYourOwnRag && params2.ragSource === "pinecone") {
      console.log("Routing to User RAG Integration: bring_your_rag = true && source = Pinecone");
      return "pinecone_rag" /* PineconeRAG */;
    }
    if (params2.userPlan === "free") {
      console.log("Routing to SupaVec: user.plan = free");
      return "pgvector_rag" /* PgVectorRAG */;
    }
    if (params2.queryTaggingEnabled) {
      console.log("Routing to Qdrant: query_tagging_enabled = true");
      return "qdrant_rag" /* QdrantRAG */;
    }
    if (params2.ocrResultInjected) {
      console.log("Routing to SupaVec or LightRAG: ocr_result_injected = true");
      return "pgvector_rag" /* PgVectorRAG */;
    }
    if (params2.agentContextRequired) {
      console.log("Routing to Mem0: agent_context_required = true");
      return "light_rag" /* LightRAG */;
    }
    if (params2.multiAgentContext) {
      console.log("Routing to Mem0 Shared Memory: multi-agent_context = true");
      return "light_rag" /* LightRAG */;
    }
    if (params2.deltaMemoryMode) {
      console.log("Routing to Context7/LightRAG: delta_memory_mode = enabled");
      return "light_rag" /* LightRAG */;
    }
    if (params2.queryDomain === "enterprise_dataset") {
      console.log("Routing to Milvus/Weaviate: query_domain = enterprise_dataset");
      return "pinecone_rag" /* PineconeRAG */;
    }
    if (params2.runtimeLatency !== void 0 && params2.runtimeLatency > 1e3) {
      console.log("Routing to LightRAG fallback: runtime_latency > 1s");
      return "light_rag" /* LightRAG */;
    }
    if (params2.ragFailures !== void 0 && params2.ragFailures > 5) {
      console.log("Routing to LightRAG/SupaVec fallback: rag_failures > threshold");
      return "light_rag" /* LightRAG */;
    }
    if (params2.requiresKnowledgeGraph) {
      console.log("Routing to Graphiti: knowledge_graph_required = true");
      return "semantic_rag" /* SemanticRAG */;
    }
    if (params2.promptSimilarity === "low") {
      console.log("Routing to SupaVec backup: prompt_similarity = low");
      return "pgvector_rag" /* PgVectorRAG */;
    }
    if (params2.ragVersioningEnabled) {
      console.log("Routing to Versioned RAG Logs: rag_versioning_enabled = true");
      return "pgvector_rag" /* PgVectorRAG */;
    }
    console.log("Routing to default: LightRAG");
    return "light_rag" /* LightRAG */;
  }
  /**
   * Get a fallback RAG system based on the primary system
   */
  getFallbackRagSystem(primarySystem) {
    const fallbackMap = {
      ["light_rag" /* LightRAG */]: "pgvector_rag" /* PgVectorRAG */,
      ["pgvector_rag" /* PgVectorRAG */]: "light_rag" /* LightRAG */,
      ["pinecone_rag" /* PineconeRAG */]: "light_rag" /* LightRAG */,
      ["qdrant_rag" /* QdrantRAG */]: "light_rag" /* LightRAG */,
      ["chroma_rag" /* ChromaRAG */]: "light_rag" /* LightRAG */,
      ["semantic_rag" /* SemanticRAG */]: "pgvector_rag" /* PgVectorRAG */,
      ["hybrid_rag" /* HybridRAG */]: "light_rag" /* LightRAG */,
      ["code_rag" /* CodeRAG */]: "pgvector_rag" /* PgVectorRAG */,
      ["legal_rag" /* LegalRAG */]: "pgvector_rag" /* PgVectorRAG */,
      ["llamaindex_rag" /* LlamaIndexRAG */]: "light_rag" /* LightRAG */,
      ["multimodal_rag" /* MultimodalRAG */]: "chroma_rag" /* ChromaRAG */,
      ["custom" /* Custom */]: "light_rag" /* LightRAG */
    };
    return fallbackMap[primarySystem] || "light_rag" /* LightRAG */;
  }
  /**
   * Get all applicable fallbacks for high reliability scenarios
   * Following the high reliability pattern: LightRAG → SupaVec → requery
   */
  getHighReliabilityFallbacks() {
    return ["light_rag" /* LightRAG */, "pgvector_rag" /* PgVectorRAG */];
  }
};
var RagSelector_default = RagSelector.getInstance();

// server/routes/rag-routes.ts
var router13 = Router10();
var lightRag = new LightRAG({
  dataDir: "./data/rag/light"
});
var ragDbSwitch = new RagDbSwitchNode();
var ragSelector = RagSelector.getInstance();
var mockRagSystems = [
  {
    id: 1,
    name: "Primary Document Storage",
    type: "light_rag" /* LightRAG */,
    isActive: true,
    documents: [
      { id: "doc1", title: "Company Overview", chunkCount: 12 },
      { id: "doc2", title: "Product Catalog", chunkCount: 34 },
      { id: "doc3", title: "Technical Documentation", chunkCount: 56 },
      { id: "doc4", title: "User Guides", chunkCount: 23 }
    ],
    metrics: {
      documentCount: 4,
      totalChunks: 125,
      averageChunkSize: 350,
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
    },
    createdAt: "2023-01-15T10:00:00Z",
    updatedAt: "2023-06-10T14:30:00Z"
  },
  {
    id: 2,
    name: "Knowledge Base Vector DB",
    type: "pinecone_rag" /* PineconeRAG */,
    isActive: true,
    documents: [
      { id: "kb1", title: "FAQs", chunkCount: 18 },
      { id: "kb2", title: "Support Articles", chunkCount: 45 },
      { id: "kb3", title: "Troubleshooting Guide", chunkCount: 29 }
    ],
    metrics: {
      documentCount: 3,
      totalChunks: 92,
      averageChunkSize: 420,
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
    },
    createdAt: "2023-02-20T09:15:00Z",
    updatedAt: "2023-07-05T11:45:00Z"
  },
  {
    id: 3,
    name: "Code Documentation",
    type: "code_rag" /* CodeRAG */,
    isActive: true,
    documents: [
      { id: "code1", title: "API Documentation", chunkCount: 32 },
      { id: "code2", title: "Library Reference", chunkCount: 47 }
    ],
    metrics: {
      documentCount: 2,
      totalChunks: 79,
      averageChunkSize: 300,
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
    },
    createdAt: "2023-03-10T14:20:00Z",
    updatedAt: "2023-08-01T16:30:00Z"
  },
  {
    id: 4,
    name: "Semantic Search Engine",
    type: "semantic_rag" /* SemanticRAG */,
    isActive: false,
    documents: [],
    metrics: {
      documentCount: 0,
      totalChunks: 0,
      averageChunkSize: 0,
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
    },
    createdAt: "2023-05-05T08:45:00Z",
    updatedAt: "2023-05-05T08:45:00Z"
  },
  {
    id: 5,
    name: "Visual Content Archive",
    type: "multimodal_rag" /* MultimodalRAG */,
    isActive: true,
    documents: [
      { id: "img1", title: "Product Images", chunkCount: 15 },
      { id: "img2", title: "Diagrams & Charts", chunkCount: 22 }
    ],
    metrics: {
      documentCount: 2,
      totalChunks: 37,
      averageChunkSize: 512,
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
    },
    createdAt: "2023-04-15T11:30:00Z",
    updatedAt: "2023-09-10T10:15:00Z"
  }
];
var mockVectorDbs = [
  {
    id: 1,
    name: "Primary Vector Store",
    type: "pgvector",
    isActive: true,
    isDefault: true,
    dimensions: 1536,
    metrics: {
      vectorCount: 125e3,
      avgQueryTime: 42,
      indexType: "HNSW",
      lastOptimized: "2023-06-10T14:30:00Z"
    },
    description: "PostgreSQL vector store using pgvector extension with HNSW indexing"
  },
  {
    id: 2,
    name: "Pinecone Serverless",
    type: "pinecone",
    isActive: true,
    isDefault: false,
    dimensions: 1536,
    metrics: {
      vectorCount: 25e4,
      avgQueryTime: 28,
      indexType: "Approximate Nearest Neighbors",
      lastOptimized: "2023-07-05T11:45:00Z"
    },
    description: "Pinecone serverless vector database with auto-scaling"
  },
  {
    id: 3,
    name: "Multimodal Archive",
    type: "weaviate",
    isActive: true,
    isDefault: false,
    dimensions: 1024,
    metrics: {
      vectorCount: 75e3,
      avgQueryTime: 35,
      indexType: "HNSW",
      lastOptimized: "2023-08-25T16:30:00Z"
    },
    description: "Weaviate vector database optimized for multimodal embeddings"
  },
  {
    id: 4,
    name: "Milvus Cluster",
    type: "milvus",
    isActive: false,
    isDefault: false,
    dimensions: 768,
    metrics: {
      vectorCount: 0,
      avgQueryTime: 0,
      indexType: "IVF_FLAT",
      lastOptimized: "2023-05-05T08:45:00Z"
    },
    description: "Milvus vector database cluster for high throughput applications"
  }
];
var transferOperations = /* @__PURE__ */ new Map();
router13.get("/systems", (req2, res2) => {
  res2.json(mockRagSystems);
});
router13.post("/select", (req2, res2) => {
  try {
    const params2 = req2.body;
    const selectedType = ragSelector.selectRagSystem(params2);
    const selectedSystem = mockRagSystems.find((s) => s.type === selectedType);
    res2.json({
      selected: selectedType,
      system: selectedSystem,
      selectionRules: Object.keys(params2).map((key) => ({
        condition: key,
        value: params2[key]
      })).filter((rule) => rule.value !== void 0),
      recommendedFallbacks: ragSelector.getFallbackRagSystem(selectedType)
    });
  } catch (error) {
    res2.status(500).json({ message: error.message });
  }
});
router13.get("/systems/:id", (req2, res2) => {
  const id = parseInt(req2.params.id);
  const system = mockRagSystems.find((s) => s.id === id);
  if (!system) {
    return res2.status(404).json({ message: "RAG system not found" });
  }
  res2.json(system);
});
router13.get("/vector-dbs", (req2, res2) => {
  res2.json(mockVectorDbs);
});
router13.post("/switch/compatibility", (req2, res2) => {
  try {
    const { sourceType, targetType } = req2.body;
    if (!sourceType || !targetType) {
      return res2.status(400).json({ message: "Source and target types are required" });
    }
    const compatibility = ragDbSwitch.getCompatibilityInfo(
      sourceType,
      targetType
    );
    res2.json(compatibility);
  } catch (error) {
    res2.status(500).json({ message: error.message });
  }
});
router13.post("/switch/recommendations", (req2, res2) => {
  try {
    const { sourceType, targetType, documentCount } = req2.body;
    if (!sourceType || !targetType || !documentCount) {
      return res2.status(400).json({
        message: "Source type, target type, and document count are required"
      });
    }
    const recommendations = ragDbSwitch.getTransferRecommendations(
      sourceType,
      targetType,
      parseInt(documentCount)
    );
    res2.json(recommendations);
  } catch (error) {
    res2.status(500).json({ message: error.message });
  }
});
router13.post("/switch/transfer", async (req2, res2) => {
  try {
    const { sourceId, targetId, documentIds } = req2.body;
    if (!sourceId || !targetId || !documentIds || !documentIds.length) {
      return res2.status(400).json({
        message: "Source ID, target ID, and document IDs are required"
      });
    }
    const result2 = await ragDbSwitch.transferDocuments(
      parseInt(sourceId),
      parseInt(targetId),
      documentIds
    );
    transferOperations.set(result2.operationId, {
      ...result2,
      status: "in_progress",
      progress: 0,
      documentsProcessed: 0,
      totalDocuments: documentIds.length,
      startTime: (/* @__PURE__ */ new Date()).toISOString(),
      errors: [],
      warnings: []
    });
    simulateProgress(result2.operationId);
    res2.json(result2);
  } catch (error) {
    res2.status(500).json({ message: error.message });
  }
});
router13.get("/switch/high-reliability", (req2, res2) => {
  res2.json({
    fallbacks: ragSelector.getHighReliabilityFallbacks()
  });
});
router13.get("/switch/status/:operationId", async (req2, res2) => {
  try {
    const { operationId } = req2.params;
    if (transferOperations.has(operationId)) {
      return res2.json(transferOperations.get(operationId));
    }
    const status = await ragDbSwitch.getTransferStatus(operationId);
    res2.json(status);
  } catch (error) {
    res2.status(500).json({ message: error.message });
  }
});
function simulateProgress(operationId) {
  const operation = transferOperations.get(operationId);
  if (!operation) return;
  let progress = 0;
  const interval = setInterval(() => {
    if (!transferOperations.has(operationId)) {
      clearInterval(interval);
      return;
    }
    const op = transferOperations.get(operationId);
    progress += 5 + Math.random() * 10;
    if (progress > 100) progress = 100;
    op.progress = Math.floor(progress);
    op.documentsProcessed = Math.floor(progress / 100 * op.totalDocuments);
    if (progress > 30 && progress < 35 && op.warnings.length === 0) {
      op.warnings.push("Some metadata fields could not be preserved during transfer");
    }
    const shouldFail = operationId.includes("7") && progress > 75;
    if (shouldFail) {
      op.status = "failed";
      op.errors.push("Connection to target database lost during transfer");
      op.endTime = (/* @__PURE__ */ new Date()).toISOString();
      clearInterval(interval);
    } else if (progress >= 100) {
      op.status = "completed";
      op.progress = 100;
      op.documentsProcessed = op.totalDocuments;
      op.endTime = (/* @__PURE__ */ new Date()).toISOString();
      clearInterval(interval);
    }
    transferOperations.set(operationId, op);
  }, 1e3);
}
var rag_routes_default = router13;

// server/routes/rag-import-routes.ts
import { Router as Router11 } from "express";
import multer from "multer";
import { v4 as uuidv47 } from "uuid";
import fs5 from "fs";
var router14 = Router11();
var upload = multer({ dest: "uploads/" });
var importOperations = /* @__PURE__ */ new Map();
router14.get("/import/file-types", (req2, res2) => {
  res2.json([
    {
      type: "pdf",
      name: "PDF Document",
      maxSize: 25 * 1024 * 1024,
      // 25MB
      supportedExtensions: [".pdf"],
      description: "Portable Document Format files. Supports text, tables, and images.",
      ocrSupported: true
    },
    {
      type: "docx",
      name: "Word Document",
      maxSize: 20 * 1024 * 1024,
      // 20MB
      supportedExtensions: [".docx", ".doc"],
      description: "Microsoft Word documents.",
      ocrSupported: false
    },
    {
      type: "txt",
      name: "Text File",
      maxSize: 5 * 1024 * 1024,
      // 5MB
      supportedExtensions: [".txt", ".md", ".csv"],
      description: "Plain text files. Most efficient for text-based RAG.",
      ocrSupported: false
    },
    {
      type: "html",
      name: "HTML Document",
      maxSize: 10 * 1024 * 1024,
      // 10MB
      supportedExtensions: [".html", ".htm"],
      description: "Web pages and HTML content.",
      ocrSupported: false
    },
    {
      type: "image",
      name: "Image",
      maxSize: 15 * 1024 * 1024,
      // 15MB
      supportedExtensions: [".jpg", ".jpeg", ".png", ".webp"],
      description: "Image files. Requires OCR or multimodal RAG.",
      ocrSupported: true
    },
    {
      type: "json",
      name: "JSON Data",
      maxSize: 15 * 1024 * 1024,
      // 15MB
      supportedExtensions: [".json"],
      description: "Structured data in JSON format.",
      ocrSupported: false
    },
    {
      type: "xml",
      name: "XML Data",
      maxSize: 15 * 1024 * 1024,
      // 15MB
      supportedExtensions: [".xml"],
      description: "Structured data in XML format.",
      ocrSupported: false
    }
  ]);
});
router14.get("/import/external-sources", (req2, res2) => {
  res2.json([
    {
      id: "web",
      name: "Web URL",
      description: "Import content from a specific URL or website",
      configOptions: [
        { name: "url", type: "string", required: true, description: "The URL to crawl" },
        { name: "maxPages", type: "number", required: false, description: "Maximum number of pages to crawl" },
        { name: "crawlDepth", type: "number", required: false, description: "How deep to crawl from the starting URL" }
      ],
      authRequired: false
    },
    {
      id: "gdrive",
      name: "Google Drive",
      description: "Import documents from Google Drive",
      configOptions: [
        { name: "folderId", type: "string", required: false, description: "Optional folder ID to import from" }
      ],
      authRequired: true,
      authType: "oauth"
    },
    {
      id: "confluence",
      name: "Confluence",
      description: "Import content from Confluence workspace",
      configOptions: [
        { name: "domain", type: "string", required: true, description: "Your Confluence domain" },
        { name: "spaceKey", type: "string", required: false, description: "Optional space key to limit import scope" }
      ],
      authRequired: true,
      authType: "api_key"
    },
    {
      id: "sharepoint",
      name: "SharePoint",
      description: "Import documents from Microsoft SharePoint",
      configOptions: [
        { name: "siteUrl", type: "string", required: true, description: "SharePoint site URL" },
        { name: "libraryName", type: "string", required: false, description: "Document library name" }
      ],
      authRequired: true,
      authType: "oauth"
    },
    {
      id: "github",
      name: "GitHub Repository",
      description: "Import code and documentation from GitHub",
      configOptions: [
        { name: "repoUrl", type: "string", required: true, description: "GitHub repository URL" },
        { name: "branch", type: "string", required: false, description: "Branch to import (defaults to main)" },
        { name: "fileTypes", type: "array", required: false, description: "File extensions to include" }
      ],
      authRequired: true,
      authType: "oauth"
    },
    {
      id: "notion",
      name: "Notion",
      description: "Import content from Notion workspace",
      configOptions: [
        { name: "databaseId", type: "string", required: false, description: "Optional database ID to import" }
      ],
      authRequired: true,
      authType: "api_key"
    }
  ]);
});
router14.post("/import/upload", upload.single("file"), (req2, res2) => {
  try {
    if (!req2.file) {
      return res2.status(400).json({ message: "No file uploaded" });
    }
    const { originalname, path: filePath, size, mimetype } = req2.file;
    const { targetSystemId, chunkSize, overlapSize, metadata } = req2.body;
    if (!targetSystemId) {
      fs5.unlinkSync(filePath);
      return res2.status(400).json({ message: "Target RAG system ID is required" });
    }
    const operationId = uuidv47();
    const operation = {
      operationId,
      originalFilename: originalname,
      filePath,
      fileSize: size,
      mimeType: mimetype,
      targetSystemId: parseInt(targetSystemId),
      metadata: metadata ? JSON.parse(metadata) : {},
      status: "queued",
      progress: 0,
      chunksCreated: 0,
      documentsProcessed: 0,
      totalDocuments: 1,
      // For file upload, it's just 1 document
      startTime: (/* @__PURE__ */ new Date()).toISOString(),
      errors: [],
      warnings: []
    };
    importOperations.set(operationId, operation);
    setTimeout(() => {
      simulateImportProgress(operationId, 1);
    }, 1e3);
    res2.json({
      operationId,
      status: "queued",
      fileName: originalname,
      fileSize: size,
      targetSystem: targetSystemId
    });
  } catch (error) {
    if (req2.file?.path) {
      fs5.unlinkSync(req2.file.path);
    }
    res2.status(500).json({ message: error.message });
  }
});
router14.post("/import/external", (req2, res2) => {
  try {
    const { sourceType, sourceConfig, targetSystemId, options: options2 } = req2.body;
    if (!sourceType || !targetSystemId) {
      return res2.status(400).json({
        message: "Source type and target system ID are required"
      });
    }
    const operationId = uuidv47();
    let estimatedDocuments = 1;
    switch (sourceType) {
      case "web":
        estimatedDocuments = sourceConfig.maxPages || 5;
        break;
      case "gdrive":
      case "sharepoint":
      case "confluence":
      case "notion":
        estimatedDocuments = 10;
        break;
      case "github":
        estimatedDocuments = 20;
        break;
    }
    const operation = {
      operationId,
      sourceType,
      sourceConfig,
      targetSystemId: parseInt(targetSystemId),
      options: options2 || {},
      status: "queued",
      progress: 0,
      chunksCreated: 0,
      documentsProcessed: 0,
      totalDocuments: estimatedDocuments,
      startTime: (/* @__PURE__ */ new Date()).toISOString(),
      errors: [],
      warnings: []
    };
    importOperations.set(operationId, operation);
    setTimeout(() => {
      simulateImportProgress(operationId, estimatedDocuments);
    }, 1e3);
    res2.json({
      operationId,
      status: "queued",
      sourceType,
      targetSystem: targetSystemId,
      estimatedDocuments
    });
  } catch (error) {
    res2.status(500).json({ message: error.message });
  }
});
router14.get("/import/status/:operationId", (req2, res2) => {
  try {
    const { operationId } = req2.params;
    if (!importOperations.has(operationId)) {
      return res2.status(404).json({ message: "Import operation not found" });
    }
    const operation = importOperations.get(operationId);
    res2.json(operation);
  } catch (error) {
    res2.status(500).json({ message: error.message });
  }
});
router14.post("/import/cancel/:operationId", (req2, res2) => {
  try {
    const { operationId } = req2.params;
    if (!importOperations.has(operationId)) {
      return res2.status(404).json({ message: "Import operation not found" });
    }
    const operation = importOperations.get(operationId);
    if (operation.status === "completed" || operation.status === "failed") {
      return res2.status(400).json({
        message: `Cannot cancel operation with status: ${operation.status}`
      });
    }
    operation.status = "cancelled";
    operation.endTime = (/* @__PURE__ */ new Date()).toISOString();
    importOperations.set(operationId, operation);
    if (operation.filePath && fs5.existsSync(operation.filePath)) {
      fs5.unlinkSync(operation.filePath);
    }
    res2.json({
      operationId,
      status: "cancelled",
      message: "Import operation cancelled successfully"
    });
  } catch (error) {
    res2.status(500).json({ message: error.message });
  }
});
router14.get("/import/operations", (req2, res2) => {
  try {
    const operations = Array.from(importOperations.values()).filter(
      (op) => op.status === "queued" || op.status === "processing"
    );
    res2.json(operations);
  } catch (error) {
    res2.status(500).json({ message: error.message });
  }
});
function simulateImportProgress(operationId, totalDocuments) {
  const operation = importOperations.get(operationId);
  if (!operation) return;
  operation.status = "processing";
  importOperations.set(operationId, operation);
  let progress = 0;
  const interval = setInterval(() => {
    if (!importOperations.has(operationId)) {
      clearInterval(interval);
      return;
    }
    const op = importOperations.get(operationId);
    if (op.status === "cancelled") {
      clearInterval(interval);
      return;
    }
    progress += 5 + Math.random() * 10;
    if (progress > 100) progress = 100;
    op.progress = Math.floor(progress);
    op.documentsProcessed = Math.floor(progress / 100 * totalDocuments);
    op.chunksCreated = Math.floor(op.documentsProcessed * (3 + Math.random() * 5));
    if (progress > 40 && progress < 45 && op.warnings.length === 0) {
      op.warnings.push("Some documents contain special formatting that may not be preserved");
    }
    const shouldFail = operationId.includes("error") || operationId.includes("5") && progress > 70;
    if (shouldFail) {
      op.status = "failed";
      op.errors.push("Failed to process document: invalid format or corrupted content");
      op.endTime = (/* @__PURE__ */ new Date()).toISOString();
      clearInterval(interval);
    } else if (progress >= 100) {
      op.status = "completed";
      op.progress = 100;
      op.documentsProcessed = totalDocuments;
      op.endTime = (/* @__PURE__ */ new Date()).toISOString();
      clearInterval(interval);
    }
    importOperations.set(operationId, op);
  }, 1e3);
}
var rag_import_routes_default = router14;

// server/routes/activity-log-routes.ts
import { Router as Router12 } from "express";
var router15 = Router12();
var isAuthenticated6 = (req2, res2, next) => {
  if (!req2.isAuthenticated()) {
    return res2.status(401).json({ message: "Unauthorized" });
  }
  next();
};
var isAdmin = (req2, res2, next) => {
  if (!req2.isAuthenticated() || req2.user?.role !== "admin") {
    return res2.status(403).json({ message: "Forbidden" });
  }
  next();
};
router15.get("/api/activity-logs", isAdmin, async (req2, res2) => {
  try {
    const {
      userId,
      level,
      action,
      entityType,
      entityId,
      from,
      to,
      limit = "100",
      offset = "0"
    } = req2.query;
    const logs = await activityLogger.getActivityLogs({
      userId: userId ? parseInt(userId) : void 0,
      level,
      action,
      entityType,
      entityId,
      startDate: from ? new Date(from) : void 0,
      endDate: to ? new Date(to) : void 0,
      limit: parseInt(limit),
      offset: parseInt(offset)
    });
    res2.status(200).json(logs);
  } catch (error) {
    logError(
      "get_activity_logs_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error retrieving activity logs",
      error: error.message
    });
  }
});
router15.get("/api/my-activity", isAuthenticated6, async (req2, res2) => {
  try {
    const { limit = "10" } = req2.query;
    const logs = await activityLogger.getUserActivity(
      req2.user.id,
      parseInt(limit)
    );
    res2.status(200).json(logs);
  } catch (error) {
    logError(
      "get_user_activity_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error retrieving your activity logs",
      error: error.message
    });
  }
});
router15.get("/api/entity-activity/:type/:id", isAuthenticated6, async (req2, res2) => {
  try {
    const { type, id } = req2.params;
    const { limit = "10" } = req2.query;
    const entityType = type;
    if (entityType === "system" /* System */ && req2.user?.role !== "admin") {
      return res2.status(403).json({ message: "Forbidden" });
    }
    const logs = await activityLogger.getEntityActivity(
      entityType,
      id,
      parseInt(limit)
    );
    res2.status(200).json(logs);
  } catch (error) {
    logError(
      "get_entity_activity_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error retrieving entity activity logs",
      error: error.message
    });
  }
});
router15.get("/api/system-activity", isAdmin, async (req2, res2) => {
  try {
    const { limit = "20" } = req2.query;
    const logs = await activityLogger.getSystemActivity(parseInt(limit));
    res2.status(200).json(logs);
  } catch (error) {
    logError(
      "get_system_activity_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error retrieving system activity logs",
      error: error.message
    });
  }
});
router15.get("/api/error-logs", isAdmin, async (req2, res2) => {
  try {
    const { limit = "50" } = req2.query;
    const logs = await activityLogger.getErrorLogs(parseInt(limit));
    res2.status(200).json(logs);
  } catch (error) {
    logError(
      "get_error_logs_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error retrieving error logs",
      error: error.message
    });
  }
});
var activity_log_routes_default = router15;

// server/routes/user-preferences-routes.ts
import { Router as Router13 } from "express";

// server/services/user-preferences/index.ts
import { eq as eq20 } from "drizzle-orm";
var DEFAULT_USER_PREFERENCES = {
  theme: "system",
  // 'light', 'dark', 'system'
  uiDensity: "comfortable",
  // 'comfortable', 'compact', 'spacious'
  timezone: "UTC",
  dateFormat: "MM/DD/YYYY",
  defaultLanguage: "en",
  aiSettings: {
    defaultModel: "gpt-4-turbo",
    temperature: 0.7,
    maxTokens: 2e3,
    showReasoning: true,
    defaultTools: ["web-search", "calculator"]
  },
  notificationSettings: {
    email: true,
    browser: true,
    desktop: false,
    mobile: false,
    executionCompleted: true,
    executionFailed: true,
    systemAlerts: true,
    marketingMessages: false
  },
  customization: {
    accentColor: "#6366f1",
    // default indigo accent
    fontFamily: "Inter",
    fontSize: "medium",
    borderRadius: "medium",
    dashboardLayout: "grid"
  }
};
var UserPreferencesService = class {
  // Track connected devices/browsers for each user
  connectedDevices = /* @__PURE__ */ new Map();
  /**
   * Register a device or browser for preference sync
   */
  registerSyncTarget(userId, target) {
    if (!this.connectedDevices.has(userId)) {
      this.connectedDevices.set(userId, []);
    }
    const devices = this.connectedDevices.get(userId);
    const existingDeviceIndex = devices.findIndex(
      (d) => d.type === target.type && d.identifier === target.identifier
    );
    if (existingDeviceIndex >= 0) {
      devices[existingDeviceIndex] = {
        ...target,
        lastSyncTime: /* @__PURE__ */ new Date()
      };
    } else {
      devices.push({
        ...target,
        lastSyncTime: /* @__PURE__ */ new Date()
      });
    }
    activityLogger.logActivity({
      level: "info" /* Info */,
      action: "register_sync_device",
      entityType: "user" /* User */,
      entityId: userId.toString(),
      details: { target }
    });
  }
  /**
   * Get all registered sync targets for a user
   */
  getSyncTargets(userId) {
    return this.connectedDevices.get(userId) || [];
  }
  /**
   * Unregister a sync target
   */
  unregisterSyncTarget(userId, targetIdentifier) {
    if (!this.connectedDevices.has(userId)) {
      return false;
    }
    const devices = this.connectedDevices.get(userId);
    const initialLength = devices.length;
    this.connectedDevices.set(
      userId,
      devices.filter((d) => d.identifier !== targetIdentifier)
    );
    const removed = this.connectedDevices.get(userId).length < initialLength;
    if (removed) {
      activityLogger.logActivity({
        level: "info" /* Info */,
        action: "unregister_sync_device",
        entityType: "user" /* User */,
        entityId: userId.toString(),
        details: { targetIdentifier }
      });
    }
    return removed;
  }
  /**
   * Synchronize preferences across devices
   */
  async syncPreferences(userId, sourceIdentifier, targetIdentifier, preferenceGroups = ["ui", "notifications", "ai-settings", "workflows"], conflictResolution = "newest") {
    try {
      const preferences = await this.getUserPreferences(userId);
      if (!preferences) {
        return {
          success: false,
          syncedAt: /* @__PURE__ */ new Date(),
          syncedPreferenceGroups: [],
          syncedKeys: []
        };
      }
      const devices = this.connectedDevices.get(userId) || [];
      const sourceDevice = devices.find((d) => d.identifier === sourceIdentifier);
      if (!sourceDevice) {
        this.registerSyncTarget(userId, {
          type: "browser",
          identifier: sourceIdentifier,
          name: `Unknown Device (${sourceIdentifier.substring(0, 8)})`
        });
      }
      const targetDevices = targetIdentifier === "all" ? devices.filter((d) => d.identifier !== sourceIdentifier) : devices.filter((d) => d.identifier === targetIdentifier);
      if (targetDevices.length === 0) {
        return {
          success: false,
          syncedAt: /* @__PURE__ */ new Date(),
          syncedPreferenceGroups: [],
          syncedKeys: []
        };
      }
      const syncedKeys = [];
      if (preferenceGroups.includes("ui")) {
        syncedKeys.push("theme", "uiDensity", "customization");
      }
      if (preferenceGroups.includes("notifications")) {
        syncedKeys.push("notificationSettings");
      }
      if (preferenceGroups.includes("ai-settings")) {
        syncedKeys.push("aiSettings");
      }
      if (preferenceGroups.includes("workflows")) {
        syncedKeys.push("defaultWorkflowSettings");
      }
      const now = /* @__PURE__ */ new Date();
      devices.forEach((device) => {
        if (device.identifier === sourceIdentifier || targetDevices.some((t) => t.identifier === device.identifier)) {
          device.lastSyncTime = now;
        }
      });
      activityLogger.logActivity({
        level: "info" /* Info */,
        action: "sync_preferences",
        entityType: "user" /* User */,
        entityId: userId.toString(),
        details: {
          sourceIdentifier,
          targetIdentifier,
          preferenceGroups,
          syncedKeys,
          syncedAt: now
        }
      });
      return {
        success: true,
        syncedAt: now,
        syncedPreferenceGroups: preferenceGroups,
        syncedKeys
      };
    } catch (error) {
      activityLogger.logActivity({
        level: "error" /* Error */,
        action: "sync_preferences_error",
        entityType: "user" /* User */,
        entityId: userId.toString(),
        details: { error: String(error) }
      });
      return {
        success: false,
        syncedAt: /* @__PURE__ */ new Date(),
        syncedPreferenceGroups: [],
        syncedKeys: []
      };
    }
  }
  /**
   * Get user preferences
   */
  async getUserPreferences(userId) {
    try {
      const [preferences] = await db.select().from(userPreferences).where(eq20(userPreferences.userId, userId));
      return preferences || null;
    } catch (error) {
      activityLogger.logActivity({
        level: "error" /* Error */,
        action: "get_user_preferences",
        entityType: "user" /* User */,
        entityId: userId.toString(),
        details: { error: String(error) }
      });
      return null;
    }
  }
  /**
   * Create or update user preferences
   */
  async saveUserPreferences(userId, preferences) {
    try {
      const existingPrefs = await this.getUserPreferences(userId);
      if (existingPrefs) {
        const [updatedPrefs] = await db.update(userPreferences).set({
          ...preferences,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq20(userPreferences.id, existingPrefs.id)).returning();
        activityLogger.logActivity({
          level: "info" /* Info */,
          action: "update_user_preferences",
          userId,
          entityType: "user" /* User */,
          entityId: userId.toString(),
          details: { updated: Object.keys(preferences) }
        });
        return updatedPrefs;
      }
      const newPrefs = {
        userId,
        ...DEFAULT_USER_PREFERENCES,
        ...preferences,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      };
      const [createdPrefs] = await db.insert(userPreferences).values(newPrefs).returning();
      activityLogger.logActivity({
        level: "info" /* Info */,
        action: "create_user_preferences",
        userId,
        entityType: "user" /* User */,
        entityId: userId.toString()
      });
      return createdPrefs;
    } catch (error) {
      activityLogger.logActivity({
        level: "error" /* Error */,
        action: "save_user_preferences",
        userId,
        entityType: "user" /* User */,
        entityId: userId.toString(),
        details: { error: String(error) }
      });
      throw error;
    }
  }
  /**
   * Update specific user preference field
   */
  async updatePreference(userId, key, value) {
    const existingPrefs = await this.getUserPreferences(userId);
    if (!existingPrefs) {
      const newPrefs = { ...DEFAULT_USER_PREFERENCES };
      if (key.includes(".")) {
        const [category, subKey] = key.split(".");
        newPrefs[category] = {
          ...newPrefs[category],
          [subKey]: value
        };
      } else {
        newPrefs[key] = value;
      }
      return this.saveUserPreferences(userId, newPrefs);
    }
    if (key.includes(".")) {
      const [category, subKey] = key.split(".");
      const currentCategory = existingPrefs[category] || {};
      return this.saveUserPreferences(userId, {
        [category]: {
          ...currentCategory,
          [subKey]: value
        }
      });
    }
    return this.saveUserPreferences(userId, {
      [key]: value
    });
  }
  /**
   * Reset user preferences to defaults
   */
  async resetPreferences(userId) {
    const existingPrefs = await this.getUserPreferences(userId);
    if (existingPrefs) {
      const [resetPrefs] = await db.update(userPreferences).set({
        ...DEFAULT_USER_PREFERENCES,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq20(userPreferences.id, existingPrefs.id)).returning();
      activityLogger.logActivity({
        level: "info" /* Info */,
        action: "reset_user_preferences",
        userId,
        entityType: "user" /* User */,
        entityId: userId.toString()
      });
      return resetPrefs;
    }
    return this.saveUserPreferences(userId, DEFAULT_USER_PREFERENCES);
  }
  /**
   * Get a specific preference value
   */
  async getPreference(userId, key, defaultValue) {
    const prefs = await this.getUserPreferences(userId);
    if (!prefs) {
      return defaultValue;
    }
    if (key.includes(".")) {
      const [category, subKey] = key.split(".");
      const categoryObj = prefs[category];
      if (!categoryObj) {
        return defaultValue;
      }
      return categoryObj[subKey] ?? defaultValue;
    }
    return prefs[key] ?? defaultValue;
  }
};
var userPreferencesService = new UserPreferencesService();

// server/routes/user-preferences-routes.ts
import { z as z8 } from "zod";
var router16 = Router13();
var isAuthenticated7 = (req2, res2, next) => {
  if (!req2.isAuthenticated()) {
    return res2.status(401).json({ message: "Unauthorized" });
  }
  next();
};
router16.get("/api/user/preferences", isAuthenticated7, async (req2, res2) => {
  try {
    const preferences = await userPreferencesService.getUserPreferences(req2.user.id);
    if (!preferences) {
      return res2.status(200).json(DEFAULT_USER_PREFERENCES);
    }
    res2.status(200).json(preferences);
  } catch (error) {
    logError(
      "get_user_preferences_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error retrieving user preferences",
      error: error.message
    });
  }
});
router16.post("/api/user/preferences", isAuthenticated7, async (req2, res2) => {
  try {
    const preferences = req2.body;
    const savedPreferences = await userPreferencesService.saveUserPreferences(
      req2.user.id,
      preferences
    );
    res2.status(200).json(savedPreferences);
  } catch (error) {
    logError(
      "save_user_preferences_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error saving user preferences",
      error: error.message
    });
  }
});
var updatePreferenceSchema = z8.object({
  key: z8.string().min(1, "Preference key is required"),
  value: z8.any()
});
router16.patch("/api/user/preferences", isAuthenticated7, async (req2, res2) => {
  try {
    const validation = updatePreferenceSchema.safeParse(req2.body);
    if (!validation.success) {
      return res2.status(400).json({
        message: "Invalid request",
        errors: validation.error.flatten().fieldErrors
      });
    }
    const { key, value } = validation.data;
    const updatedPreferences = await userPreferencesService.updatePreference(
      req2.user.id,
      key,
      value
    );
    res2.status(200).json(updatedPreferences);
  } catch (error) {
    logError(
      "update_preference_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error updating preference",
      error: error.message
    });
  }
});
router16.post("/api/user/preferences/reset", isAuthenticated7, async (req2, res2) => {
  try {
    const resetPreferences = await userPreferencesService.resetPreferences(
      req2.user.id
    );
    res2.status(200).json(resetPreferences);
  } catch (error) {
    logError(
      "reset_preferences_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error resetting preferences",
      error: error.message
    });
  }
});
router16.get("/api/user/preferences/:key", isAuthenticated7, async (req2, res2) => {
  try {
    const { key } = req2.params;
    const { default: defaultValue } = req2.query;
    const parsedDefault = defaultValue ? JSON.parse(defaultValue) : void 0;
    const value = await userPreferencesService.getPreference(
      req2.user.id,
      key,
      parsedDefault
    );
    res2.status(200).json({ key, value });
  } catch (error) {
    logError(
      "get_preference_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error retrieving preference",
      error: error.message
    });
  }
});
var syncTargetSchema = z8.object({
  type: z8.enum(["browser", "device", "account"]),
  identifier: z8.string().min(1, "Device identifier is required"),
  name: z8.string().min(1, "Device name is required")
});
router16.post("/api/user/preferences/sync/register", isAuthenticated7, async (req2, res2) => {
  try {
    const validation = syncTargetSchema.safeParse(req2.body);
    if (!validation.success) {
      return res2.status(400).json({
        message: "Invalid request",
        errors: validation.error.flatten().fieldErrors
      });
    }
    const target = validation.data;
    userPreferencesService.registerSyncTarget(
      req2.user.id,
      target
    );
    res2.status(200).json({
      message: "Sync target registered successfully",
      target
    });
  } catch (error) {
    logError(
      "register_sync_target_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error registering sync target",
      error: error.message
    });
  }
});
router16.get("/api/user/preferences/sync/targets", isAuthenticated7, (req2, res2) => {
  try {
    const targets = userPreferencesService.getSyncTargets(req2.user.id);
    res2.status(200).json(targets);
  } catch (error) {
    logError(
      "get_sync_targets_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error retrieving sync targets",
      error: error.message
    });
  }
});
router16.delete("/api/user/preferences/sync/targets/:identifier", isAuthenticated7, (req2, res2) => {
  try {
    const { identifier } = req2.params;
    const success = userPreferencesService.unregisterSyncTarget(
      req2.user.id,
      identifier
    );
    if (!success) {
      return res2.status(404).json({
        message: "Sync target not found"
      });
    }
    res2.status(200).json({
      message: "Sync target unregistered successfully"
    });
  } catch (error) {
    logError(
      "unregister_sync_target_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error unregistering sync target",
      error: error.message
    });
  }
});
var syncPreferencesSchema = z8.object({
  sourceIdentifier: z8.string().min(1, "Source identifier is required"),
  targetIdentifier: z8.string().min(1, "Target identifier is required"),
  preferenceGroups: z8.array(z8.string()).optional(),
  conflictResolution: z8.enum(["newest", "oldest", "source", "target"]).optional()
});
router16.post("/api/user/preferences/sync", isAuthenticated7, async (req2, res2) => {
  try {
    const validation = syncPreferencesSchema.safeParse(req2.body);
    if (!validation.success) {
      return res2.status(400).json({
        message: "Invalid request",
        errors: validation.error.flatten().fieldErrors
      });
    }
    const {
      sourceIdentifier,
      targetIdentifier,
      preferenceGroups,
      conflictResolution
    } = validation.data;
    const result2 = await userPreferencesService.syncPreferences(
      req2.user.id,
      sourceIdentifier,
      targetIdentifier,
      preferenceGroups,
      conflictResolution
    );
    res2.status(200).json(result2);
  } catch (error) {
    logError(
      "sync_preferences_error",
      error,
      req2.user?.id,
      void 0,
      void 0,
      req2
    );
    res2.status(500).json({
      message: "Error synchronizing preferences",
      error: error.message
    });
  }
});
var user_preferences_routes_default = router16;

// server/routes/runtime-routes.ts
import express5 from "express";
import { z as z9 } from "zod";

// server/services/runtime/runtimes/BaseRuntime.ts
var BaseRuntime = class {
  name;
  capabilities;
  constructor(name) {
    this.name = name;
    this.capabilities = this.getDefaultCapabilities();
    log(`Initializing ${name} runtime`, "runtime");
  }
  /**
   * Get the capabilities of this runtime
   */
  getCapabilities() {
    return this.capabilities;
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    log(`Cleaning up ${this.name} runtime`, "runtime");
  }
  /**
   * Helper to measure execution time of a function
   */
  async measureExecutionTime(fn) {
    const startTime2 = Date.now();
    try {
      const result2 = await fn();
      const executionTime = Date.now() - startTime2;
      return {
        result: result2,
        executionTime
      };
    } catch (error) {
      const executionTime = Date.now() - startTime2;
      if (error instanceof Error) {
        throw Object.assign(error, { executionTime });
      } else {
        throw new Error(`${error}`, { cause: { executionTime } });
      }
    }
  }
  /**
   * Helper to create a successful execution result
   */
  createSuccessResult(output, executionTime, memoryUsage) {
    return {
      success: true,
      output,
      executionTime,
      memoryUsage
    };
  }
  /**
   * Helper to create an error execution result
   */
  createErrorResult(error, executionTime, memoryUsage) {
    return {
      success: false,
      output: "",
      error,
      executionTime,
      memoryUsage
    };
  }
};

// server/services/runtime/runtimes/OpenInterpreterRuntime.ts
var OpenInterpreterRuntime = class extends BaseRuntime {
  constructor() {
    super("open_interpreter");
    log("OpenInterpreter Runtime initialized", "runtime");
  }
  /**
   * Execute code using OpenInterpreter
   */
  async execute(code, config) {
    try {
      const { result: result2, executionTime } = await this.measureExecutionTime(async () => {
        const language = config?.options?.language || "python";
        const output = this.simulateOutput(code, language);
        return output;
      });
      const memoryUsage = Math.round(Math.random() * 100);
      return this.createSuccessResult(result2, executionTime, memoryUsage);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      log(`OpenInterpreter execution error: ${errorMessage}`, "runtime");
      return this.createErrorResult(errorMessage, 0);
    }
  }
  /**
   * Get default capabilities for OpenInterpreter runtime
   */
  getDefaultCapabilities() {
    return {
      supportedLanguages: ["python", "javascript", "typescript", "shell", "r", "html", "css"],
      persistence: true,
      sandboxed: false,
      maxExecutionTime: 6e4,
      // 60 seconds
      maxMemory: 1024,
      // 1 GB
      supportsPackages: true,
      supportedPackageManagers: ["pip", "npm", "apt"],
      supportsStreaming: true,
      supportsFileIO: true,
      supportsNetworkAccess: true,
      supportsConcurrency: false
    };
  }
  /**
   * Simulate interpreter output based on language
   * This is a placeholder until we integrate with the actual OpenInterpreter
   */
  simulateOutput(code, language) {
    let output = "";
    switch (language.toLowerCase()) {
      case "python":
        if (code.includes("print")) {
          const match = code.match(/print\s*\((.*?)\)/);
          if (match && match[1]) {
            output = match[1].replace(/['"]/g, "") + "\n";
          }
        } else if (code.includes("import")) {
          output = "Module imported successfully\n";
        } else {
          output = "Python code executed with no output\n";
        }
        break;
      case "javascript":
      case "typescript":
        if (code.includes("console.log")) {
          const match = code.match(/console\.log\s*\((.*?)\)/);
          if (match && match[1]) {
            output = match[1].replace(/['"]/g, "") + "\n";
          }
        } else {
          output = "JavaScript code executed with no output\n";
        }
        break;
      case "shell":
        if (code.includes("echo")) {
          const match = code.match(/echo\s+(.*?)($|\n)/);
          if (match && match[1]) {
            output = match[1] + "\n";
          }
        } else if (code.includes("ls")) {
          output = "file1.txt\nfile2.txt\ndirectory1/\n";
        } else {
          output = "Command executed successfully\n";
        }
        break;
      case "r":
        if (code.includes("print")) {
          const match = code.match(/print\s*\((.*?)\)/);
          if (match && match[1]) {
            output = "[1] " + match[1].replace(/['"]/g, "") + "\n";
          }
        } else {
          output = "R code executed with no output\n";
        }
        break;
      case "html":
        output = "HTML rendered successfully\n";
        break;
      case "css":
        output = "CSS applied successfully\n";
        break;
      default:
        output = `Code executed in ${language} interpreter
`;
    }
    return output;
  }
};

// server/services/runtime/runtimes/E2BRuntime.ts
import { VM, VMScript } from "vm2";
var E2BRuntime = class extends BaseRuntime {
  constructor() {
    super("e2b");
    log("E2B Runtime initialized", "runtime");
  }
  /**
   * Execute JavaScript/TypeScript/Node.js code in a sandbox
   */
  async execute(code, config) {
    try {
      const { result: result2, executionTime } = await this.measureExecutionTime(async () => {
        const timeout = config?.timeout || 5e3;
        const sandbox = this.createSandbox(config);
        const vm = new VM({
          timeout,
          sandbox,
          eval: false,
          wasm: false
        });
        const wrappedCode = `
          let __output = '';
          const originalConsoleLog = console.log;
          console.log = function(...args) {
            __output += args.map(a => String(a)).join(' ') + '\\n';
            originalConsoleLog.apply(console, args);
          };
          
          try {
            ${code}
          } catch (error) {
            __output += '\\nError: ' + error.message;
          }
          
          __output;
        `;
        const script = new VMScript(wrappedCode);
        const output = vm.run(script);
        return output;
      });
      const memoryUsage = Math.round(code.length * 0.1);
      return this.createSuccessResult(result2, executionTime, memoryUsage);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      log(`E2B runtime execution error: ${errorMessage}`, "runtime");
      return this.createErrorResult(errorMessage, 0);
    }
  }
  /**
   * Create a sandbox environment for VM execution
   */
  createSandbox(config) {
    return {
      console,
      setTimeout,
      clearTimeout,
      setInterval,
      clearInterval,
      process: {
        env: {}
      },
      Math,
      Date,
      JSON,
      Array,
      Object,
      String,
      RegExp,
      Map,
      Set,
      WeakMap,
      WeakSet,
      Error,
      Buffer: {
        from: (str, encoding) => Buffer.from(str, encoding),
        isBuffer: (obj) => Buffer.isBuffer(obj)
      },
      // Add any custom context from the config
      ...config?.options?.context
    };
  }
  /**
   * Get default capabilities for E2B runtime
   */
  getDefaultCapabilities() {
    return {
      supportedLanguages: ["javascript", "typescript", "nodejs"],
      persistence: false,
      sandboxed: true,
      maxExecutionTime: 5e3,
      // 5 seconds
      maxMemory: 128,
      // 128 MB
      supportsPackages: false,
      supportedPackageManagers: [],
      supportsStreaming: false,
      supportsFileIO: false,
      supportsNetworkAccess: false,
      supportsConcurrency: true,
      maxConcurrentExecutions: 10
    };
  }
  /**
   * Clean up resources
   */
  async cleanup() {
    await super.cleanup();
  }
};

// server/services/runtime/runtimes/StubRuntimes.ts
var WasmEdgeRuntime = class extends BaseRuntime {
  constructor() {
    super("wasm_edge");
    log("WasmEdge Runtime initialized (stub)", "runtime");
  }
  async execute(code, config) {
    try {
      const { result: result2, executionTime } = await this.measureExecutionTime(async () => {
        const language = config?.options?.language || "rust";
        return `[WasmEdge Runtime Stub] Executed ${language} code:
${code.substring(0, 100)}${code.length > 100 ? "..." : ""}

Simulated result: Success`;
      });
      return this.createSuccessResult(result2, executionTime, 40);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return this.createErrorResult(errorMessage, 0);
    }
  }
  getDefaultCapabilities() {
    return {
      supportedLanguages: ["rust", "c", "cpp", "assemblyscript", "go", "javascript"],
      persistence: false,
      sandboxed: true,
      maxExecutionTime: 1e4,
      // 10 seconds
      maxMemory: 512,
      // 512 MB
      supportsPackages: true,
      supportedPackageManagers: ["cargo", "npm"],
      supportsStreaming: false,
      supportsFileIO: false,
      supportsNetworkAccess: false,
      supportsConcurrency: true,
      maxConcurrentExecutions: 5
    };
  }
};
var BacalhauRuntime = class extends BaseRuntime {
  constructor() {
    super("bacalhau");
    log("Bacalhau Runtime initialized (stub)", "runtime");
  }
  async execute(code, config) {
    try {
      const { result: result2, executionTime } = await this.measureExecutionTime(async () => {
        const language = config?.options?.language || "python";
        return `[Bacalhau Runtime Stub] Executed ${language} code with distributed compute:
${code.substring(0, 100)}${code.length > 100 ? "..." : ""}

Simulated distributed execution result: Success`;
      });
      return this.createSuccessResult(result2, executionTime, 128);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return this.createErrorResult(errorMessage, 0);
    }
  }
  getDefaultCapabilities() {
    return {
      supportedLanguages: ["python", "r", "julia", "bash", "javascript"],
      persistence: true,
      sandboxed: true,
      maxExecutionTime: 3e5,
      // 5 minutes
      maxMemory: 4096,
      // 4 GB
      supportsPackages: true,
      supportedPackageManagers: ["pip", "npm", "apt"],
      supportsStreaming: true,
      supportsFileIO: true,
      supportsNetworkAccess: true,
      supportsConcurrency: true,
      maxConcurrentExecutions: 10
    };
  }
};
var ClineNodeRuntime = class extends BaseRuntime {
  constructor() {
    super("cline_node");
    log("Cline Node Runtime initialized (stub)", "runtime");
  }
  async execute(code, config) {
    try {
      const { result: result2, executionTime } = await this.measureExecutionTime(async () => {
        const language = config?.options?.language || "javascript";
        return `[Cline Node Runtime Stub] Executed ${language} code:
${code.substring(0, 100)}${code.length > 100 ? "..." : ""}

Simulated result: Success`;
      });
      return this.createSuccessResult(result2, executionTime, 75);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return this.createErrorResult(errorMessage, 0);
    }
  }
  getDefaultCapabilities() {
    return {
      supportedLanguages: ["javascript", "typescript"],
      persistence: true,
      sandboxed: true,
      maxExecutionTime: 15e3,
      // 15 seconds
      maxMemory: 512,
      // 512 MB
      supportsPackages: true,
      supportedPackageManagers: ["npm"],
      supportsStreaming: false,
      supportsFileIO: true,
      supportsNetworkAccess: true,
      supportsConcurrency: true,
      maxConcurrentExecutions: 5
    };
  }
};
var OpenDevinRuntime = class extends BaseRuntime {
  constructor() {
    super("open_devin");
    log("OpenDevin Runtime initialized (stub)", "runtime");
  }
  async execute(code, config) {
    try {
      const { result: result2, executionTime } = await this.measureExecutionTime(async () => {
        const language = config?.options?.language || "python";
        return `[OpenDevin Runtime Stub] Executed ${language} code:
${code.substring(0, 100)}${code.length > 100 ? "..." : ""}

Simulated result: Success`;
      });
      return this.createSuccessResult(result2, executionTime, 150);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return this.createErrorResult(errorMessage, 0);
    }
  }
  getDefaultCapabilities() {
    return {
      supportedLanguages: ["python", "javascript", "typescript", "go", "rust", "java"],
      persistence: true,
      sandboxed: false,
      maxExecutionTime: 6e4,
      // 1 minute
      maxMemory: 1024,
      // 1 GB
      supportsPackages: true,
      supportedPackageManagers: ["pip", "npm", "cargo", "go", "maven"],
      supportsStreaming: true,
      supportsFileIO: true,
      supportsNetworkAccess: true,
      supportsConcurrency: true,
      maxConcurrentExecutions: 3
    };
  }
};
var MCPServerRuntime = class extends BaseRuntime {
  constructor() {
    super("mcp_server");
    log("MCP Server Runtime initialized (stub)", "runtime");
  }
  async execute(code, config) {
    try {
      const { result: result2, executionTime } = await this.measureExecutionTime(async () => {
        const language = config?.options?.language || "python";
        return `[MCP Server Runtime Stub] Executed ${language} code:
${code.substring(0, 100)}${code.length > 100 ? "..." : ""}

Simulated result: Success`;
      });
      return this.createSuccessResult(result2, executionTime, 200);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return this.createErrorResult(errorMessage, 0);
    }
  }
  getDefaultCapabilities() {
    return {
      supportedLanguages: ["python", "javascript", "typescript", "go", "rust", "java", "php", "ruby"],
      persistence: true,
      sandboxed: false,
      maxExecutionTime: 12e4,
      // 2 minutes
      maxMemory: 2048,
      // 2 GB
      supportsPackages: true,
      supportedPackageManagers: ["pip", "npm", "cargo", "go", "maven", "composer", "gem"],
      supportsStreaming: true,
      supportsFileIO: true,
      supportsNetworkAccess: true,
      supportsConcurrency: true,
      maxConcurrentExecutions: 5
    };
  }
};
var CoolifyRuntime = class extends BaseRuntime {
  constructor() {
    super("coolify");
    log("Coolify Runtime initialized (stub)", "runtime");
  }
  async execute(code, config) {
    try {
      const { result: result2, executionTime } = await this.measureExecutionTime(async () => {
        const language = config?.options?.language || "javascript";
        return `[Coolify Runtime Stub] Executed ${language} code:
${code.substring(0, 100)}${code.length > 100 ? "..." : ""}

Simulated result: Success`;
      });
      return this.createSuccessResult(result2, executionTime, 180);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return this.createErrorResult(errorMessage, 0);
    }
  }
  getDefaultCapabilities() {
    return {
      supportedLanguages: ["javascript", "typescript", "python", "go", "ruby", "php", "java"],
      persistence: true,
      sandboxed: false,
      maxExecutionTime: 9e4,
      // 1.5 minutes
      maxMemory: 1536,
      // 1.5 GB
      supportsPackages: true,
      supportedPackageManagers: ["npm", "pip", "go", "gem", "composer", "maven"],
      supportsStreaming: true,
      supportsFileIO: true,
      supportsNetworkAccess: true,
      supportsConcurrency: true,
      maxConcurrentExecutions: 4
    };
  }
};

// server/services/runtime/index.ts
var RuntimeService = class {
  runtimes;
  initialized;
  constructor() {
    this.runtimes = /* @__PURE__ */ new Map();
    this.initialized = false;
    log("Runtime Service created", "runtime");
  }
  /**
   * Initialize the runtime service with available runtimes
   */
  async initialize() {
    if (this.initialized) {
      return;
    }
    try {
      this.registerRuntime("e2b" /* E2B */, new E2BRuntime());
      this.registerRuntime("open_interpreter" /* OPEN_INTERPRETER */, new OpenInterpreterRuntime());
      this.registerRuntime("wasm_edge" /* WASM_EDGE */, new WasmEdgeRuntime());
      this.registerRuntime("bacalhau" /* BACALHAU */, new BacalhauRuntime());
      this.registerRuntime("cline_node" /* CLINE_NODE */, new ClineNodeRuntime());
      this.registerRuntime("open_devin" /* OPEN_DEVIN */, new OpenDevinRuntime());
      this.registerRuntime("mcp_server" /* MCP_SERVER */, new MCPServerRuntime());
      this.registerRuntime("coolify" /* COOLIFY */, new CoolifyRuntime());
      this.initialized = true;
      log(`Runtime Service initialized with ${this.runtimes.size} runtimes`, "runtime");
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      log(`Error initializing Runtime Service: ${errorMessage}`, "runtime");
      throw new Error(`Failed to initialize Runtime Service: ${errorMessage}`);
    }
  }
  /**
   * Register a runtime implementation
   */
  registerRuntime(name, runtime) {
    if (this.runtimes.has(name)) {
      log(`Runtime '${name}' is already registered`, "runtime");
      return;
    }
    this.runtimes.set(name, runtime);
    log(`Registered runtime: ${name}`, "runtime");
  }
  /**
   * Execute code using the specified runtime
   */
  async executeCode(runtimeName, code, config) {
    if (!this.initialized) {
      await this.initialize();
    }
    const runtime = this.runtimes.get(runtimeName);
    if (!runtime) {
      throw new Error(`Runtime '${runtimeName}' not found`);
    }
    try {
      return await runtime.execute(code, config);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      log(`Error executing code in runtime '${runtimeName}': ${errorMessage}`, "runtime");
      return {
        success: false,
        output: "",
        error: errorMessage,
        executionTime: 0
      };
    }
  }
  /**
   * Check if a runtime is available
   */
  hasRuntime(name) {
    return this.runtimes.has(name);
  }
  /**
   * Get a runtime by name
   */
  getRuntime(name) {
    const runtime = this.runtimes.get(name);
    if (!runtime) {
      throw new Error(`Runtime '${name}' not found`);
    }
    return runtime;
  }
  /**
   * List all available runtimes
   */
  listRuntimes() {
    const runtimeList = [];
    for (const [name, runtime] of this.runtimes.entries()) {
      runtimeList.push({
        name,
        capabilities: runtime.getCapabilities()
      });
    }
    return runtimeList;
  }
  /**
   * Clean up resources for all runtimes
   */
  async cleanup() {
    log("Cleaning up all runtimes...", "runtime");
    const cleanupPromises = [];
    for (const runtime of this.runtimes.values()) {
      cleanupPromises.push(runtime.cleanup());
    }
    await Promise.all(cleanupPromises);
    log("All runtimes cleaned up", "runtime");
  }
};
var runtimeService = new RuntimeService();

// server/routes/runtime-routes.ts
var router17 = express5.Router();
var executeCodeSchema = z9.object({
  runtime: z9.string(),
  code: z9.string(),
  language: z9.string().optional(),
  timeout: z9.number().optional(),
  options: z9.record(z9.any()).optional()
});
function setupRuntimeRoutes() {
  runtimeService.initialize().catch((error) => {
    log(`Error initializing runtime service: ${error}`, "runtime");
  });
  router17.get("/runtimes", async (_req, res2) => {
    try {
      const runtimes = runtimeService.listRuntimes();
      res2.json({ runtimes });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      res2.status(500).json({ error: errorMessage });
    }
  });
  router17.get("/runtimes/:name", async (req2, res2) => {
    try {
      const { name } = req2.params;
      if (!runtimeService.hasRuntime(name)) {
        return res2.status(404).json({ error: `Runtime '${name}' not found` });
      }
      const runtime = runtimeService.getRuntime(name);
      const capabilities = runtime.getCapabilities();
      res2.json({ name, capabilities });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      res2.status(500).json({ error: errorMessage });
    }
  });
  router17.post("/execute", async (req2, res2) => {
    try {
      const validationResult = executeCodeSchema.safeParse(req2.body);
      if (!validationResult.success) {
        return res2.status(400).json({
          error: "Invalid request body",
          details: validationResult.error.format()
        });
      }
      const { runtime, code, language, timeout, options: options2 } = validationResult.data;
      if (!runtimeService.hasRuntime(runtime)) {
        return res2.status(404).json({ error: `Runtime '${runtime}' not found` });
      }
      const config = {
        timeout,
        options: {
          language,
          ...options2
        }
      };
      const result2 = await runtimeService.executeCode(runtime, code, config);
      res2.json(result2);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      log(`Error executing code: ${errorMessage}`, "runtime");
      res2.status(500).json({ error: errorMessage });
    }
  });
  router17.get("/health", (_req, res2) => {
    try {
      const isInitialized = runtimeService.hasRuntime("e2b");
      res2.json({
        status: isInitialized ? "healthy" : "initializing",
        message: isInitialized ? "Runtime service is healthy" : "Runtime service is initializing"
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      res2.status(500).json({ status: "error", error: errorMessage });
    }
  });
  return router17;
}

// server/routes/execution-routes.ts
import { Router as Router14 } from "express";
import { z as z10 } from "zod";
import { v4 as uuidv48 } from "uuid";

// server/services/stats/execution-stats.ts
var ExecutionStatsService = class {
  stats = {
    totalExecutions: 0,
    activeExecutions: 0,
    completedExecutions: 0,
    failedExecutions: 0,
    averageDuration: 0,
    successRate: 0
  };
  durations = [];
  constructor() {
    this.stats = {
      totalExecutions: 142,
      activeExecutions: 3,
      completedExecutions: 122,
      failedExecutions: 17,
      averageDuration: 45e3,
      // 45 seconds
      successRate: 87.5
      // percentage
    };
  }
  /**
   * Get current execution statistics
   */
  getStats() {
    return { ...this.stats };
  }
  /**
   * Record a new execution start
   */
  recordExecutionStart() {
    this.stats.totalExecutions++;
    this.stats.activeExecutions++;
  }
  /**
   * Record an execution completion
   */
  recordExecutionCompletion(durationMs, success = true) {
    this.stats.activeExecutions = Math.max(0, this.stats.activeExecutions - 1);
    if (success) {
      this.stats.completedExecutions++;
    } else {
      this.stats.failedExecutions++;
    }
    this.durations.push(durationMs);
    if (this.durations.length > 100) {
      this.durations.shift();
    }
    this.stats.averageDuration = this.durations.reduce((sum2, d) => sum2 + d, 0) / this.durations.length;
    const total = this.stats.completedExecutions + this.stats.failedExecutions;
    this.stats.successRate = total > 0 ? this.stats.completedExecutions / total * 100 : 0;
  }
  /**
   * Reset statistics
   */
  resetStats() {
    this.stats = {
      totalExecutions: 0,
      activeExecutions: 0,
      completedExecutions: 0,
      failedExecutions: 0,
      averageDuration: 0,
      successRate: 0
    };
    this.durations = [];
  }
};
var executionStats = new ExecutionStatsService();

// server/services/stats/performance-monitor.ts
import { EventEmitter as EventEmitter3 } from "events";
var PerformanceMonitorService = class extends EventEmitter3 {
  performanceData = /* @__PURE__ */ new Map();
  thresholds = /* @__PURE__ */ new Map();
  isMonitoring = false;
  monitoringInterval = null;
  samplingIntervalMs = 6e4;
  // Default: 1 minute
  constructor() {
    super();
    const demoMetrics = {
      memoryUsage: 256,
      cpuUsage: 15,
      responseTime: 120,
      throughput: 42,
      errorRate: 1.5,
      queueLength: 3,
      activeConnections: 8,
      diskUsage: 45
    };
    this.recordMetrics("workflow-1", { ...demoMetrics, cpuUsage: 22, memoryUsage: 310 });
    this.recordMetrics("workflow-2", { ...demoMetrics, responseTime: 350, throughput: 15 });
    this.recordMetrics("workflow-3", { ...demoMetrics, errorRate: 0.2, diskUsage: 65 });
  }
  /**
   * Set default thresholds for a workflow
   */
  setThresholds(workflowId, metricThresholds) {
    this.thresholds.set(workflowId, metricThresholds);
    logInfo(
      "Set performance thresholds",
      { message: "Setting performance thresholds for workflow", workflow: workflowId },
      void 0,
      "workflow" /* Workflow */,
      workflowId
    );
  }
  /**
   * Get current thresholds for a workflow
   */
  getThresholds(workflowId) {
    return this.thresholds.get(workflowId) || {};
  }
  /**
   * Record performance metrics for a workflow
   */
  recordMetrics(workflowId, metrics) {
    const timestamp2 = /* @__PURE__ */ new Date();
    const data = {
      workflowId,
      metrics,
      timestamp: timestamp2
    };
    if (!this.performanceData.has(workflowId)) {
      this.performanceData.set(workflowId, []);
    }
    const history = this.performanceData.get(workflowId);
    history.push(data);
    if (history.length > 1e3) {
      history.shift();
    }
    this.checkThresholds(workflowId, metrics);
  }
  /**
   * Get performance metrics for a workflow
   */
  getMetrics(workflowId) {
    return this.performanceData.get(workflowId) || [];
  }
  /**
   * Get the latest performance metrics for a workflow
   */
  getLatestMetrics(workflowId) {
    const metrics = this.performanceData.get(workflowId);
    if (!metrics || metrics.length === 0) {
      return null;
    }
    return metrics[metrics.length - 1];
  }
  /**
   * Get a list of all monitored workflow IDs
   */
  getMonitoredWorkflows() {
    return Array.from(this.performanceData.keys());
  }
  /**
   * Clear performance data for a workflow
   */
  clearMetrics(workflowId) {
    this.performanceData.delete(workflowId);
  }
  /**
   * Start continuous monitoring
   */
  startMonitoring(intervalMs = 6e4) {
    if (this.isMonitoring) {
      return;
    }
    this.samplingIntervalMs = intervalMs;
    this.isMonitoring = true;
    this.monitoringInterval = setInterval(() => {
      for (const workflowId of this.getMonitoredWorkflows()) {
        const lastMetrics = this.getLatestMetrics(workflowId);
        if (lastMetrics) {
          const variationFactor = 0.1;
          const newMetrics = {
            memoryUsage: this.applyRandomVariation(lastMetrics.metrics.memoryUsage, variationFactor),
            cpuUsage: this.applyRandomVariation(lastMetrics.metrics.cpuUsage, variationFactor),
            responseTime: this.applyRandomVariation(lastMetrics.metrics.responseTime, variationFactor),
            throughput: this.applyRandomVariation(lastMetrics.metrics.throughput, variationFactor),
            errorRate: this.applyRandomVariation(lastMetrics.metrics.errorRate, variationFactor),
            queueLength: Math.max(0, Math.round(this.applyRandomVariation(lastMetrics.metrics.queueLength, variationFactor))),
            activeConnections: Math.max(0, Math.round(this.applyRandomVariation(lastMetrics.metrics.activeConnections, variationFactor))),
            diskUsage: this.applyRandomVariation(lastMetrics.metrics.diskUsage, variationFactor)
          };
          this.recordMetrics(workflowId, newMetrics);
        }
      }
    }, this.samplingIntervalMs);
    logInfo(
      "Started performance monitoring",
      { message: `Performance monitoring started with interval of ${intervalMs}ms` },
      void 0,
      "system" /* System */
    );
  }
  /**
   * Stop continuous monitoring
   */
  stopMonitoring() {
    if (!this.isMonitoring || !this.monitoringInterval) {
      return;
    }
    clearInterval(this.monitoringInterval);
    this.isMonitoring = false;
    this.monitoringInterval = null;
    logInfo(
      "Stopped performance monitoring",
      { message: "Performance monitoring was stopped" },
      void 0,
      "system" /* System */
    );
  }
  /**
   * Apply random variation to a metric value
   */
  applyRandomVariation(value, factor) {
    const variation = (Math.random() * 2 - 1) * factor * value;
    return Math.max(0, value + variation);
  }
  /**
   * Check if any metrics have crossed thresholds and emit alerts
   */
  checkThresholds(workflowId, metrics) {
    const thresholds = this.thresholds.get(workflowId);
    if (!thresholds) {
      return;
    }
    for (const [metricName, metricValue] of Object.entries(metrics)) {
      const threshold = thresholds[metricName];
      if (!threshold) {
        continue;
      }
      if (threshold.critical !== void 0 && metricValue >= threshold.critical) {
        const alert = {
          workflowId,
          metric: metricName,
          value: metricValue,
          threshold: threshold.critical,
          severity: "critical",
          timestamp: /* @__PURE__ */ new Date()
        };
        this.emit("alert", alert);
        const alertError = new Error(`Workflow ${workflowId} has ${metricName} at ${metricValue} (threshold: ${threshold.critical})`);
        Object.assign(alertError, {
          workflowId,
          metric: metricName,
          value: metricValue,
          threshold: threshold.critical
        });
        logError(
          `Performance alert: ${metricName} exceeded critical threshold`,
          alertError,
          void 0,
          "workflow" /* Workflow */,
          workflowId
        );
      } else if (threshold.warning !== void 0 && metricValue >= threshold.warning) {
        const alert = {
          workflowId,
          metric: metricName,
          value: metricValue,
          threshold: threshold.warning,
          severity: "warning",
          timestamp: /* @__PURE__ */ new Date()
        };
        this.emit("alert", alert);
        logInfo(
          `Performance warning: ${metricName} exceeded warning threshold`,
          {
            message: `Workflow ${workflowId} has ${metricName} at ${metricValue} (threshold: ${threshold.warning})`,
            workflowId,
            metric: metricName,
            value: metricValue,
            threshold: threshold.warning
          },
          void 0,
          "workflow" /* Workflow */,
          workflowId
        );
      }
    }
  }
};
var performanceMonitor = new PerformanceMonitorService();

// server/routes/execution-routes.ts
var router18 = Router14();
var isAuthenticated8 = (req2, res2, next) => {
  if (req2.isAuthenticated()) {
    return next();
  }
  res2.status(401).json({ message: "Unauthorized" });
};
router18.get("/api/executions", isAuthenticated8, async (req2, res2) => {
  try {
    const user = req2.user;
    const userId = user.id;
    const page = parseInt(req2.query.page) || 1;
    const limit = parseInt(req2.query.limit) || 10;
    const status = req2.query.status || null;
    const search = req2.query.search || "";
    const fromDate = req2.query.from ? new Date(req2.query.from) : null;
    const toDate = req2.query.to ? new Date(req2.query.to) : null;
    const offset = (page - 1) * limit;
    const executions = await storage.getWorkflowExecutionsByUser(userId, {
      limit,
      offset,
      status,
      search,
      fromDate,
      toDate
    });
    const total = await storage.countWorkflowExecutionsByUser(userId, {
      status,
      search,
      fromDate,
      toDate
    });
    const formattedExecutions = await Promise.all(
      executions.map(async (execution) => {
        const workflow = await storage.getWorkflow(execution.workflowId);
        const triggeredByUser = await storage.getUser(execution.triggeredById || 0);
        return {
          id: execution.id,
          workflowId: execution.workflowId,
          workflowName: workflow?.name || "Unknown Workflow",
          status: execution.status,
          startedAt: execution.startedAt.toISOString(),
          completedAt: execution.completedAt ? execution.completedAt.toISOString() : null,
          progress: execution.progress || 0,
          triggeredBy: {
            id: triggeredByUser?.id || 0,
            username: triggeredByUser?.username || "Unknown User"
          }
        };
      })
    );
    res2.json({
      executions: formattedExecutions,
      total
    });
  } catch (error) {
    console.error("Error fetching executions:", error);
    res2.status(500).json({
      message: "Error fetching executions",
      error: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router18.get("/api/executions/:id/details", isAuthenticated8, async (req2, res2) => {
  try {
    const { id } = req2.params;
    const executionId = parseInt(id);
    const user = req2.user;
    const execution = await storage.getWorkflowExecution(executionId);
    if (!execution) {
      return res2.status(404).json({ message: "Execution not found" });
    }
    const workflow = await storage.getWorkflow(execution.workflowId);
    if (!workflow) {
      return res2.status(404).json({ message: "Associated workflow not found" });
    }
    if (workflow.ownerId !== user.id) {
      return res2.status(403).json({ message: "Forbidden" });
    }
    const logs = await storage.getExecutionLogs(executionId);
    const nodeExecutions2 = await storage.getNodeExecutions(executionId);
    const activeExecution = executionRegistry.get(executionId);
    let realTimeStatus = null;
    if (activeExecution) {
      realTimeStatus = {
        status: activeExecution.status,
        progress: execution.progress,
        currentNode: activeExecution.currentNodeId,
        elapsedTime: Date.now() - execution.startedAt.getTime()
        // in ms
        // Add other real-time details as needed
      };
    }
    const triggeredByUser = await storage.getUser(execution.triggeredById || 0);
    const workflowDetails = await storage.getWorkflow(execution.workflowId);
    const formattedExecution = {
      id: execution.id,
      workflowId: execution.workflowId,
      workflowName: workflowDetails?.name || "Unknown Workflow",
      status: execution.status,
      startedAt: execution.startedAt.toISOString(),
      completedAt: execution.completedAt ? execution.completedAt.toISOString() : null,
      progress: execution.progress || 0,
      triggeredBy: {
        id: triggeredByUser?.id || 0,
        username: triggeredByUser?.username || "Unknown User"
      },
      duration: execution.completedAt ? execution.completedAt.getTime() - execution.startedAt.getTime() : Date.now() - execution.startedAt.getTime(),
      result: execution.result,
      error: execution.error
    };
    const formattedLogs = logs.map((log2) => ({
      id: log2.id,
      timestamp: log2.timestamp.toISOString(),
      level: log2.level,
      message: log2.message,
      source: log2.source
    }));
    const formattedNodeExecutions = nodeExecutions2.map((node) => ({
      id: node.id,
      nodeId: node.nodeId,
      status: node.status,
      startedAt: node.startedAt.toISOString(),
      completedAt: node.completedAt ? node.completedAt.toISOString() : null,
      input: node.input,
      output: node.output,
      error: node.error,
      duration: node.completedAt ? node.completedAt.getTime() - node.startedAt.getTime() : null
    }));
    res2.json({
      execution: formattedExecution,
      logs: formattedLogs,
      nodeExecutions: formattedNodeExecutions,
      realTimeStatus,
      workflow: {
        id: workflowDetails?.id,
        name: workflowDetails?.name,
        definition: workflowDetails?.data
      }
    });
  } catch (error) {
    console.error("Error fetching execution details:", error);
    res2.status(500).json({
      message: "Error fetching execution details",
      error: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router18.post("/api/executions", isAuthenticated8, async (req2, res2) => {
  try {
    const user = req2.user;
    const schema = z10.object({
      workflowId: z10.number(),
      inputs: z10.record(z10.any()).optional()
    });
    const validatedData = schema.parse(req2.body);
    const workflow = await storage.getWorkflow(validatedData.workflowId);
    if (!workflow) {
      return res2.status(404).json({ message: "Workflow not found" });
    }
    if (workflow.ownerId !== user.id) {
      return res2.status(403).json({ message: "Forbidden" });
    }
    const execution = await storage.createWorkflowExecution({
      workflowId: validatedData.workflowId,
      status: "queued" /* QUEUED */,
      startedAt: /* @__PURE__ */ new Date(),
      completedAt: null,
      progress: 0,
      triggeredById: user.id,
      result: null,
      error: null
    });
    startWorkflowExecution(
      execution.id,
      workflow,
      validatedData.inputs || {}
    ).catch((error) => {
      console.error("Error starting workflow execution:", error);
    });
    executionStats.recordExecutionStart();
    res2.status(201).json({
      executionId: execution.id,
      message: "Execution started"
    });
    simulateWorkflowExecution(execution.id).catch((error) => {
      console.error("Error simulating workflow execution:", error);
    });
  } catch (error) {
    console.error("Error starting execution:", error);
    if (error instanceof z10.ZodError) {
      return res2.status(400).json({
        message: "Invalid request data",
        errors: error.errors
      });
    }
    res2.status(500).json({
      message: "Error starting execution",
      error: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router18.post("/api/executions/:id/pause", isAuthenticated8, async (req2, res2) => {
  try {
    const { id } = req2.params;
    const executionId = parseInt(id);
    const user = req2.user;
    const execution = await storage.getWorkflowExecution(executionId);
    if (!execution) {
      return res2.status(404).json({ message: "Execution not found" });
    }
    const workflow = await storage.getWorkflow(execution.workflowId);
    if (!workflow) {
      return res2.status(404).json({ message: "Associated workflow not found" });
    }
    if (workflow.ownerId !== user.id) {
      return res2.status(403).json({ message: "Forbidden" });
    }
    if (execution.status !== "running" /* RUNNING */) {
      return res2.status(400).json({
        message: `Cannot pause execution with status ${execution.status}`
      });
    }
    const success = await pauseWorkflowExecution(executionId);
    if (!success) {
      return res2.status(400).json({ message: "Failed to pause execution" });
    }
    res2.json({ message: "Execution paused successfully" });
  } catch (error) {
    console.error("Error pausing execution:", error);
    res2.status(500).json({
      message: "Error pausing execution",
      error: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router18.post("/api/executions/:id/resume", isAuthenticated8, async (req2, res2) => {
  try {
    const { id } = req2.params;
    const executionId = parseInt(id);
    const user = req2.user;
    const execution = await storage.getWorkflowExecution(executionId);
    if (!execution) {
      return res2.status(404).json({ message: "Execution not found" });
    }
    const workflow = await storage.getWorkflow(execution.workflowId);
    if (!workflow) {
      return res2.status(404).json({ message: "Associated workflow not found" });
    }
    if (workflow.ownerId !== user.id) {
      return res2.status(403).json({ message: "Forbidden" });
    }
    if (execution.status !== "paused" /* PAUSED */) {
      return res2.status(400).json({
        message: `Cannot resume execution with status ${execution.status}`
      });
    }
    const success = await resumeWorkflowExecution(executionId);
    if (!success) {
      return res2.status(400).json({ message: "Failed to resume execution" });
    }
    res2.json({ message: "Execution resumed successfully" });
  } catch (error) {
    console.error("Error resuming execution:", error);
    res2.status(500).json({
      message: "Error resuming execution",
      error: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router18.post("/api/executions/:id/cancel", isAuthenticated8, async (req2, res2) => {
  try {
    const { id } = req2.params;
    const executionId = parseInt(id);
    const user = req2.user;
    const execution = await storage.getWorkflowExecution(executionId);
    if (!execution) {
      return res2.status(404).json({ message: "Execution not found" });
    }
    const workflow = await storage.getWorkflow(execution.workflowId);
    if (!workflow) {
      return res2.status(404).json({ message: "Associated workflow not found" });
    }
    if (workflow.ownerId !== user.id) {
      return res2.status(403).json({ message: "Forbidden" });
    }
    if (!["running" /* RUNNING */, "paused" /* PAUSED */, "queued" /* QUEUED */].includes(execution.status)) {
      return res2.status(400).json({
        message: `Cannot cancel execution with status ${execution.status}`
      });
    }
    const success = await cancelWorkflowExecution(executionId);
    if (!success) {
      return res2.status(400).json({ message: "Failed to cancel execution" });
    }
    res2.json({ message: "Execution cancelled successfully" });
  } catch (error) {
    console.error("Error cancelling execution:", error);
    res2.status(500).json({
      message: "Error cancelling execution",
      error: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router18.get("/api/executions/stats", isAuthenticated8, (_req, res2) => {
  try {
    const stats = executionStats.getStats();
    res2.json(stats);
  } catch (error) {
    console.error("Error fetching execution stats:", error);
    res2.status(500).json({
      message: "Error fetching execution stats",
      error: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router18.get("/api/performance/:workflowId", isAuthenticated8, async (req2, res2) => {
  try {
    const { workflowId } = req2.params;
    const user = req2.user;
    const workflow = await storage.getWorkflow(parseInt(workflowId));
    if (!workflow) {
      return res2.status(404).json({ message: "Workflow not found" });
    }
    if (workflow.ownerId !== user.id) {
      return res2.status(403).json({ message: "Forbidden" });
    }
    const metrics = performanceMonitor.getMetrics(workflowId);
    const latestMetrics = performanceMonitor.getLatestMetrics(workflowId);
    res2.json({
      workflowId,
      metrics: metrics.slice(-20),
      // Return last 20 data points to avoid overwhelming response
      latest: latestMetrics
    });
  } catch (error) {
    console.error("Error fetching performance metrics:", error);
    res2.status(500).json({
      message: "Error fetching performance metrics",
      error: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router18.get("/api/performance/:workflowId/thresholds", isAuthenticated8, async (req2, res2) => {
  try {
    const { workflowId } = req2.params;
    const user = req2.user;
    const workflow = await storage.getWorkflow(parseInt(workflowId));
    if (!workflow) {
      return res2.status(404).json({ message: "Workflow not found" });
    }
    if (workflow.ownerId !== user.id) {
      return res2.status(403).json({ message: "Forbidden" });
    }
    const thresholds = performanceMonitor.getThresholds(workflowId);
    res2.json({
      workflowId,
      thresholds
    });
  } catch (error) {
    console.error("Error fetching performance thresholds:", error);
    res2.status(500).json({
      message: "Error fetching performance thresholds",
      error: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router18.post("/api/performance/:workflowId/thresholds", isAuthenticated8, async (req2, res2) => {
  try {
    const { workflowId } = req2.params;
    const user = req2.user;
    const schema = z10.record(z10.object({
      warning: z10.number().optional(),
      critical: z10.number().optional()
    }));
    const thresholds = schema.parse(req2.body);
    const workflow = await storage.getWorkflow(parseInt(workflowId));
    if (!workflow) {
      return res2.status(404).json({ message: "Workflow not found" });
    }
    if (workflow.ownerId !== user.id) {
      return res2.status(403).json({ message: "Forbidden" });
    }
    performanceMonitor.setThresholds(workflowId, thresholds);
    res2.json({
      message: "Performance thresholds updated successfully",
      workflowId,
      thresholds
    });
  } catch (error) {
    console.error("Error updating performance thresholds:", error);
    if (error instanceof z10.ZodError) {
      return res2.status(400).json({
        message: "Invalid request data",
        errors: error.errors
      });
    }
    res2.status(500).json({
      message: "Error updating performance thresholds",
      error: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router18.post("/api/performance/:workflowId/monitor", isAuthenticated8, async (req2, res2) => {
  try {
    const { workflowId } = req2.params;
    const user = req2.user;
    const schema = z10.object({
      interval: z10.number().min(5e3).default(6e4)
    });
    const { interval } = schema.parse(req2.body);
    const workflow = await storage.getWorkflow(parseInt(workflowId));
    if (!workflow) {
      return res2.status(404).json({ message: "Workflow not found" });
    }
    if (workflow.ownerId !== user.id) {
      return res2.status(403).json({ message: "Forbidden" });
    }
    performanceMonitor.startMonitoring(interval);
    res2.json({
      message: "Performance monitoring started",
      workflowId,
      interval
    });
  } catch (error) {
    console.error("Error starting performance monitoring:", error);
    if (error instanceof z10.ZodError) {
      return res2.status(400).json({
        message: "Invalid request data",
        errors: error.errors
      });
    }
    res2.status(500).json({
      message: "Error starting performance monitoring",
      error: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router18.post("/api/performance/:workflowId/stop", isAuthenticated8, async (req2, res2) => {
  try {
    const { workflowId } = req2.params;
    const user = req2.user;
    const workflow = await storage.getWorkflow(parseInt(workflowId));
    if (!workflow) {
      return res2.status(404).json({ message: "Workflow not found" });
    }
    if (workflow.ownerId !== user.id) {
      return res2.status(403).json({ message: "Forbidden" });
    }
    performanceMonitor.stopMonitoring();
    res2.json({
      message: "Performance monitoring stopped",
      workflowId
    });
  } catch (error) {
    console.error("Error stopping performance monitoring:", error);
    res2.status(500).json({
      message: "Error stopping performance monitoring",
      error: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
async function simulateWorkflowExecution(executionId) {
  try {
    const execution = await storage.getWorkflowExecution(executionId);
    if (!execution) {
      console.error(`Execution ${executionId} not found for simulation`);
      return;
    }
    await sleep(1e3);
    await storage.updateWorkflowExecution(executionId, {
      status: "running" /* RUNNING */
    });
    const totalSteps = 10;
    for (let step = 1; step <= totalSteps; step++) {
      if (Math.random() < 0.05) {
        await storage.updateWorkflowExecution(executionId, {
          status: "failed" /* FAILED */,
          completedAt: /* @__PURE__ */ new Date(),
          error: "Simulated random failure"
        });
        const duration2 = Date.now() - execution.startedAt.getTime();
        executionStats.recordExecutionCompletion(duration2, false);
        return;
      }
      const progress = Math.floor(step / totalSteps * 100);
      await storage.updateWorkflowExecution(executionId, {
        progress
      });
      const nodeId = `node-${uuidv48().slice(0, 8)}`;
      await storage.createNodeExecution({
        executionId,
        nodeId,
        status: "completed" /* COMPLETED */,
        startedAt: /* @__PURE__ */ new Date(),
        completedAt: /* @__PURE__ */ new Date(),
        input: { step },
        output: { result: `Result for step ${step}` }
      });
      await storage.createExecutionLog({
        executionId,
        timestamp: /* @__PURE__ */ new Date(),
        level: "info",
        message: `Completed step ${step} of ${totalSteps}`,
        source: nodeId
      });
      await sleep(1e3 + Math.random() * 2e3);
    }
    await storage.updateWorkflowExecution(executionId, {
      status: "completed" /* COMPLETED */,
      completedAt: /* @__PURE__ */ new Date(),
      progress: 100,
      result: { message: "Simulation completed successfully" }
    });
    const duration = Date.now() - execution.startedAt.getTime();
    executionStats.recordExecutionCompletion(duration, true);
  } catch (error) {
    console.error("Error in execution simulation:", error);
    try {
      await storage.updateWorkflowExecution(executionId, {
        status: "failed" /* FAILED */,
        completedAt: /* @__PURE__ */ new Date(),
        error: `Simulation error: ${error instanceof Error ? error.message : "Unknown error"}`
      });
      const execution = await storage.getWorkflowExecution(executionId);
      if (execution) {
        const duration = Date.now() - execution.startedAt.getTime();
        executionStats.recordExecutionCompletion(duration, false);
      }
    } catch (updateError) {
      console.error("Failed to update execution after simulation error:", updateError);
    }
  }
}
var execution_routes_default = router18;

// server/routes/telemetry-routes.ts
import { Router as Router15 } from "express";

// server/services/telemetry/opentelemetry.ts
import { NodeSDK } from "@opentelemetry/sdk-node";
import { getNodeAutoInstrumentations } from "@opentelemetry/auto-instrumentations-node";
import { OTLPTraceExporter } from "@opentelemetry/exporter-trace-otlp-proto";
import { OTLPMetricExporter } from "@opentelemetry/exporter-metrics-otlp-proto";
import { SemanticResourceAttributes } from "@opentelemetry/semantic-conventions";
import { diag, DiagConsoleLogger, DiagLogLevel } from "@opentelemetry/api";
diag.setLogger(new DiagConsoleLogger(), DiagLogLevel.INFO);
function initOpenTelemetry(serviceName = "synthralos", serviceVersion = "1.0.0", signozEndpoint = process.env.SIGNOZ_ENDPOINT || "http://localhost:4318") {
  const traceExporter = new OTLPTraceExporter({
    url: `${signozEndpoint}/v1/traces`
  });
  const metricExporter = new OTLPMetricExporter({
    url: `${signozEndpoint}/v1/metrics`
  });
  const resourceAttributes = {};
  resourceAttributes[SemanticResourceAttributes.SERVICE_NAME] = serviceName;
  resourceAttributes[SemanticResourceAttributes.SERVICE_VERSION] = serviceVersion;
  resourceAttributes["environment"] = process.env.NODE_ENV || "development";
  const sdk = new NodeSDK({
    traceExporter,
    // Use resources object instead of Resource constructor
    resources: resourceAttributes,
    instrumentations: [
      getNodeAutoInstrumentations({
        // Enable all auto-instrumentations with default settings
        "@opentelemetry/instrumentation-fs": { enabled: true },
        "@opentelemetry/instrumentation-net": { enabled: true },
        "@opentelemetry/instrumentation-http": { enabled: true },
        "@opentelemetry/instrumentation-express": { enabled: true },
        "@opentelemetry/instrumentation-pg": { enabled: true }
      })
    ]
  });
  sdk.start();
  process.on("SIGTERM", () => {
    sdk.shutdown().then(() => console.log("OpenTelemetry SDK shut down successfully")).catch((error) => console.error("Error shutting down OpenTelemetry SDK", error)).finally(() => process.exit(0));
  });
  return sdk;
}
var sdkInstance = null;
function getOpenTelemetrySdk() {
  return sdkInstance;
}
function initializeGlobalTelemetry() {
  if (!sdkInstance) {
    sdkInstance = initOpenTelemetry();
  }
  return sdkInstance;
}

// server/services/telemetry/posthog.ts
var import_posthog_wrapper = __toESM(require_posthog_wrapper(), 1);
function initPostHog(options2) {
  return (0, import_posthog_wrapper.initPostHog)(options2);
}
var posthogInstance = null;
function getPostHogClient() {
  if (!posthogInstance && process.env.POSTHOG_API_KEY) {
    posthogInstance = initPostHog({
      apiKey: process.env.POSTHOG_API_KEY,
      host: process.env.POSTHOG_HOST
    });
  }
  return posthogInstance;
}
function trackEvent(eventName, userId, properties = {}) {
  const client = getPostHogClient();
  if (!client) {
    console.warn("PostHog client not initialized. Event not tracked:", eventName);
    return;
  }
  client.capture({
    distinctId: userId.toString(),
    event: eventName,
    properties
  });
}
async function isFeatureEnabled(flagKey, userId, defaultValue = false) {
  const client = getPostHogClient();
  if (!client) {
    console.warn("PostHog client not initialized. Using default for feature flag:", flagKey);
    return defaultValue;
  }
  try {
    const result2 = await client.isFeatureEnabled(flagKey, userId.toString());
    return result2 !== null ? result2 : defaultValue;
  } catch (error) {
    console.error(`Error checking feature flag ${flagKey}:`, error);
    return defaultValue;
  }
}
async function getAllFeatureFlags(userId) {
  const client = getPostHogClient();
  if (!client) {
    console.warn("PostHog client not initialized. Cannot get feature flags.");
    return {};
  }
  try {
    const flags = await client.getAllFlags(userId.toString());
    return flags || {};
  } catch (error) {
    console.error("Error getting all feature flags:", error);
    return {};
  }
}

// server/services/telemetry/langfuse.ts
import { Langfuse } from "langfuse";
function initLangfuse(options2) {
  const { secretKey, publicKey, baseUrl } = options2;
  return new Langfuse({
    secretKey,
    publicKey,
    baseUrl: baseUrl || "https://cloud.langfuse.com"
  });
}
var langfuseInstance = null;
function getLangfuseClient() {
  if (!langfuseInstance && process.env.LANGFUSE_SECRET_KEY && process.env.LANGFUSE_PUBLIC_KEY) {
    langfuseInstance = initLangfuse({
      secretKey: process.env.LANGFUSE_SECRET_KEY,
      publicKey: process.env.LANGFUSE_PUBLIC_KEY,
      baseUrl: process.env.LANGFUSE_BASE_URL
    });
  }
  return langfuseInstance;
}
function createTrace(name, userId, metadata = {}) {
  const client = getLangfuseClient();
  if (!client) {
    console.warn("Langfuse client not initialized. Trace not created:", name);
    return null;
  }
  const userIdString = userId ? userId.toString() : void 0;
  return client.trace({
    name,
    userId: userIdString,
    metadata
  });
}
function trackGeneration(traceId, name, model, prompt, completion, metadata = {}) {
  const client = getLangfuseClient();
  if (!client) {
    console.warn("Langfuse client not initialized. Generation not tracked:", name);
    return;
  }
  const promptString = typeof prompt === "string" ? prompt : JSON.stringify(prompt);
  const completionString = typeof completion === "string" ? completion : JSON.stringify(completion);
  return client.generation({
    name,
    traceId,
    model,
    prompt: promptString,
    completion: completionString,
    metadata
  });
}

// server/services/telemetry/stackstorm.ts
import axios7 from "axios";
var StackStormClient = class {
  apiUrl;
  apiKey;
  timeout;
  constructor(options2) {
    this.apiUrl = options2.apiUrl.endsWith("/") ? options2.apiUrl.slice(0, -1) : options2.apiUrl;
    this.apiKey = options2.apiKey;
    this.timeout = options2.timeout || 3e4;
  }
  /**
   * Execute a StackStorm action
   */
  async executeAction(request) {
    try {
      const response = await axios7.post(
        `${this.apiUrl}/v1/executions`,
        request,
        {
          headers: {
            "St2-Api-Key": this.apiKey,
            "Content-Type": "application/json"
          },
          timeout: this.timeout
        }
      );
      return response.data;
    } catch (error) {
      if (axios7.isAxiosError(error) && error.response) {
        throw new Error(`StackStorm API error: ${error.response.status} - ${JSON.stringify(error.response.data)}`);
      }
      throw error;
    }
  }
  /**
   * Get execution result by ID
   */
  async getExecution(executionId) {
    try {
      const response = await axios7.get(
        `${this.apiUrl}/v1/executions/${executionId}`,
        {
          headers: {
            "St2-Api-Key": this.apiKey,
            "Content-Type": "application/json"
          },
          timeout: this.timeout
        }
      );
      return response.data;
    } catch (error) {
      if (axios7.isAxiosError(error) && error.response) {
        throw new Error(`StackStorm API error: ${error.response.status} - ${JSON.stringify(error.response.data)}`);
      }
      throw error;
    }
  }
  /**
   * Create a new rule
   */
  async createRule(rule) {
    try {
      const response = await axios7.post(
        `${this.apiUrl}/v1/rules`,
        rule,
        {
          headers: {
            "St2-Api-Key": this.apiKey,
            "Content-Type": "application/json"
          },
          timeout: this.timeout
        }
      );
      return response.data;
    } catch (error) {
      if (axios7.isAxiosError(error) && error.response) {
        throw new Error(`StackStorm API error: ${error.response.status} - ${JSON.stringify(error.response.data)}`);
      }
      throw error;
    }
  }
  /**
   * Trigger a webhook
   */
  async triggerWebhook(hookName, payload) {
    try {
      const response = await axios7.post(
        `${this.apiUrl}/v1/webhooks/${hookName}`,
        payload,
        {
          headers: {
            "St2-Api-Key": this.apiKey,
            "Content-Type": "application/json"
          },
          timeout: this.timeout
        }
      );
      return response.data;
    } catch (error) {
      if (axios7.isAxiosError(error) && error.response) {
        throw new Error(`StackStorm API error: ${error.response.status} - ${JSON.stringify(error.response.data)}`);
      }
      throw error;
    }
  }
};
var stackStormClient = null;
function getStackStormClient() {
  if (!stackStormClient && process.env.STACKSTORM_API_URL && process.env.STACKSTORM_API_KEY) {
    stackStormClient = new StackStormClient({
      apiUrl: process.env.STACKSTORM_API_URL,
      apiKey: process.env.STACKSTORM_API_KEY
    });
  }
  return stackStormClient;
}
var IncidentResponseActions = {
  /**
   * Report a security incident
   */
  reportSecurityIncident: async (severity, description, metadata = {}) => {
    const client = getStackStormClient();
    if (!client) {
      console.warn("StackStorm client not initialized. Cannot report security incident.");
      return null;
    }
    return client.executeAction({
      action: "synthralos.report_security_incident",
      parameters: {
        severity,
        description,
        occurred_at: (/* @__PURE__ */ new Date()).toISOString(),
        metadata
      }
    });
  },
  /**
   * Perform automated remediation for a known issue
   */
  performRemediation: async (issueType, context = {}) => {
    const client = getStackStormClient();
    if (!client) {
      console.warn("StackStorm client not initialized. Cannot perform remediation.");
      return null;
    }
    return client.executeAction({
      action: "synthralos.auto_remediate",
      parameters: {
        issue_type: issueType,
        context
      }
    });
  }
};

// server/services/telemetry/arch_gw.ts
var ArchGWService = class {
  components;
  rules;
  constructor() {
    this.components = /* @__PURE__ */ new Map();
    this.rules = /* @__PURE__ */ new Map();
  }
  /**
   * Register a component in the architecture
   */
  registerComponent(component) {
    this.components.set(component.id, component);
    return component;
  }
  /**
   * Update a component
   */
  updateComponent(id, updates) {
    const component = this.components.get(id);
    if (!component) return void 0;
    const updatedComponent = { ...component, ...updates };
    this.components.set(id, updatedComponent);
    return updatedComponent;
  }
  /**
   * Remove a component
   */
  removeComponent(id) {
    return this.components.delete(id);
  }
  /**
   * Get all components
   */
  getComponents() {
    return Array.from(this.components.values());
  }
  /**
   * Get a component by ID
   */
  getComponent(id) {
    return this.components.get(id);
  }
  /**
   * Add a validation rule
   */
  addRule(rule) {
    this.rules.set(rule.id, rule);
    return rule;
  }
  /**
   * Update a rule
   */
  updateRule(id, updates) {
    const rule = this.rules.get(id);
    if (!rule) return void 0;
    const updatedRule = { ...rule, ...updates };
    this.rules.set(id, updatedRule);
    return updatedRule;
  }
  /**
   * Remove a rule
   */
  removeRule(id) {
    return this.rules.delete(id);
  }
  /**
   * Get all validation rules
   */
  getRules() {
    return Array.from(this.rules.values());
  }
  /**
   * Validate the architecture against all rules
   */
  validateArchitecture() {
    const violations = [];
    const validatedComponents = [];
    let pass = true;
    const enabledRules = Array.from(this.rules.values()).filter((rule) => rule.enabled);
    for (const component of this.components.values()) {
      validatedComponents.push(component.id);
      for (const rule of enabledRules) {
        if (rule.componentsFilter && rule.componentsFilter.length > 0 && !rule.componentsFilter.includes(component.id)) {
          continue;
        }
        try {
          const context = {
            component,
            components: this.getComponents(),
            getComponent: (id) => this.getComponent(id),
            type: component.type,
            dependencies: component.dependencies.map((id) => this.getComponent(id)),
            tags: component.tags,
            metadata: component.metadata
          };
          const conditionFn = new Function("context", `return ${rule.condition}`);
          const conditionMet = conditionFn(context);
          if (!conditionMet) {
            violations.push({
              ruleId: rule.id,
              componentId: component.id,
              severity: rule.severity,
              message: rule.message.replace("{component}", component.name),
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            });
            if (rule.severity === "error" || rule.severity === "block") {
              pass = false;
            }
          }
        } catch (error) {
          console.error(`Error evaluating rule ${rule.id} on component ${component.id}:`, error);
        }
      }
    }
    return {
      pass,
      violations,
      validatedComponents,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  /**
   * Get dependencies for a component
   */
  getComponentDependencies(componentId) {
    const component = this.getComponent(componentId);
    if (!component) return [];
    return component.dependencies.map((id) => this.getComponent(id)).filter((c) => c !== void 0);
  }
  /**
   * Get components that depend on a component
   */
  getDependentComponents(componentId) {
    return this.getComponents().filter(
      (c) => c.dependencies.includes(componentId)
    );
  }
};
var archGWService = new ArchGWService();

// server/routes/telemetry-routes.ts
var telemetryRouter = Router15();
telemetryRouter.get("/status", (req2, res2) => {
  const status = {
    openTelemetry: getOpenTelemetrySdk() !== null,
    postHog: getPostHogClient() !== null,
    langfuse: getLangfuseClient() !== null,
    stackStorm: getStackStormClient() !== null,
    archGW: true
    // Always available as it's a local service
  };
  res2.json({
    enabled: Object.values(status).some(Boolean),
    services: status
  });
});
telemetryRouter.post("/opentelemetry/init", (req2, res2) => {
  try {
    const sdk = initializeGlobalTelemetry();
    res2.json({ success: true, message: "OpenTelemetry initialized successfully" });
  } catch (error) {
    res2.status(500).json({
      success: false,
      message: "Failed to initialize OpenTelemetry",
      error: error.message
    });
  }
});
telemetryRouter.post("/track-event", (req2, res2) => {
  try {
    const { eventName, userId, properties } = req2.body;
    if (!eventName || !userId) {
      return res2.status(400).json({
        success: false,
        message: "Event name and user ID are required"
      });
    }
    trackEvent(eventName, userId, properties);
    res2.json({ success: true });
  } catch (error) {
    res2.status(500).json({
      success: false,
      message: "Failed to track event",
      error: error.message
    });
  }
});
telemetryRouter.get("/feature-flag/:flagKey/:userId", async (req2, res2) => {
  try {
    const { flagKey, userId } = req2.params;
    const defaultValue = req2.query.default === "true";
    const enabled = await isFeatureEnabled(flagKey, userId, defaultValue);
    res2.json({ enabled });
  } catch (error) {
    res2.status(500).json({
      success: false,
      message: "Failed to check feature flag",
      error: error.message
    });
  }
});
telemetryRouter.get("/feature-flags/:userId", async (req2, res2) => {
  try {
    const { userId } = req2.params;
    const flags = await getAllFeatureFlags(userId);
    res2.json({ flags });
  } catch (error) {
    res2.status(500).json({
      success: false,
      message: "Failed to get feature flags",
      error: error.message
    });
  }
});
telemetryRouter.post("/langfuse/trace", async (req2, res2) => {
  try {
    const { name, userId, metadata } = req2.body;
    if (!name) {
      return res2.status(400).json({
        success: false,
        message: "Trace name is required"
      });
    }
    const trace = createTrace(name, userId, metadata);
    res2.json({ success: true, traceId: trace?.id });
  } catch (error) {
    res2.status(500).json({
      success: false,
      message: "Failed to create trace",
      error: error.message
    });
  }
});
telemetryRouter.post("/langfuse/generation", async (req2, res2) => {
  try {
    const { traceId, name, model, prompt, completion, metadata } = req2.body;
    if (!name || !model || !prompt) {
      return res2.status(400).json({
        success: false,
        message: "Name, model, and prompt are required"
      });
    }
    const generation = trackGeneration(traceId, name, model, prompt, completion || "", metadata);
    res2.json({ success: true, generationId: generation?.id });
  } catch (error) {
    res2.status(500).json({
      success: false,
      message: "Failed to track generation",
      error: error.message
    });
  }
});
telemetryRouter.post("/stackstorm/security-incident", async (req2, res2) => {
  try {
    const { severity, description, metadata } = req2.body;
    if (!severity || !description) {
      return res2.status(400).json({
        success: false,
        message: "Severity and description are required"
      });
    }
    const result2 = await IncidentResponseActions.reportSecurityIncident(
      severity,
      description,
      metadata
    );
    res2.json({
      success: true,
      executionId: result2?.id,
      status: result2?.status
    });
  } catch (error) {
    res2.status(500).json({
      success: false,
      message: "Failed to report security incident",
      error: error.message
    });
  }
});
telemetryRouter.get("/arch/components", (req2, res2) => {
  const components = archGWService.getComponents();
  res2.json({ components });
});
telemetryRouter.post("/arch/components", (req2, res2) => {
  try {
    const component = req2.body;
    if (!component.id || !component.name || !component.type) {
      return res2.status(400).json({
        success: false,
        message: "ID, name, and type are required"
      });
    }
    const registeredComponent = archGWService.registerComponent(component);
    res2.json({ success: true, component: registeredComponent });
  } catch (error) {
    res2.status(500).json({
      success: false,
      message: "Failed to register component",
      error: error.message
    });
  }
});
telemetryRouter.get("/arch/rules", (req2, res2) => {
  const rules = archGWService.getRules();
  res2.json({ rules });
});
telemetryRouter.post("/arch/rules", (req2, res2) => {
  try {
    const rule = req2.body;
    if (!rule.id || !rule.name || !rule.type || !rule.condition) {
      return res2.status(400).json({
        success: false,
        message: "ID, name, type, and condition are required"
      });
    }
    const addedRule = archGWService.addRule(rule);
    res2.json({ success: true, rule: addedRule });
  } catch (error) {
    res2.status(500).json({
      success: false,
      message: "Failed to add rule",
      error: error.message
    });
  }
});
telemetryRouter.post("/arch/validate", (req2, res2) => {
  try {
    const result2 = archGWService.validateArchitecture();
    res2.json(result2);
  } catch (error) {
    res2.status(500).json({
      success: false,
      message: "Failed to validate architecture",
      error: error.message
    });
  }
});

// server/routes/airbyte-routes.ts
import { Router as Router16 } from "express";

// server/services/integrations/airbyte.ts
import axios8 from "axios";
var AirbyteClient = class {
  client;
  workspaceId;
  /**
   * Create a new Airbyte client
   * 
   * @param config Configuration for connecting to Airbyte
   */
  constructor(config) {
    this.workspaceId = config.workspaceId;
    const axiosConfig = {
      baseURL: config.apiUrl.endsWith("/") ? config.apiUrl : `${config.apiUrl}/`,
      headers: {
        "Content-Type": "application/json"
      }
    };
    if (config.apiKey) {
      axiosConfig.headers = {
        ...axiosConfig.headers,
        "Authorization": `Bearer ${config.apiKey}`
      };
    } else if (config.basicAuth) {
      const auth = btoa(`${config.basicAuth.username}:${config.basicAuth.password}`);
      axiosConfig.headers = {
        ...axiosConfig.headers,
        "Authorization": `Basic ${auth}`
      };
    }
    this.client = axios8.create(axiosConfig);
  }
  /**
   * Get all sources in the workspace
   */
  async getSources() {
    try {
      const response = await this.client.post("v1/sources/list", {
        workspaceId: this.workspaceId
      });
      return response.data.sources || [];
    } catch (error) {
      log(`Error getting Airbyte sources: ${error.message}`, "error");
      throw new Error(`Failed to get sources: ${error.message}`);
    }
  }
  /**
   * Create a new source
   * 
   * @param name Source name
   * @param sourceDefinitionId Source definition ID
   * @param connectionConfiguration Connection configuration
   * @returns Created source
   */
  async createSource(name, sourceDefinitionId, connectionConfiguration) {
    try {
      const response = await this.client.post("v1/sources/create", {
        name,
        sourceDefinitionId,
        workspaceId: this.workspaceId,
        connectionConfiguration
      });
      return response.data;
    } catch (error) {
      log(`Error creating Airbyte source: ${error.message}`, "error");
      throw new Error(`Failed to create source: ${error.message}`);
    }
  }
  /**
   * Get all destinations in the workspace
   */
  async getDestinations() {
    try {
      const response = await this.client.post("v1/destinations/list", {
        workspaceId: this.workspaceId
      });
      return response.data.destinations || [];
    } catch (error) {
      log(`Error getting Airbyte destinations: ${error.message}`, "error");
      throw new Error(`Failed to get destinations: ${error.message}`);
    }
  }
  /**
   * Create a new destination
   * 
   * @param name Destination name
   * @param destinationDefinitionId Destination definition ID
   * @param connectionConfiguration Connection configuration
   * @returns Created destination
   */
  async createDestination(name, destinationDefinitionId, connectionConfiguration) {
    try {
      const response = await this.client.post("v1/destinations/create", {
        name,
        destinationDefinitionId,
        workspaceId: this.workspaceId,
        connectionConfiguration
      });
      return response.data;
    } catch (error) {
      log(`Error creating Airbyte destination: ${error.message}`, "error");
      throw new Error(`Failed to create destination: ${error.message}`);
    }
  }
  /**
   * Get all connections in the workspace
   */
  async getConnections() {
    try {
      const response = await this.client.post("v1/connections/list", {
        workspaceId: this.workspaceId
      });
      return response.data.connections || [];
    } catch (error) {
      log(`Error getting Airbyte connections: ${error.message}`, "error");
      throw new Error(`Failed to get connections: ${error.message}`);
    }
  }
  /**
   * Create a new connection between source and destination
   * 
   * @param sourceId Source ID
   * @param destinationId Destination ID
   * @param name Connection name
   * @param syncCatalog Sync catalog
   * @param schedule Schedule configuration
   * @returns Created connection
   */
  async createConnection(sourceId, destinationId, name, syncCatalog, schedule) {
    try {
      const response = await this.client.post("v1/connections/create", {
        name,
        sourceId,
        destinationId,
        syncCatalog,
        schedule,
        status: "active"
      });
      return response.data;
    } catch (error) {
      log(`Error creating Airbyte connection: ${error.message}`, "error");
      throw new Error(`Failed to create connection: ${error.message}`);
    }
  }
  /**
   * Trigger a sync operation for a connection
   * 
   * @param connectionId Connection ID
   * @returns Sync operation response
   */
  async triggerSync(connectionId) {
    try {
      const response = await this.client.post("v1/connections/sync", {
        connectionId
      });
      return {
        jobId: response.data.job?.id,
        status: "pending"
      };
    } catch (error) {
      log(`Error triggering Airbyte sync: ${error.message}`, "error");
      throw new Error(`Failed to trigger sync: ${error.message}`);
    }
  }
  /**
   * Get the status of a sync job
   * 
   * @param jobId Job ID
   * @returns Job status
   */
  async getSyncStatus(jobId) {
    try {
      const response = await this.client.post("v1/jobs/get", {
        id: jobId
      });
      const job = response.data.job;
      return {
        jobId: job.id,
        status: job.status,
        startTime: job.createdAt ? new Date(job.createdAt).toISOString() : void 0,
        endTime: job.updatedAt ? new Date(job.updatedAt).toISOString() : void 0,
        bytesSynced: job.bytesSynced,
        recordsSynced: job.recordsSynced
      };
    } catch (error) {
      log(`Error getting Airbyte sync status: ${error.message}`, "error");
      throw new Error(`Failed to get sync status: ${error.message}`);
    }
  }
  /**
   * Test connection to Airbyte API
   * 
   * @returns True if connection is successful
   */
  async testConnection() {
    try {
      const response = await this.client.post("v1/workspaces/list");
      return Array.isArray(response.data.workspaces);
    } catch (error) {
      log(`Error testing Airbyte connection: ${error.message}`, "error");
      return false;
    }
  }
};
function createAirbyteClient(config) {
  return new AirbyteClient(config);
}

// server/routes/airbyte-routes.ts
var isAuthenticated9 = (req2, res2, next) => {
  if (req2.isAuthenticated()) {
    return next();
  }
  res2.status(401).json({ message: "Unauthorized" });
};
var router19 = Router16();
var airbyteClients = /* @__PURE__ */ new Map();
async function getAirbyteClient(userId) {
  if (airbyteClients.has(userId)) {
    return airbyteClients.get(userId);
  }
  try {
    const config = await storage.getAirbyteConfig(userId);
    if (!config) {
      return null;
    }
    const client = createAirbyteClient(JSON.parse(config.configJson));
    airbyteClients.set(userId, client);
    return client;
  } catch (error) {
    log(`Error getting Airbyte client: ${error.message}`, "error");
    return null;
  }
}
router19.post("/test-connection", isAuthenticated9, async (req2, res2) => {
  try {
    const user = req2.user;
    const { config } = req2.body;
    if (!config || typeof config !== "object") {
      return res2.status(400).json({ message: "Invalid configuration provided" });
    }
    const client = createAirbyteClient(config);
    const success = await client.testConnection();
    if (success) {
      res2.json({ success: true });
    } else {
      res2.status(400).json({ message: "Failed to connect to Airbyte API" });
    }
  } catch (error) {
    log(`Error testing Airbyte connection: ${error.message}`, "error");
    res2.status(500).json({ message: `Error testing connection: ${error.message}` });
  }
});
router19.post("/save-config", isAuthenticated9, async (req2, res2) => {
  try {
    const user = req2.user;
    const { config } = req2.body;
    if (!config || typeof config !== "object") {
      return res2.status(400).json({ message: "Invalid configuration provided" });
    }
    const client = createAirbyteClient(config);
    const success = await client.testConnection();
    if (!success) {
      return res2.status(400).json({ message: "Configuration validation failed" });
    }
    await storage.saveAirbyteConfig(user.id, {
      userId: user.id,
      configJson: JSON.stringify(config)
    });
    airbyteClients.set(user.id, client);
    res2.json({ success: true });
  } catch (error) {
    log(`Error saving Airbyte configuration: ${error.message}`, "error");
    res2.status(500).json({ message: `Error saving configuration: ${error.message}` });
  }
});
router19.get("/sources", isAuthenticated9, async (req2, res2) => {
  try {
    const user = req2.user;
    const sources = await storage.getAirbyteSources(user.id);
    res2.json(sources);
  } catch (error) {
    log(`Error fetching Airbyte sources: ${error.message}`, "error");
    res2.status(500).json({ message: `Error fetching sources: ${error.message}` });
  }
});
router19.post("/sources", isAuthenticated9, async (req2, res2) => {
  try {
    const user = req2.user;
    const validatedData = insertAirbyteSourceSchema.parse(req2.body);
    const client = await getAirbyteClient(user.id);
    if (!client) {
      return res2.status(400).json({ message: "Airbyte is not configured" });
    }
    const sourceResult = await client.createSource(
      validatedData.name,
      validatedData.sourceDefinitionId,
      validatedData.connectionConfiguration
    );
    const source = await storage.createAirbyteSource({
      userId: user.id,
      sourceId: sourceResult.sourceId,
      sourceDefinitionId: validatedData.sourceDefinitionId,
      name: validatedData.name,
      connectionConfiguration: validatedData.connectionConfiguration,
      workspaceId: validatedData.workspaceId
    });
    res2.status(201).json(source);
  } catch (error) {
    log(`Error creating Airbyte source: ${error.message}`, "error");
    res2.status(500).json({ message: `Error creating source: ${error.message}` });
  }
});
router19.get("/destinations", isAuthenticated9, async (req2, res2) => {
  try {
    const user = req2.user;
    const destinations = await storage.getAirbyteDestinations(user.id);
    res2.json(destinations);
  } catch (error) {
    log(`Error fetching Airbyte destinations: ${error.message}`, "error");
    res2.status(500).json({ message: `Error fetching destinations: ${error.message}` });
  }
});
router19.post("/destinations", isAuthenticated9, async (req2, res2) => {
  try {
    const user = req2.user;
    const validatedData = insertAirbyteDestinationSchema.parse(req2.body);
    const client = await getAirbyteClient(user.id);
    if (!client) {
      return res2.status(400).json({ message: "Airbyte is not configured" });
    }
    const destinationResult = await client.createDestination(
      validatedData.name,
      validatedData.destinationDefinitionId,
      validatedData.connectionConfiguration
    );
    const destination = await storage.createAirbyteDestination({
      userId: user.id,
      destinationId: destinationResult.destinationId,
      destinationDefinitionId: validatedData.destinationDefinitionId,
      name: validatedData.name,
      connectionConfiguration: validatedData.connectionConfiguration,
      workspaceId: validatedData.workspaceId
    });
    res2.status(201).json(destination);
  } catch (error) {
    log(`Error creating Airbyte destination: ${error.message}`, "error");
    res2.status(500).json({ message: `Error creating destination: ${error.message}` });
  }
});
router19.get("/connections", isAuthenticated9, async (req2, res2) => {
  try {
    const user = req2.user;
    const connections = await storage.getAirbyteConnections(user.id);
    res2.json(connections);
  } catch (error) {
    log(`Error fetching Airbyte connections: ${error.message}`, "error");
    res2.status(500).json({ message: `Error fetching connections: ${error.message}` });
  }
});
router19.post("/connections", isAuthenticated9, async (req2, res2) => {
  try {
    const user = req2.user;
    const validatedData = insertAirbyteConnectionSchema.parse(req2.body);
    const client = await getAirbyteClient(user.id);
    if (!client) {
      return res2.status(400).json({ message: "Airbyte is not configured" });
    }
    const source = await storage.getAirbyteSource(validatedData.sourceId);
    const destination = await storage.getAirbyteDestination(validatedData.destinationId);
    if (!source || !destination) {
      return res2.status(400).json({ message: "Invalid source or destination" });
    }
    const connectionResult = await client.createConnection(
      source.sourceId,
      destination.destinationId,
      validatedData.name,
      validatedData.syncCatalog,
      validatedData.schedule
    );
    const connection = await storage.createAirbyteConnection({
      userId: user.id,
      connectionId: connectionResult.connectionId,
      sourceId: source.id,
      destinationId: destination.id,
      name: validatedData.name,
      syncCatalog: validatedData.syncCatalog,
      status: validatedData.status,
      schedule: validatedData.schedule
    });
    res2.status(201).json(connection);
  } catch (error) {
    log(`Error creating Airbyte connection: ${error.message}`, "error");
    res2.status(500).json({ message: `Error creating connection: ${error.message}` });
  }
});
router19.post("/trigger-sync/:connectionId", isAuthenticated9, async (req2, res2) => {
  try {
    const user = req2.user;
    const connectionId = parseInt(req2.params.connectionId);
    if (isNaN(connectionId)) {
      return res2.status(400).json({ message: "Invalid connection ID" });
    }
    const connection = await storage.getAirbyteConnection(connectionId);
    if (!connection || connection.userId !== user.id) {
      return res2.status(404).json({ message: "Connection not found" });
    }
    const client = await getAirbyteClient(user.id);
    if (!client) {
      return res2.status(400).json({ message: "Airbyte is not configured" });
    }
    const syncResult = await client.triggerSync(connection.connectionId);
    const job = await storage.createAirbyteSyncJob({
      userId: user.id,
      connectionId: connection.id,
      jobId: syncResult.jobId,
      status: "pending"
    });
    res2.json(job);
  } catch (error) {
    log(`Error triggering Airbyte sync: ${error.message}`, "error");
    res2.status(500).json({ message: `Error triggering sync: ${error.message}` });
  }
});
router19.get("/sync-jobs", isAuthenticated9, async (req2, res2) => {
  try {
    const user = req2.user;
    const jobs = await storage.getAirbyteSyncJobs(user.id);
    res2.json(jobs);
  } catch (error) {
    log(`Error fetching Airbyte sync jobs: ${error.message}`, "error");
    res2.status(500).json({ message: `Error fetching sync jobs: ${error.message}` });
  }
});
router19.get("/sync-jobs/:id", isAuthenticated9, async (req2, res2) => {
  try {
    const user = req2.user;
    const jobId = parseInt(req2.params.id);
    if (isNaN(jobId)) {
      return res2.status(400).json({ message: "Invalid job ID" });
    }
    const job = await storage.getAirbyteSyncJob(jobId);
    if (!job || job.userId !== user.id) {
      return res2.status(404).json({ message: "Job not found" });
    }
    if (job.status !== "pending" && job.status !== "running") {
      return res2.json(job);
    }
    const client = await getAirbyteClient(user.id);
    if (!client || !job.jobId) {
      return res2.json(job);
    }
    const jobStatus = await client.getSyncStatus(job.jobId);
    if (jobStatus && jobStatus.status !== job.status) {
      const updatedJob = await storage.updateAirbyteSyncJob(job.id, {
        status: jobStatus.status,
        startTime: jobStatus.startTime,
        endTime: jobStatus.endTime,
        bytesSynced: jobStatus.bytesSynced,
        recordsSynced: jobStatus.recordsSynced
      });
      return res2.json(updatedJob);
    }
    res2.json(job);
  } catch (error) {
    log(`Error fetching Airbyte sync job status: ${error.message}`, "error");
    res2.status(500).json({ message: `Error fetching job status: ${error.message}` });
  }
});
var airbyte_routes_default = router19;

// server/routes/composio-routes.ts
import { Router as Router17 } from "express";

// server/services/integrations/composio.ts
import axios9 from "axios";
var ComposioClient = class {
  client;
  organizationId;
  /**
   * Create a new Composio client
   * 
   * @param config Configuration for connecting to Composio
   */
  constructor(config) {
    this.organizationId = config.organizationId;
    const axiosConfig = {
      baseURL: config.apiUrl.endsWith("/") ? config.apiUrl : `${config.apiUrl}/`,
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${config.apiKey}`
      }
    };
    this.client = axios9.create(axiosConfig);
  }
  /**
   * Get all workflows
   */
  async getWorkflows() {
    try {
      const response = await this.client.get("workflows", {
        params: this.organizationId ? { organizationId: this.organizationId } : void 0
      });
      return response.data.workflows || [];
    } catch (error) {
      log(`Error getting Composio workflows: ${error.message}`, "error");
      throw new Error(`Failed to get workflows: ${error.message}`);
    }
  }
  /**
   * Get workflow by ID
   * 
   * @param workflowId Workflow ID
   */
  async getWorkflow(workflowId) {
    try {
      const response = await this.client.get(`workflows/${workflowId}`);
      return response.data;
    } catch (error) {
      log(`Error getting Composio workflow: ${error.message}`, "error");
      throw new Error(`Failed to get workflow: ${error.message}`);
    }
  }
  /**
   * Create a new workflow
   * 
   * @param name Workflow name
   * @param description Workflow description
   * @param definition Workflow definition
   */
  async createWorkflow(name, description, definition) {
    try {
      const response = await this.client.post("workflows", {
        name,
        description,
        definition,
        ...this.organizationId ? { organizationId: this.organizationId } : {}
      });
      return response.data;
    } catch (error) {
      log(`Error creating Composio workflow: ${error.message}`, "error");
      throw new Error(`Failed to create workflow: ${error.message}`);
    }
  }
  /**
   * Update an existing workflow
   * 
   * @param workflowId Workflow ID
   * @param updates Updates to apply to the workflow
   */
  async updateWorkflow(workflowId, updates) {
    try {
      const response = await this.client.patch(`workflows/${workflowId}`, updates);
      return response.data;
    } catch (error) {
      log(`Error updating Composio workflow: ${error.message}`, "error");
      throw new Error(`Failed to update workflow: ${error.message}`);
    }
  }
  /**
   * Delete a workflow
   * 
   * @param workflowId Workflow ID
   */
  async deleteWorkflow(workflowId) {
    try {
      await this.client.delete(`workflows/${workflowId}`);
      return true;
    } catch (error) {
      log(`Error deleting Composio workflow: ${error.message}`, "error");
      throw new Error(`Failed to delete workflow: ${error.message}`);
    }
  }
  /**
   * Get workflow executions
   * 
   * @param workflowId Workflow ID
   */
  async getExecutions(workflowId) {
    try {
      const response = await this.client.get("executions", {
        params: {
          ...workflowId ? { workflowId } : {},
          ...this.organizationId ? { organizationId: this.organizationId } : {}
        }
      });
      return response.data.executions || [];
    } catch (error) {
      log(`Error getting Composio executions: ${error.message}`, "error");
      throw new Error(`Failed to get executions: ${error.message}`);
    }
  }
  /**
   * Get execution details
   * 
   * @param executionId Execution ID
   */
  async getExecution(executionId) {
    try {
      const response = await this.client.get(`executions/${executionId}`);
      return response.data;
    } catch (error) {
      log(`Error getting Composio execution: ${error.message}`, "error");
      throw new Error(`Failed to get execution: ${error.message}`);
    }
  }
  /**
   * Trigger workflow execution
   * 
   * @param workflowId Workflow ID
   * @param input Input data for the workflow
   */
  async triggerWorkflow(workflowId, input2) {
    try {
      const response = await this.client.post("executions", {
        workflowId,
        input: input2
      });
      return response.data;
    } catch (error) {
      log(`Error triggering Composio workflow: ${error.message}`, "error");
      throw new Error(`Failed to trigger workflow: ${error.message}`);
    }
  }
  /**
   * Test connection to Composio API
   */
  async testConnection() {
    try {
      await this.getWorkflows();
      return true;
    } catch (error) {
      log(`Error testing Composio connection: ${error.message}`, "error");
      return false;
    }
  }
};
function createComposioClient(config) {
  return new ComposioClient(config);
}

// server/routes/composio-routes.ts
import { z as z11 } from "zod";
var isAuthenticated10 = (req2, res2, next) => {
  if (req2.isAuthenticated()) {
    return next();
  }
  res2.status(401).json({ message: "Unauthorized" });
};
var router20 = Router17();
var composioClients = /* @__PURE__ */ new Map();
router20.get("/config", isAuthenticated10, async (req2, res2) => {
  try {
    const user = req2.user;
    const userId = user.id;
    const config = await storage.getComposioConfig(userId);
    if (!config) {
      return res2.status(404).json({ message: "Composio configuration not found" });
    }
    res2.json(config);
  } catch (error) {
    log(`Error fetching Composio configuration: ${error instanceof Error ? error.message : "Unknown error"}`, "error");
    res2.status(500).json({ message: "Failed to fetch Composio configuration" });
  }
});
router20.post("/config", isAuthenticated10, async (req2, res2) => {
  try {
    const user = req2.user;
    const userId = user.id;
    const { configJson } = req2.body;
    if (!configJson) {
      return res2.status(400).json({ message: "Configuration JSON is required" });
    }
    try {
      const configObj = typeof configJson === "string" ? JSON.parse(configJson) : configJson;
      const client = createComposioClient(configObj);
      const success = await client.testConnection();
      if (!success) {
        return res2.status(400).json({ message: "Configuration validation failed" });
      }
      const validatedData = insertComposioConfigSchema.parse({
        userId,
        configJson: typeof configJson === "string" ? configJson : JSON.stringify(configJson)
      });
      const savedConfig = await storage.saveComposioConfig(userId, validatedData);
      composioClients.set(userId, client);
      res2.json(savedConfig);
    } catch (validationError) {
      if (validationError instanceof z11.ZodError) {
        return res2.status(400).json({ message: "Invalid configuration format", errors: validationError.errors });
      }
      throw validationError;
    }
  } catch (error) {
    log(`Error saving Composio configuration: ${error instanceof Error ? error.message : "Unknown error"}`, "error");
    res2.status(500).json({ message: "Failed to save Composio configuration" });
  }
});
router20.get("/workflows", isAuthenticated10, async (req2, res2) => {
  try {
    const user = req2.user;
    const userId = user.id;
    const workflows2 = await storage.getComposioWorkflows(userId);
    res2.json(workflows2);
  } catch (error) {
    log(`Error fetching Composio workflows: ${error instanceof Error ? error.message : "Unknown error"}`, "error");
    res2.status(500).json({ message: "Failed to fetch Composio workflows" });
  }
});
router20.get("/workflows/:id", isAuthenticated10, async (req2, res2) => {
  try {
    const { id } = req2.params;
    const user = req2.user;
    const workflowId = parseInt(id);
    if (isNaN(workflowId)) {
      return res2.status(400).json({ message: "Invalid workflow ID" });
    }
    const workflow = await storage.getComposioWorkflow(workflowId);
    if (!workflow) {
      return res2.status(404).json({ message: "Workflow not found" });
    }
    if (workflow.userId !== user.id) {
      return res2.status(403).json({ message: "Access denied" });
    }
    res2.json(workflow);
  } catch (error) {
    log(`Error fetching Composio workflow: ${error instanceof Error ? error.message : "Unknown error"}`, "error");
    res2.status(500).json({ message: "Failed to fetch Composio workflow" });
  }
});
router20.post("/workflows", isAuthenticated10, async (req2, res2) => {
  try {
    const user = req2.user;
    const userId = user.id;
    try {
      let statusValue = "draft" /* DRAFT */;
      if (req2.body.status && Object.values(ComposioWorkflowStatusType).includes(req2.body.status)) {
        statusValue = req2.body.status;
      }
      const workflowData = {
        name: req2.body.name,
        workflowId: req2.body.workflowId,
        userId,
        definition: req2.body.definition || {},
        status: statusValue,
        description: req2.body.description,
        version: req2.body.version || 1
      };
      const validatedData = insertComposioWorkflowSchema.parse(workflowData);
      const newWorkflow = await storage.createComposioWorkflow(validatedData);
      res2.status(201).json(newWorkflow);
    } catch (validationError) {
      if (validationError instanceof z11.ZodError) {
        return res2.status(400).json({ message: "Invalid workflow data", errors: validationError.errors });
      }
      throw validationError;
    }
  } catch (error) {
    log(`Error creating Composio workflow: ${error instanceof Error ? error.message : "Unknown error"}`, "error");
    res2.status(500).json({ message: "Failed to create Composio workflow" });
  }
});
router20.put("/workflows/:id", isAuthenticated10, async (req2, res2) => {
  try {
    const { id } = req2.params;
    const user = req2.user;
    const workflowId = parseInt(id);
    if (isNaN(workflowId)) {
      return res2.status(400).json({ message: "Invalid workflow ID" });
    }
    const existingWorkflow = await storage.getComposioWorkflow(workflowId);
    if (!existingWorkflow) {
      return res2.status(404).json({ message: "Workflow not found" });
    }
    if (existingWorkflow.userId !== user.id) {
      return res2.status(403).json({ message: "Access denied" });
    }
    try {
      const updates = {
        ...req2.body,
        updatedAt: /* @__PURE__ */ new Date()
      };
      const updatedWorkflow = await storage.updateComposioWorkflow(workflowId, updates);
      res2.json(updatedWorkflow);
    } catch (validationError) {
      if (validationError instanceof z11.ZodError) {
        return res2.status(400).json({ message: "Invalid workflow data", errors: validationError.errors });
      }
      throw validationError;
    }
  } catch (error) {
    log(`Error updating Composio workflow: ${error instanceof Error ? error.message : "Unknown error"}`, "error");
    res2.status(500).json({ message: "Failed to update Composio workflow" });
  }
});
router20.delete("/workflows/:id", isAuthenticated10, async (req2, res2) => {
  try {
    const { id } = req2.params;
    const user = req2.user;
    const workflowId = parseInt(id);
    if (isNaN(workflowId)) {
      return res2.status(400).json({ message: "Invalid workflow ID" });
    }
    const existingWorkflow = await storage.getComposioWorkflow(workflowId);
    if (!existingWorkflow) {
      return res2.status(404).json({ message: "Workflow not found" });
    }
    if (existingWorkflow.userId !== user.id) {
      return res2.status(403).json({ message: "Access denied" });
    }
    const result2 = await storage.deleteComposioWorkflow(workflowId);
    if (result2) {
      res2.status(204).end();
    } else {
      res2.status(500).json({ message: "Failed to delete workflow" });
    }
  } catch (error) {
    log(`Error deleting Composio workflow: ${error instanceof Error ? error.message : "Unknown error"}`, "error");
    res2.status(500).json({ message: "Failed to delete Composio workflow" });
  }
});
router20.get("/workflows/:workflowId/triggers", isAuthenticated10, async (req2, res2) => {
  try {
    const { workflowId } = req2.params;
    const user = req2.user;
    const workflowIdNum = parseInt(workflowId);
    if (isNaN(workflowIdNum)) {
      return res2.status(400).json({ message: "Invalid workflow ID" });
    }
    const workflow = await storage.getComposioWorkflow(workflowIdNum);
    if (!workflow) {
      return res2.status(404).json({ message: "Workflow not found" });
    }
    if (workflow.userId !== user.id) {
      return res2.status(403).json({ message: "Access denied" });
    }
    const triggers = await storage.getComposioTriggers(workflowIdNum);
    res2.json(triggers);
  } catch (error) {
    log(`Error fetching Composio triggers: ${error instanceof Error ? error.message : "Unknown error"}`, "error");
    res2.status(500).json({ message: "Failed to fetch Composio triggers" });
  }
});
router20.post("/workflows/:workflowId/triggers", isAuthenticated10, async (req2, res2) => {
  try {
    const { workflowId } = req2.params;
    const user = req2.user;
    const userId = user.id;
    const workflowIdNum = parseInt(workflowId);
    if (isNaN(workflowIdNum)) {
      return res2.status(400).json({ message: "Invalid workflow ID" });
    }
    const workflow = await storage.getComposioWorkflow(workflowIdNum);
    if (!workflow) {
      return res2.status(404).json({ message: "Workflow not found" });
    }
    if (workflow.userId !== userId) {
      return res2.status(403).json({ message: "Access denied" });
    }
    try {
      const validatedData = insertComposioTriggerSchema.parse({
        ...req2.body,
        userId,
        workflowId: workflowIdNum,
        configuration: req2.body.configuration || {}
      });
      const newTrigger = await storage.createComposioTrigger(validatedData);
      res2.status(201).json(newTrigger);
    } catch (validationError) {
      if (validationError instanceof z11.ZodError) {
        return res2.status(400).json({ message: "Invalid trigger data", errors: validationError.errors });
      }
      throw validationError;
    }
  } catch (error) {
    log(`Error creating Composio trigger: ${error instanceof Error ? error.message : "Unknown error"}`, "error");
    res2.status(500).json({ message: "Failed to create Composio trigger" });
  }
});
router20.get("/workflows/:workflowId/actions", isAuthenticated10, async (req2, res2) => {
  try {
    const { workflowId } = req2.params;
    const user = req2.user;
    const workflowIdNum = parseInt(workflowId);
    if (isNaN(workflowIdNum)) {
      return res2.status(400).json({ message: "Invalid workflow ID" });
    }
    const workflow = await storage.getComposioWorkflow(workflowIdNum);
    if (!workflow) {
      return res2.status(404).json({ message: "Workflow not found" });
    }
    if (workflow.userId !== user.id) {
      return res2.status(403).json({ message: "Access denied" });
    }
    const actions = await storage.getComposioActions(workflowIdNum);
    res2.json(actions);
  } catch (error) {
    log(`Error fetching Composio actions: ${error instanceof Error ? error.message : "Unknown error"}`, "error");
    res2.status(500).json({ message: "Failed to fetch Composio actions" });
  }
});
router20.post("/workflows/:workflowId/actions", isAuthenticated10, async (req2, res2) => {
  try {
    const { workflowId } = req2.params;
    const user = req2.user;
    const userId = user.id;
    const workflowIdNum = parseInt(workflowId);
    if (isNaN(workflowIdNum)) {
      return res2.status(400).json({ message: "Invalid workflow ID" });
    }
    const workflow = await storage.getComposioWorkflow(workflowIdNum);
    if (!workflow) {
      return res2.status(404).json({ message: "Workflow not found" });
    }
    if (workflow.userId !== userId) {
      return res2.status(403).json({ message: "Access denied" });
    }
    try {
      const validatedData = insertComposioActionSchema.parse({
        ...req2.body,
        userId,
        workflowId: workflowIdNum,
        configuration: req2.body.configuration || {}
      });
      const newAction = await storage.createComposioAction(validatedData);
      res2.status(201).json(newAction);
    } catch (validationError) {
      if (validationError instanceof z11.ZodError) {
        return res2.status(400).json({ message: "Invalid action data", errors: validationError.errors });
      }
      throw validationError;
    }
  } catch (error) {
    log(`Error creating Composio action: ${error instanceof Error ? error.message : "Unknown error"}`, "error");
    res2.status(500).json({ message: "Failed to create Composio action" });
  }
});
router20.get("/executions", isAuthenticated10, async (req2, res2) => {
  try {
    const user = req2.user;
    const userId = user.id;
    const { workflowId } = req2.query;
    let workflowIdParam = void 0;
    if (workflowId) {
      workflowIdParam = parseInt(workflowId);
      if (isNaN(workflowIdParam)) {
        return res2.status(400).json({ message: "Invalid workflow ID" });
      }
      const workflow = await storage.getComposioWorkflow(workflowIdParam);
      if (workflow && workflow.userId !== userId) {
        return res2.status(403).json({ message: "Access denied" });
      }
    }
    const executions = await storage.getComposioExecutions(userId, workflowIdParam);
    res2.json(executions);
  } catch (error) {
    log(`Error fetching Composio executions: ${error instanceof Error ? error.message : "Unknown error"}`, "error");
    res2.status(500).json({ message: "Failed to fetch Composio executions" });
  }
});
router20.get("/executions/:id", isAuthenticated10, async (req2, res2) => {
  try {
    const { id } = req2.params;
    const user = req2.user;
    const executionId = parseInt(id);
    if (isNaN(executionId)) {
      return res2.status(400).json({ message: "Invalid execution ID" });
    }
    const execution = await storage.getComposioExecution(executionId);
    if (!execution) {
      return res2.status(404).json({ message: "Execution not found" });
    }
    if (execution.userId !== user.id) {
      return res2.status(403).json({ message: "Access denied" });
    }
    res2.json(execution);
  } catch (error) {
    log(`Error fetching Composio execution: ${error instanceof Error ? error.message : "Unknown error"}`, "error");
    res2.status(500).json({ message: "Failed to fetch Composio execution" });
  }
});
router20.post("/executions", isAuthenticated10, async (req2, res2) => {
  try {
    const user = req2.user;
    const userId = user.id;
    const { workflowId, triggerId, executionId, input: input2 } = req2.body;
    if (!workflowId || !executionId) {
      return res2.status(400).json({ message: "Workflow ID and execution ID are required" });
    }
    const workflowIdNum = parseInt(workflowId);
    if (isNaN(workflowIdNum)) {
      return res2.status(400).json({ message: "Invalid workflow ID" });
    }
    const workflow = await storage.getComposioWorkflow(workflowIdNum);
    if (!workflow) {
      return res2.status(404).json({ message: "Workflow not found" });
    }
    if (workflow.userId !== userId) {
      return res2.status(403).json({ message: "Access denied" });
    }
    let triggerIdNum = null;
    if (triggerId) {
      const triggerIdParsed = parseInt(triggerId);
      if (isNaN(triggerIdParsed)) {
        return res2.status(400).json({ message: "Invalid trigger ID" });
      }
      const trigger = await storage.getComposioTrigger(triggerIdParsed);
      if (!trigger) {
        return res2.status(404).json({ message: "Trigger not found" });
      }
      if (trigger.workflowId !== workflowIdNum) {
        return res2.status(400).json({ message: "Trigger does not belong to specified workflow" });
      }
      triggerIdNum = trigger.id;
    }
    try {
      const executionData = {
        userId,
        workflowId: workflowIdNum,
        triggerId: triggerIdNum,
        executionId,
        status: "pending" /* PENDING */,
        startTime: /* @__PURE__ */ new Date(),
        input: input2 || {}
      };
      const validatedData = insertComposioExecutionSchema.parse(executionData);
      const newExecution = await storage.createComposioExecution(validatedData);
      res2.status(201).json(newExecution);
    } catch (validationError) {
      if (validationError instanceof z11.ZodError) {
        return res2.status(400).json({ message: "Invalid execution data", errors: validationError.errors });
      }
      throw validationError;
    }
  } catch (error) {
    log(`Error creating Composio execution: ${error instanceof Error ? error.message : "Unknown error"}`, "error");
    res2.status(500).json({ message: "Failed to create Composio execution" });
  }
});
router20.put("/executions/:id", isAuthenticated10, async (req2, res2) => {
  try {
    const { id } = req2.params;
    const user = req2.user;
    const { status, output, error } = req2.body;
    const executionId = parseInt(id);
    if (isNaN(executionId)) {
      return res2.status(400).json({ message: "Invalid execution ID" });
    }
    const existingExecution = await storage.getComposioExecution(executionId);
    if (!existingExecution) {
      return res2.status(404).json({ message: "Execution not found" });
    }
    if (existingExecution.userId !== user.id) {
      return res2.status(403).json({ message: "Access denied" });
    }
    try {
      const updates = {
        output,
        error
      };
      if (status) {
        updates.status = status;
        if (status === "completed" /* COMPLETED */ || status === "failed" /* FAILED */) {
          updates.endTime = /* @__PURE__ */ new Date();
        }
      }
      if (updates.status && typeof updates.status === "string") {
        if (Object.values(ComposioExecutionStatusType).includes(updates.status)) {
          updates.status = updates.status;
        } else {
          return res2.status(400).json({ message: "Invalid execution status" });
        }
      }
      const updatedExecution = await storage.updateComposioExecution(executionId, updates);
      res2.json(updatedExecution);
    } catch (validationError) {
      if (validationError instanceof z11.ZodError) {
        return res2.status(400).json({ message: "Invalid execution data", errors: validationError.errors });
      }
      throw validationError;
    }
  } catch (error) {
    log(`Error updating Composio execution: ${error instanceof Error ? error.message : "Unknown error"}`, "error");
    res2.status(500).json({ message: "Failed to update Composio execution" });
  }
});
var composio_routes_default = router20;

// server/routes/slack-routes.ts
import express6 from "express";

// server/services/integrations/slack.ts
import { WebClient } from "@slack/web-api";
var SlackService = class {
  client;
  isInitialized = false;
  channelId;
  constructor() {
    this.client = new WebClient();
  }
  /**
   * Initialize the Slack client with API token
   * @param token Slack Bot Token (xoxb-...)
   * @param channelId Default channel ID to post messages to
   * @returns True if initialized successfully
   */
  initialize(token, channelId) {
    try {
      this.client = new WebClient(token);
      this.channelId = channelId;
      this.isInitialized = true;
      console.info("Slack service initialized");
      return true;
    } catch (error) {
      console.error("Failed to initialize Slack service", error);
      this.isInitialized = false;
      return false;
    }
  }
  /**
   * Check if the service is properly initialized
   * @returns True if initialized with valid token
   */
  async isConnected() {
    if (!this.isInitialized) return false;
    try {
      const auth = await this.client.auth.test();
      return !!auth.ok;
    } catch (error) {
      console.error("Slack connection test failed", error);
      return false;
    }
  }
  /**
   * Send a simple text message to a Slack channel
   * @param text Message text
   * @param channel Channel ID (optional, uses default if not provided)
   * @returns Message timestamp if successful
   */
  async sendMessage(text2, channel) {
    if (!this.isInitialized) {
      throw new Error("Slack service not initialized");
    }
    const targetChannel = channel || this.channelId;
    if (!targetChannel) {
      throw new Error("No target channel specified for Slack message");
    }
    try {
      const result2 = await this.client.chat.postMessage({
        channel: targetChannel,
        text: text2
      });
      console.debug(`Sent message to Slack channel: ${targetChannel}`);
      return result2.ts;
    } catch (error) {
      console.error("Failed to send Slack message", error);
      throw new Error(`Failed to send Slack message: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Send a rich/structured message to Slack using blocks
   * @param message Full message configuration including blocks
   * @returns Message timestamp if successful
   */
  async sendRichMessage(message) {
    if (!this.isInitialized) {
      throw new Error("Slack service not initialized");
    }
    if (!message.channel && this.channelId) {
      message.channel = this.channelId;
    }
    if (!message.channel) {
      throw new Error("No target channel specified for Slack message");
    }
    try {
      const result2 = await this.client.chat.postMessage(message);
      console.debug(`Sent rich message to Slack channel: ${message.channel}`);
      return result2.ts;
    } catch (error) {
      console.error("Failed to send rich Slack message", error);
      throw new Error(`Failed to send rich Slack message: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get messages from a channel
   * @param channel Channel ID to fetch history from
   * @param limit Maximum number of messages to retrieve (default: 100)
   * @returns Channel history response
   */
  async getChannelHistory(channel, limit = 100) {
    if (!this.isInitialized) {
      throw new Error("Slack service not initialized");
    }
    const targetChannel = channel || this.channelId;
    if (!targetChannel) {
      throw new Error("No target channel specified for fetching Slack history");
    }
    try {
      const result2 = await this.client.conversations.history({
        channel: targetChannel,
        limit
      });
      console.debug(`Retrieved ${result2.messages?.length || 0} messages from Slack channel: ${targetChannel}`);
      return result2;
    } catch (error) {
      console.error("Failed to fetch Slack channel history", error);
      throw new Error(`Failed to fetch Slack channel history: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get list of channels the bot has access to
   * @returns List of channels
   */
  async listChannels() {
    if (!this.isInitialized) {
      throw new Error("Slack service not initialized");
    }
    try {
      const result2 = await this.client.conversations.list();
      console.debug(`Retrieved ${result2.channels?.length || 0} Slack channels`);
      return result2;
    } catch (error) {
      console.error("Failed to list Slack channels", error);
      throw new Error(`Failed to list Slack channels: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Get information about a specific channel
   * @param channelId Channel ID to get info for
   * @returns Channel info
   */
  async getChannelInfo(channelId) {
    if (!this.isInitialized) {
      throw new Error("Slack service not initialized");
    }
    try {
      const result2 = await this.client.conversations.info({
        channel: channelId
      });
      return result2;
    } catch (error) {
      console.error(`Failed to get info for Slack channel: ${channelId}`, error);
      throw new Error(`Failed to get Slack channel info: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Post a file to a Slack channel
   * @param channel Channel to upload file to
   * @param options Upload options
   * @returns Upload response
   */
  async uploadFile(channel, options2) {
    if (!this.isInitialized) {
      throw new Error("Slack service not initialized");
    }
    try {
      const uploadParams = {
        channels: channel,
        ...options2
      };
      const result2 = await this.client.files.upload(uploadParams);
      console.debug(`Uploaded file to Slack channel: ${channel}`);
      return result2;
    } catch (error) {
      console.error("Failed to upload file to Slack", error);
      throw new Error(`Failed to upload file to Slack: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
};
var slackService = new SlackService();

// server/routes/slack-routes.ts
import { z as z12 } from "zod";
var isAuthenticated11 = (req2, res2, next) => {
  if (req2.isAuthenticated()) {
    return next();
  }
  res2.status(401).json({ message: "Unauthorized" });
};
var router21 = express6.Router();
router21.use(isAuthenticated11);
router21.get("/config", async (req2, res2) => {
  try {
    const userId = req2.user.id;
    const config = await storage.getSlackConfig(userId);
    if (!config) {
      return res2.status(404).json({ message: "No Slack configuration found" });
    }
    res2.json(config);
  } catch (error) {
    console.error("Error getting Slack config:", error);
    res2.status(500).json({ message: "Failed to get Slack configuration" });
  }
});
router21.post("/config", async (req2, res2) => {
  try {
    const userId = req2.user.id;
    const configData = insertSlackConfigSchema.parse({
      ...req2.body,
      userId,
      isActive: true,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    });
    const config = await storage.createSlackConfig(configData);
    const connectionSuccess = slackService.initialize(config.botToken, config.defaultChannelId);
    if (!connectionSuccess) {
      await storage.updateSlackConfig(config.id, {
        connectionStatus: "error" /* Error */,
        lastConnectionError: "Failed to connect to Slack API",
        updatedAt: /* @__PURE__ */ new Date()
      });
      return res2.status(400).json({ message: "Failed to connect to Slack API with provided credentials" });
    }
    await storage.updateSlackConfig(config.id, {
      connectionStatus: "connected" /* Connected */,
      lastConnectionError: null,
      lastConnectedAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    });
    res2.status(201).json(config);
  } catch (error) {
    console.error("Error creating Slack config:", error);
    if (error instanceof z12.ZodError) {
      return res2.status(400).json({ message: "Invalid request data", errors: error.errors });
    }
    res2.status(500).json({ message: "Failed to create Slack configuration" });
  }
});
router21.patch("/config/:id", async (req2, res2) => {
  try {
    const userId = req2.user.id;
    const configId = parseInt(req2.params.id);
    const existingConfig = await storage.getSlackConfigById(configId);
    if (!existingConfig) {
      return res2.status(404).json({ message: "Slack configuration not found" });
    }
    if (existingConfig.userId !== userId) {
      return res2.status(403).json({ message: "Not authorized to update this configuration" });
    }
    const updatedConfig = await storage.updateSlackConfig(configId, {
      ...req2.body,
      updatedAt: /* @__PURE__ */ new Date()
    });
    if (req2.body.botToken) {
      const connectionSuccess = slackService.initialize(
        req2.body.botToken,
        req2.body.defaultChannelId || existingConfig.defaultChannelId
      );
      if (!connectionSuccess) {
        await storage.updateSlackConfig(configId, {
          connectionStatus: "error" /* Error */,
          lastConnectionError: "Failed to connect to Slack API",
          updatedAt: /* @__PURE__ */ new Date()
        });
        return res2.status(400).json({ message: "Failed to connect to Slack API with provided credentials" });
      }
      await storage.updateSlackConfig(configId, {
        connectionStatus: "connected" /* Connected */,
        lastConnectionError: null,
        lastConnectedAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      });
    }
    res2.json(updatedConfig);
  } catch (error) {
    console.error("Error updating Slack config:", error);
    if (error instanceof z12.ZodError) {
      return res2.status(400).json({ message: "Invalid request data", errors: error.errors });
    }
    res2.status(500).json({ message: "Failed to update Slack configuration" });
  }
});
router21.delete("/config/:id", async (req2, res2) => {
  try {
    const userId = req2.user.id;
    const configId = parseInt(req2.params.id);
    const existingConfig = await storage.getSlackConfigById(configId);
    if (!existingConfig) {
      return res2.status(404).json({ message: "Slack configuration not found" });
    }
    if (existingConfig.userId !== userId) {
      return res2.status(403).json({ message: "Not authorized to delete this configuration" });
    }
    const deleted = await storage.deleteSlackConfig(configId);
    if (!deleted) {
      return res2.status(500).json({ message: "Failed to delete Slack configuration" });
    }
    res2.json({ success: true });
  } catch (error) {
    console.error("Error deleting Slack config:", error);
    res2.status(500).json({ message: "Failed to delete Slack configuration" });
  }
});
router21.get("/channels", async (req2, res2) => {
  try {
    const userId = req2.user.id;
    const configId = req2.query.configId ? parseInt(req2.query.configId) : void 0;
    const channels = await storage.getSlackChannels(userId, configId);
    res2.json(channels);
  } catch (error) {
    console.error("Error getting Slack channels:", error);
    res2.status(500).json({ message: "Failed to get Slack channels" });
  }
});
router21.post("/channels/sync", async (req2, res2) => {
  try {
    const userId = req2.user.id;
    const { configId } = req2.body;
    if (!configId) {
      return res2.status(400).json({ message: "configId is required" });
    }
    const config = await storage.getSlackConfigById(parseInt(configId));
    if (!config) {
      return res2.status(404).json({ message: "Slack configuration not found" });
    }
    if (config.userId !== userId) {
      return res2.status(403).json({ message: "Not authorized to sync channels for this configuration" });
    }
    const initialized = slackService.initialize(config.botToken, config.defaultChannelId);
    if (!initialized) {
      return res2.status(500).json({ message: "Failed to initialize Slack client" });
    }
    const channelsResponse = await slackService.listChannels();
    if (!channelsResponse.ok || !channelsResponse.channels) {
      return res2.status(500).json({ message: "Failed to fetch channels from Slack" });
    }
    const channelsData = channelsResponse.channels.map((channel) => ({
      channelId: channel.id,
      name: channel.name,
      isPrivate: channel.is_private || false
    }));
    const savedChannels = await storage.createOrUpdateSlackChannels(
      userId,
      parseInt(configId),
      channelsData
    );
    res2.json(savedChannels);
  } catch (error) {
    console.error("Error syncing Slack channels:", error);
    res2.status(500).json({ message: "Failed to sync Slack channels" });
  }
});
router21.get("/messages/:channelId", async (req2, res2) => {
  try {
    const userId = req2.user.id;
    const slackChannelId = parseInt(req2.params.channelId);
    const limit = req2.query.limit ? parseInt(req2.query.limit) : 100;
    const before = req2.query.before ? new Date(req2.query.before) : void 0;
    const after = req2.query.after ? new Date(req2.query.after) : void 0;
    const channel = await storage.getSlackChannel(slackChannelId);
    if (!channel) {
      return res2.status(404).json({ message: "Slack channel not found" });
    }
    if (channel.userId !== userId) {
      return res2.status(403).json({ message: "Not authorized to access messages for this channel" });
    }
    const messages = await storage.getSlackMessages(slackChannelId, { limit, before, after });
    res2.json(messages);
  } catch (error) {
    console.error("Error getting Slack messages:", error);
    res2.status(500).json({ message: "Failed to get Slack messages" });
  }
});
router21.post("/messages/sync", async (req2, res2) => {
  try {
    const userId = req2.user.id;
    const { channelId, configId } = req2.body;
    if (!channelId || !configId) {
      return res2.status(400).json({ message: "channelId and configId are required" });
    }
    const config = await storage.getSlackConfigById(parseInt(configId));
    if (!config) {
      return res2.status(404).json({ message: "Slack configuration not found" });
    }
    if (config.userId !== userId) {
      return res2.status(403).json({ message: "Not authorized to sync messages for this configuration" });
    }
    const channel = await storage.getSlackChannelBySlackId(userId, parseInt(configId), channelId);
    if (!channel) {
      return res2.status(404).json({ message: "Slack channel not found" });
    }
    const initialized = slackService.initialize(config.botToken, config.defaultChannelId);
    if (!initialized) {
      return res2.status(500).json({ message: "Failed to initialize Slack client" });
    }
    const messagesResponse = await slackService.getChannelHistory(channelId, 100);
    if (!messagesResponse.ok || !messagesResponse.messages) {
      return res2.status(500).json({ message: "Failed to fetch messages from Slack" });
    }
    const messagesToStore = messagesResponse.messages.map((message) => ({
      channelId: channel.id,
      messageId: message.ts,
      userId: message.user || "unknown",
      text: message.text || "",
      postedAt: new Date(parseFloat(message.ts) * 1e3),
      rawData: message,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    }));
    const count2 = await storage.batchCreateSlackMessages(messagesToStore);
    await storage.updateSlackChannel(channel.id, { lastSyncedAt: /* @__PURE__ */ new Date() });
    res2.json({ success: true, count: count2 });
  } catch (error) {
    console.error("Error syncing Slack messages:", error);
    res2.status(500).json({ message: "Failed to sync Slack messages" });
  }
});
router21.post("/messages/send", async (req2, res2) => {
  try {
    const userId = req2.user.id;
    const { channelId, text: text2, configId } = req2.body;
    if (!channelId || !text2) {
      return res2.status(400).json({ message: "channelId and text are required" });
    }
    const config = configId ? await storage.getSlackConfigById(parseInt(configId)) : await storage.getSlackConfig(userId);
    if (!config) {
      return res2.status(404).json({ message: "No active Slack configuration found" });
    }
    if (config.userId !== userId) {
      return res2.status(403).json({ message: "Not authorized to send messages using this configuration" });
    }
    const initialized = slackService.initialize(config.botToken, config.defaultChannelId);
    if (!initialized) {
      return res2.status(500).json({ message: "Failed to initialize Slack client" });
    }
    const messageTs = await slackService.sendMessage(text2, channelId);
    if (!messageTs) {
      return res2.status(500).json({ message: "Failed to send message to Slack" });
    }
    let channel = await storage.getSlackChannelBySlackId(userId, config.id, channelId);
    if (!channel) {
      try {
        const channelInfo = await slackService.getChannelInfo(channelId);
        if (channelInfo.ok && channelInfo.channel) {
          channel = await storage.createSlackChannel({
            userId,
            configId: config.id,
            channelId,
            name: channelInfo.channel.name || "unknown",
            isPrivate: channelInfo.channel.is_private || false,
            lastSyncedAt: /* @__PURE__ */ new Date(),
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          });
        }
      } catch (error) {
        console.error("Error creating channel record:", error);
      }
    }
    let savedMessage;
    if (channel) {
      savedMessage = await storage.createSlackMessage({
        channelId: channel.id,
        messageId: messageTs,
        userId: "bot",
        // This message was sent by our bot
        text: text2,
        postedAt: /* @__PURE__ */ new Date(),
        rawData: { text: text2, ts: messageTs },
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      });
    }
    res2.json({ success: true, messageTs, message: savedMessage });
  } catch (error) {
    console.error("Error sending Slack message:", error);
    res2.status(500).json({ message: "Failed to send Slack message" });
  }
});
router21.post("/webhooks", async (req2, res2) => {
  try {
    const userId = req2.user.id;
    const webhookData = insertSlackWebhookSchema.parse({
      ...req2.body,
      userId,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    });
    const config = await storage.getSlackConfigById(webhookData.configId);
    if (!config) {
      return res2.status(404).json({ message: "Slack configuration not found" });
    }
    if (config.userId !== userId) {
      return res2.status(403).json({ message: "Not authorized to create webhooks for this configuration" });
    }
    const webhook = await storage.createSlackWebhook(webhookData);
    res2.status(201).json(webhook);
  } catch (error) {
    console.error("Error creating Slack webhook:", error);
    if (error instanceof z12.ZodError) {
      return res2.status(400).json({ message: "Invalid request data", errors: error.errors });
    }
    res2.status(500).json({ message: "Failed to create Slack webhook" });
  }
});
router21.get("/webhooks", async (req2, res2) => {
  try {
    const userId = req2.user.id;
    const configId = req2.query.configId ? parseInt(req2.query.configId) : void 0;
    const webhooks = await storage.getSlackWebhooks(userId, configId);
    res2.json(webhooks);
  } catch (error) {
    console.error("Error getting Slack webhooks:", error);
    res2.status(500).json({ message: "Failed to get Slack webhooks" });
  }
});
router21.patch("/webhooks/:id", async (req2, res2) => {
  try {
    const userId = req2.user.id;
    const webhookId = parseInt(req2.params.id);
    const existingWebhook = await storage.getSlackWebhook(webhookId);
    if (!existingWebhook) {
      return res2.status(404).json({ message: "Slack webhook not found" });
    }
    if (existingWebhook.userId !== userId) {
      return res2.status(403).json({ message: "Not authorized to update this webhook" });
    }
    const updatedWebhook = await storage.updateSlackWebhook(webhookId, {
      ...req2.body,
      updatedAt: /* @__PURE__ */ new Date()
    });
    res2.json(updatedWebhook);
  } catch (error) {
    console.error("Error updating Slack webhook:", error);
    res2.status(500).json({ message: "Failed to update Slack webhook" });
  }
});
router21.delete("/webhooks/:id", async (req2, res2) => {
  try {
    const userId = req2.user.id;
    const webhookId = parseInt(req2.params.id);
    const existingWebhook = await storage.getSlackWebhook(webhookId);
    if (!existingWebhook) {
      return res2.status(404).json({ message: "Slack webhook not found" });
    }
    if (existingWebhook.userId !== userId) {
      return res2.status(403).json({ message: "Not authorized to delete this webhook" });
    }
    const deleted = await storage.deleteSlackWebhook(webhookId);
    if (!deleted) {
      return res2.status(500).json({ message: "Failed to delete Slack webhook" });
    }
    res2.json({ success: true });
  } catch (error) {
    console.error("Error deleting Slack webhook:", error);
    res2.status(500).json({ message: "Failed to delete Slack webhook" });
  }
});
router21.post("/webhook/:webhookId", async (req2, res2) => {
  try {
    const webhookId = req2.params.webhookId;
    const webhook = await storage.getSlackWebhook(parseInt(webhookId));
    if (!webhook) {
      return res2.status(404).json({ message: "Webhook not found" });
    }
    if (req2.body.type === "url_verification") {
      return res2.json({ challenge: req2.body.challenge });
    }
    const event = req2.body.event;
    if (!event) {
      return res2.status(400).json({ message: "No event in payload" });
    }
    res2.json({ success: true });
  } catch (error) {
    console.error("Error processing webhook event:", error);
    res2.status(500).json({ message: "Failed to process webhook event" });
  }
});
var slack_routes_default = router21;

// server/routes/oauth-routes.ts
import { Router as Router18 } from "express";
import { z as z13 } from "zod";

// server/services/integrations/nango.ts
import axios10 from "axios";
var NangoService = class {
  secretKey;
  publicKey;
  hostUrl;
  baseUrl = "https://api.nango.dev/v1";
  initialized = false;
  registeredProviders = /* @__PURE__ */ new Map();
  constructor() {
    this.secretKey = "";
    this.publicKey = "";
    this.hostUrl = "";
  }
  /**
   * Initialize the Nango service with API keys
   */
  initialize(config) {
    try {
      this.secretKey = config.secretKey;
      this.publicKey = config.publicKey;
      this.hostUrl = config.hostUrl || "https://app.synthralos.com";
      this.initialized = true;
      console.log("[nango] Service initialized");
      return true;
    } catch (error) {
      console.error("[nango] Failed to initialize service:", error);
      return false;
    }
  }
  /**
   * Check if service is initialized
   */
  isInitialized() {
    return this.initialized;
  }
  /**
   * Get authorization URL for OAuth flow
   */
  async getAuthorizationUrl(provider, connectionId, redirectUri) {
    if (!this.initialized) {
      console.error("[nango] Service not initialized");
      return null;
    }
    const providerConfig = this.registeredProviders.get(provider);
    if (!providerConfig) {
      console.error(`[nango] Provider ${provider} not registered`);
      return null;
    }
    try {
      const response = await axios10.post(
        `${this.baseUrl}/auth/connect/${providerConfig.providerConfigKey}`,
        {
          connection_id: connectionId,
          redirect_uri: redirectUri || `${this.hostUrl}/api/oauth/callback`
        },
        {
          headers: {
            "Authorization": `Bearer ${this.secretKey}`,
            "Content-Type": "application/json"
          }
        }
      );
      if (response.data && response.data.auth_url) {
        return response.data.auth_url;
      }
      console.error("[nango] Failed to get authorization URL:", response.data);
      return null;
    } catch (error) {
      console.error("[nango] Error getting authorization URL:", error);
      return null;
    }
  }
  /**
   * Create a new connection for a user
   */
  async createConnection(params2) {
    if (!this.initialized) {
      console.error("[nango] Service not initialized");
      return false;
    }
    try {
      await axios10.post(
        `${this.baseUrl}/connection`,
        {
          provider: params2.provider,
          connection_id: params2.connectionId,
          external_id: params2.externalId,
          credentials: {
            type: "oauth",
            ...params2.config
          }
        },
        {
          headers: {
            "Authorization": `Bearer ${this.secretKey}`,
            "Content-Type": "application/json"
          }
        }
      );
      return true;
    } catch (error) {
      console.error("[nango] Error creating connection:", error);
      return false;
    }
  }
  /**
   * Get connection details
   */
  async getConnection(provider, connectionId) {
    if (!this.initialized) {
      console.error("[nango] Service not initialized");
      return null;
    }
    try {
      const response = await axios10.get(
        `${this.baseUrl}/connection/${provider}/${connectionId}`,
        {
          headers: {
            "Authorization": `Bearer ${this.secretKey}`
          }
        }
      );
      return response.data;
    } catch (error) {
      console.error("[nango] Error getting connection:", error);
      return null;
    }
  }
  /**
   * Delete a connection
   */
  async deleteConnection(provider, connectionId) {
    if (!this.initialized) {
      console.error("[nango] Service not initialized");
      return false;
    }
    try {
      await axios10.delete(
        `${this.baseUrl}/connection/${provider}/${connectionId}`,
        {
          headers: {
            "Authorization": `Bearer ${this.secretKey}`
          }
        }
      );
      return true;
    } catch (error) {
      console.error("[nango] Error deleting connection:", error);
      return false;
    }
  }
  /**
   * Make an API request through Nango (handles token refresh automatically)
   */
  async makeRequest(provider, connectionId, endpoint, method = "GET", data) {
    if (!this.initialized) {
      console.error("[nango] Service not initialized");
      return null;
    }
    try {
      const response = await axios10({
        method: "POST",
        url: `${this.baseUrl}/proxy/${provider}/${connectionId}`,
        headers: {
          "Authorization": `Bearer ${this.secretKey}`,
          "Content-Type": "application/json"
        },
        data: {
          endpoint,
          method,
          data
        }
      });
      return response.data;
    } catch (error) {
      console.error("[nango] Error making API request:", error);
      return null;
    }
  }
  /**
   * Register provider configurations
   */
  registerProvider(config) {
    this.registeredProviders.set(config.provider, config);
    console.log(`[nango] Registered provider: ${config.provider}`);
  }
  /**
   * Register common OAuth providers
   */
  registerCommonProviders() {
    this.registerProvider({ provider: "github", providerConfigKey: "github", authMode: "oauth2" });
    this.registerProvider({ provider: "twitter", providerConfigKey: "twitter", authMode: "oauth2" });
    this.registerProvider({ provider: "linkedin", providerConfigKey: "linkedin", authMode: "oauth2" });
    this.registerProvider({ provider: "google", providerConfigKey: "google", authMode: "oauth2" });
    this.registerProvider({ provider: "salesforce", providerConfigKey: "salesforce", authMode: "oauth2" });
    this.registerProvider({ provider: "hubspot", providerConfigKey: "hubspot", authMode: "oauth2" });
    this.registerProvider({ provider: "shopify", providerConfigKey: "shopify", authMode: "oauth2" });
    this.registerProvider({ provider: "notion", providerConfigKey: "notion", authMode: "oauth2" });
    this.registerProvider({ provider: "jira", providerConfigKey: "jira", authMode: "oauth2" });
    this.registerProvider({ provider: "asana", providerConfigKey: "asana", authMode: "oauth2" });
    this.registerProvider({ provider: "slack", providerConfigKey: "slack", authMode: "oauth2" });
    console.log("[nango] Registered common OAuth providers");
  }
};
var nangoService = new NangoService();

// server/routes/oauth-routes.ts
var router22 = Router18();
function initializeNangoService() {
  if (!process.env.NANGO_SECRET_KEY || !process.env.NANGO_PUBLIC_KEY) {
    console.error("Nango API keys not found in environment variables. OAuth features will not work properly.");
    return false;
  }
  return nangoService.initialize({
    secretKey: process.env.NANGO_SECRET_KEY,
    publicKey: process.env.NANGO_PUBLIC_KEY,
    hostUrl: process.env.HOST_URL || `https://${process.env.REPLIT_DOMAINS?.split(",")[0]}`
  });
}
(async () => {
  initializeNangoService();
  nangoService.registerCommonProviders();
})();
router22.post("/config/nango", isAuthenticated3, async (req2, res2) => {
  try {
    if (!req2.user) {
      return res2.status(401).json({ error: "User not authenticated" });
    }
    const configSchema2 = z13.object({
      secretKey: z13.string().min(1),
      publicKey: z13.string().min(1),
      hostUrl: z13.string().optional()
    });
    const { secretKey, publicKey, hostUrl } = configSchema2.parse(req2.body);
    process.env.NANGO_SECRET_KEY = secretKey;
    process.env.NANGO_PUBLIC_KEY = publicKey;
    if (hostUrl) {
      process.env.HOST_URL = hostUrl;
    }
    const result2 = nangoService.initialize({
      secretKey,
      publicKey,
      hostUrl: hostUrl || process.env.HOST_URL || `https://${process.env.REPLIT_DOMAINS?.split(",")[0]}`
    });
    if (!result2) {
      return res2.status(500).json({ success: false, message: "Failed to initialize Nango service with provided keys" });
    }
    nangoService.registerCommonProviders();
    res2.json({ success: true, message: "Nango API keys updated successfully" });
  } catch (error) {
    console.error("Error updating Nango API keys:", error);
    if (error instanceof z13.ZodError) {
      return res2.status(400).json({ success: false, message: "Invalid input data", errors: error.errors });
    }
    res2.status(500).json({ success: false, message: "Failed to update Nango API keys" });
  }
});
router22.get("/auth-url/:provider", isAuthenticated3, async (req2, res2) => {
  try {
    const { provider } = req2.params;
    if (!req2.user) {
      return res2.status(401).json({ error: "User not authenticated" });
    }
    const userId = req2.user.id;
    if (!nangoService.isInitialized()) {
      if (!initializeNangoService()) {
        return res2.status(503).json({
          error: "Nango service is not available. Please check if API keys are configured."
        });
      }
    }
    const connectionId = `${provider}-${userId}`;
    const redirectUrl = req2.query.redirectUrl;
    const authUrl = await nangoService.getAuthorizationUrl(provider, connectionId, redirectUrl);
    if (!authUrl) {
      return res2.status(400).json({ error: `Failed to get authorization URL for ${provider}` });
    }
    res2.json({ authUrl });
  } catch (error) {
    console.error("Error getting OAuth auth URL:", error);
    res2.status(500).json({ error: "Failed to generate authorization URL" });
  }
});
router22.get("/callback", async (req2, res2) => {
  try {
    const { success, error, connectionId, provider } = req2.query;
    if (error) {
      console.error(`OAuth error from Nango: ${error}`);
      return res2.redirect(`/integrations?error=${encodeURIComponent(error)}`);
    }
    if (success === "true" && connectionId && provider) {
      const connParts = connectionId.split("-");
      if (connParts.length < 2) {
        return res2.redirect("/integrations?error=Invalid connection ID format");
      }
      const userId = parseInt(connParts[1]);
      const connection = await nangoService.getConnection(provider, connectionId);
      if (!connection) {
        return res2.redirect("/integrations?error=Failed to retrieve connection details");
      }
      const existingConnections = await storage.getOAuthConnectionsByProvider(userId, provider);
      let oauthConnection;
      if (existingConnections.length > 0) {
        oauthConnection = await storage.updateOAuthConnection(existingConnections[0].id, {
          connectionStatus: "connected" /* Connected */,
          nangoConnectionId: connection.id,
          metadata: connection.metadata || {},
          tokenData: connection.credentials || {},
          lastConnectedAt: /* @__PURE__ */ new Date(),
          expiresAt: connection.expires_at ? new Date(connection.expires_at) : null
        });
      } else {
        const connectionData = insertOAuthConnectionSchema.parse({
          userId,
          provider,
          connectionId,
          nangoConnectionId: connection.id,
          connectionStatus: "connected" /* Connected */,
          metadata: connection.metadata || {},
          tokenData: connection.credentials || {},
          lastConnectedAt: /* @__PURE__ */ new Date(),
          expiresAt: connection.expires_at ? new Date(connection.expires_at) : null
        });
        oauthConnection = await storage.createOAuthConnection(connectionData);
      }
      return res2.redirect("/integrations?success=true");
    }
    res2.redirect("/integrations?error=Invalid callback parameters");
  } catch (error) {
    console.error("Error handling OAuth callback:", error);
    res2.redirect(`/integrations?error=${encodeURIComponent("Failed to complete OAuth connection")}`);
  }
});
router22.get("/connections", isAuthenticated3, async (req2, res2) => {
  try {
    if (!req2.user) {
      return res2.status(401).json({ error: "User not authenticated" });
    }
    const userId = req2.user.id;
    const connections = await storage.getOAuthConnectionsByUser(userId);
    const sanitizedConnections = connections.map((conn) => ({
      id: conn.id,
      provider: conn.provider,
      connectionId: conn.connectionId,
      connectionStatus: conn.connectionStatus,
      metadata: conn.metadata,
      lastConnectedAt: conn.lastConnectedAt,
      expiresAt: conn.expiresAt,
      createdAt: conn.createdAt
    }));
    res2.json({ connections: sanitizedConnections });
  } catch (error) {
    console.error("Error listing OAuth connections:", error);
    res2.status(500).json({ error: "Failed to list OAuth connections" });
  }
});
router22.get("/connections/:id", isAuthenticated3, async (req2, res2) => {
  try {
    if (!req2.user) {
      return res2.status(401).json({ error: "User not authenticated" });
    }
    const userId = req2.user.id;
    const connectionId = parseInt(req2.params.id);
    const connection = await storage.getOAuthConnection(connectionId);
    if (!connection) {
      return res2.status(404).json({ error: "Connection not found" });
    }
    if (connection.userId !== userId) {
      return res2.status(403).json({ error: "Unauthorized" });
    }
    const sanitizedConnection = {
      id: connection.id,
      provider: connection.provider,
      connectionId: connection.connectionId,
      connectionStatus: connection.connectionStatus,
      metadata: connection.metadata,
      lastConnectedAt: connection.lastConnectedAt,
      expiresAt: connection.expiresAt,
      createdAt: connection.createdAt
    };
    res2.json(sanitizedConnection);
  } catch (error) {
    console.error("Error getting OAuth connection:", error);
    res2.status(500).json({ error: "Failed to get OAuth connection" });
  }
});
router22.delete("/connections/:id", isAuthenticated3, async (req2, res2) => {
  try {
    if (!req2.user) {
      return res2.status(401).json({ error: "User not authenticated" });
    }
    const userId = req2.user.id;
    const connectionId = parseInt(req2.params.id);
    const connection = await storage.getOAuthConnection(connectionId);
    if (!connection) {
      return res2.status(404).json({ error: "Connection not found" });
    }
    if (connection.userId !== userId) {
      return res2.status(403).json({ error: "Unauthorized" });
    }
    await nangoService.deleteConnection(connection.provider, connection.connectionId);
    const deleted = await storage.deleteOAuthConnection(connectionId);
    if (!deleted) {
      return res2.status(500).json({ error: "Failed to delete connection" });
    }
    res2.json({ success: true });
  } catch (error) {
    console.error("Error deleting OAuth connection:", error);
    res2.status(500).json({ error: "Failed to delete OAuth connection" });
  }
});
router22.post("/request/:provider/:id", isAuthenticated3, async (req2, res2) => {
  try {
    if (!req2.user) {
      return res2.status(401).json({ error: "User not authenticated" });
    }
    const userId = req2.user.id;
    const { provider } = req2.params;
    const connectionId = parseInt(req2.params.id);
    const requestSchema = z13.object({
      endpoint: z13.string(),
      method: z13.enum(["GET", "POST", "PUT", "PATCH", "DELETE"]).default("GET"),
      data: z13.any().optional()
    });
    const { endpoint, method, data } = requestSchema.parse(req2.body);
    const connection = await storage.getOAuthConnection(connectionId);
    if (!connection) {
      return res2.status(404).json({ error: "Connection not found" });
    }
    if (connection.userId !== userId) {
      return res2.status(403).json({ error: "Unauthorized" });
    }
    const response = await nangoService.makeRequest(
      provider,
      connection.connectionId,
      endpoint,
      method,
      data
    );
    if (!response) {
      return res2.status(500).json({ error: "API request failed" });
    }
    res2.json(response);
  } catch (error) {
    console.error("Error making API request through OAuth:", error);
    res2.status(500).json({ error: "Failed to make API request" });
  }
});
var oauth_routes_default = router22;

// server/routes.ts
var socialMonitorService = new SocialMonitoringService();
var sessionConfig = {
  secret: process.env.SESSION_SECRET || "synthralos-secret",
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === "production",
    maxAge: 1e3 * 60 * 60 * 24
    // 1 day
  }
};
var stripeApiKey2 = process.env.STRIPE_SECRET_KEY;
var stripe2 = stripeApiKey2 ? new Stripe2(stripeApiKey2, { apiVersion: "2023-10-16" }) : void 0;
var storage2 = multer2.memoryStorage();
var upload2 = multer2({
  storage: storage2,
  limits: {
    fileSize: 10 * 1024 * 1024
    // 10MB max file size
  }
});
var osintService = new OsintService();
async function registerRoutes(app2) {
  app2.use(session(sessionConfig));
  app2.use(passport.initialize());
  app2.use(passport.session());
  passport.use(
    new LocalStrategy(
      { usernameField: "email" },
      async (email, password, done) => {
        try {
          const user = await storage.getUserByEmail(email);
          if (!user) {
            return done(null, false, { message: "Incorrect email or password" });
          }
          if (!user.password) {
            return done(null, false, { message: "Please login with your social account" });
          }
          const isMatch = await bcrypt.compare(password, user.password);
          if (!isMatch) {
            return done(null, false, { message: "Incorrect email or password" });
          }
          return done(null, user);
        } catch (error) {
          return done(error);
        }
      }
    )
  );
  passport.serializeUser((user, done) => {
    done(null, user.id);
  });
  passport.deserializeUser(async (id, done) => {
    try {
      const user = await storage.getUser(id);
      done(null, user);
    } catch (error) {
      done(error);
    }
  });
  const isAuthenticated12 = (req2, res2, next) => {
    if (req2.isAuthenticated()) {
      return next();
    }
    res2.status(401).json({ message: "Unauthorized" });
  };
  app2.post("/api/auth/register", async (req2, res2) => {
    try {
      const validatedData = insertUserSchema.parse(req2.body);
      const existingUser = await storage.getUserByEmail(validatedData.email);
      if (existingUser) {
        return res2.status(400).json({ message: "User already exists" });
      }
      const hashedPassword = await bcrypt.hash(validatedData.password, 10);
      const user = await storage.createUser({
        ...validatedData,
        password: hashedPassword
      });
      const { password, ...userWithoutPassword } = user;
      res2.status(201).json(userWithoutPassword);
    } catch (error) {
      if (error instanceof z14.ZodError) {
        return res2.status(400).json({ message: error.errors });
      }
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.post("/api/auth/login", (req2, res2, next) => {
    passport.authenticate("local", (err, user, info) => {
      if (err) {
        return next(err);
      }
      if (!user) {
        return res2.status(401).json({ message: info.message || "Authentication failed" });
      }
      req2.logIn(user, (err2) => {
        if (err2) {
          return next(err2);
        }
        const { password, ...userWithoutPassword } = user;
        return res2.json(userWithoutPassword);
      });
    })(req2, res2, next);
  });
  app2.post("/api/auth/logout", (req2, res2) => {
    req2.logout(() => {
      res2.json({ message: "Logged out successfully" });
    });
  });
  app2.get("/api/auth/session", (req2, res2) => {
    if (req2.isAuthenticated()) {
      const { password, ...userWithoutPassword } = req2.user;
      return res2.json(userWithoutPassword);
    }
    res2.status(401).json({ message: "Not authenticated" });
  });
  app2.get("/api/users/me", isAuthenticated12, (req2, res2) => {
    const { password, ...userWithoutPassword } = req2.user;
    res2.json(userWithoutPassword);
  });
  app2.put("/api/users/me", isAuthenticated12, async (req2, res2) => {
    try {
      const user = req2.user;
      const updatedUser = await storage.updateUser(user.id, req2.body);
      if (!updatedUser) {
        return res2.status(404).json({ message: "User not found" });
      }
      const { password, ...userWithoutPassword } = updatedUser;
      res2.json(userWithoutPassword);
    } catch (error) {
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.get("/api/workflows", isAuthenticated12, async (req2, res2) => {
    try {
      const user = req2.user;
      const workflows2 = await storage.getWorkflowsByUser(user.id);
      res2.json(workflows2);
    } catch (error) {
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.get("/api/workflows/:id", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const workflow = await storage.getWorkflow(parseInt(id));
      if (!workflow) {
        return res2.status(404).json({ message: "Workflow not found" });
      }
      const user = req2.user;
      if (workflow.ownerId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      res2.json(workflow);
    } catch (error) {
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.post("/api/workflows", isAuthenticated12, async (req2, res2) => {
    try {
      const user = req2.user;
      const validatedData = insertWorkflowSchema.parse({
        ...req2.body,
        ownerId: user.id
      });
      const workflow = await storage.createWorkflow(validatedData);
      res2.status(201).json(workflow);
    } catch (error) {
      if (error instanceof z14.ZodError) {
        return res2.status(400).json({ message: error.errors });
      }
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.put("/api/workflows/:id", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const user = req2.user;
      const existingWorkflow = await storage.getWorkflow(parseInt(id));
      if (!existingWorkflow) {
        return res2.status(404).json({ message: "Workflow not found" });
      }
      if (existingWorkflow.ownerId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      const updatedWorkflow = await storage.updateWorkflow(parseInt(id), req2.body);
      res2.json(updatedWorkflow);
    } catch (error) {
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.delete("/api/workflows/:id", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const user = req2.user;
      const existingWorkflow = await storage.getWorkflow(parseInt(id));
      if (!existingWorkflow) {
        return res2.status(404).json({ message: "Workflow not found" });
      }
      if (existingWorkflow.ownerId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      await storage.deleteWorkflow(parseInt(id));
      res2.status(204).send();
    } catch (error) {
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.get("/api/workflows/:id/executions", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const user = req2.user;
      const workflow = await storage.getWorkflow(parseInt(id));
      if (!workflow) {
        return res2.status(404).json({ message: "Workflow not found" });
      }
      if (workflow.ownerId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      const executions = await storage.getWorkflowExecutionsByWorkflow(parseInt(id));
      res2.json(executions);
    } catch (error) {
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.get("/api/executions/:id", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const executionId = parseInt(id);
      const user = req2.user;
      const execution = await storage.getWorkflowExecution(executionId);
      if (!execution) {
        return res2.status(404).json({ message: "Execution not found" });
      }
      const workflow = await storage.getWorkflow(execution.workflowId);
      if (!workflow) {
        return res2.status(404).json({ message: "Associated workflow not found" });
      }
      if (workflow.ownerId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      const activeExecution = executionRegistry.get(executionId);
      if (activeExecution) {
        const serializedExecution = {
          ...execution,
          activeState: {
            status: execution.status
          }
        };
        return res2.json(serializedExecution);
      }
      res2.json(execution);
    } catch (error) {
      console.error("Error fetching execution:", error);
      res2.status(500).json({ message: `Error fetching execution: ${error instanceof Error ? error.message : "Unknown error"}` });
    }
  });
  app2.get("/api/executions/:id/status", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const executionId = parseInt(id);
      const user = req2.user;
      const execution = await storage.getWorkflowExecution(executionId);
      if (!execution) {
        return res2.status(404).json({ message: "Execution not found" });
      }
      const workflow = await storage.getWorkflow(execution.workflowId);
      if (!workflow || workflow.ownerId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      const activeExecution = executionRegistry.get(executionId);
      if (!activeExecution) {
        return res2.json({
          executionId,
          status: execution.status,
          isActive: false,
          currentNodes: [],
          completedNodes: execution.result ? JSON.parse(execution.result).completedNodes || [] : [],
          progress: 100,
          // Assuming completed
          startedAt: execution.startedAt,
          completedAt: execution.completedAt
        });
      }
      const workflowData = workflow.data;
      const totalNodes = workflowData.nodes ? workflowData.nodes.length : 0;
      const completedCount = activeExecution.completedNodes.length;
      const progress = totalNodes > 0 ? Math.round(completedCount / totalNodes * 100) : 0;
      res2.json({
        executionId,
        status: activeExecution.status,
        isActive: true,
        currentNodes: activeExecution.currentNodes,
        completedNodes: activeExecution.completedNodes,
        progress,
        startedAt: activeExecution.startTime,
        completedAt: activeExecution.endTime,
        recentLogs: activeExecution.logs.slice(-10)
        // Last 10 log entries
      });
    } catch (error) {
      console.error("Error fetching execution status:", error);
      res2.status(500).json({ message: `Error fetching execution status: ${error instanceof Error ? error.message : "Unknown error"}` });
    }
  });
  app2.get("/api/executions/:id/details", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const executionId = parseInt(id);
      const user = req2.user;
      const execution = await storage.getWorkflowExecution(executionId);
      if (!execution) {
        return res2.status(404).json({ message: "Execution not found" });
      }
      const workflow = await storage.getWorkflow(execution.workflowId);
      if (!workflow) {
        return res2.status(404).json({ message: "Associated workflow not found" });
      }
      if (workflow.ownerId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      const activeExecution = executionRegistry.get(executionId);
      if (activeExecution) {
        const serializedExecution = {
          execution: {
            id: execution.id,
            workflowId: execution.workflowId,
            status: activeExecution.status,
            startedAt: execution.startedAt,
            completedAt: null
          },
          workflow: {
            id: workflow.id,
            name: workflow.name,
            description: workflow.description
          },
          result: null,
          logs: activeExecution.logs,
          activeState: {
            currentNodes: activeExecution.currentNodes,
            completedNodes: activeExecution.completedNodes,
            nodeResults: Object.fromEntries(activeExecution.nodeResults)
          }
        };
        return res2.json(serializedExecution);
      }
      try {
        const executionDetails = {
          execution,
          workflow,
          result: execution.result ? JSON.parse(execution.result) : null,
          logs: execution.logs || []
        };
        res2.json(executionDetails);
      } catch (detailsError) {
        console.error("Error retrieving execution details:", detailsError);
        return res2.status(500).json({
          message: `Error retrieving execution details: ${detailsError instanceof Error ? detailsError.message : "Unknown error"}`
        });
      }
    } catch (error) {
      console.error("Error fetching execution details:", error);
      res2.status(500).json({
        message: `Error fetching execution details: ${error instanceof Error ? error.message : "Unknown error"}`
      });
    }
  });
  app2.post("/api/executions/:id/cancel", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const executionId = parseInt(id);
      const user = req2.user;
      const execution = await storage.getWorkflowExecution(executionId);
      if (!execution) {
        return res2.status(404).json({ message: "Execution not found" });
      }
      const workflow = await storage.getWorkflow(execution.workflowId);
      if (!workflow) {
        return res2.status(404).json({ message: "Associated workflow not found" });
      }
      if (workflow.ownerId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      try {
        await cancelWorkflowExecution(executionId);
        return res2.json({ success: true, message: "Execution cancelled successfully" });
      } catch (error) {
        return res2.status(400).json({ message: "Execution cannot be cancelled (not active or already completed)" });
      }
    } catch (error) {
      console.error("Error cancelling execution:", error);
      res2.status(500).json({ message: `Error cancelling execution: ${error instanceof Error ? error.message : "Unknown error"}` });
    }
  });
  app2.post("/api/executions/:id/pause", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const executionId = parseInt(id);
      const user = req2.user;
      const execution = await storage.getWorkflowExecution(executionId);
      if (!execution) {
        return res2.status(404).json({ message: "Execution not found" });
      }
      const workflow = await storage.getWorkflow(execution.workflowId);
      if (!workflow) {
        return res2.status(404).json({ message: "Associated workflow not found" });
      }
      if (workflow.ownerId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      try {
        await pauseWorkflowExecution(executionId);
        return res2.json({ success: true, message: "Execution paused successfully" });
      } catch (error) {
        return res2.status(400).json({ message: "Execution cannot be paused (not active or already completed)" });
      }
    } catch (error) {
      console.error("Error pausing execution:", error);
      res2.status(500).json({ message: `Error pausing execution: ${error instanceof Error ? error.message : "Unknown error"}` });
    }
  });
  app2.post("/api/executions/:id/resume", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const executionId = parseInt(id);
      const user = req2.user;
      const execution = await storage.getWorkflowExecution(executionId);
      if (!execution) {
        return res2.status(404).json({ message: "Execution not found" });
      }
      const workflow = await storage.getWorkflow(execution.workflowId);
      if (!workflow) {
        return res2.status(404).json({ message: "Associated workflow not found" });
      }
      if (workflow.ownerId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      try {
        await resumeWorkflowExecution(executionId);
        return res2.json({ success: true, message: "Execution resumed successfully" });
      } catch (error) {
        return res2.status(400).json({ message: "Execution cannot be resumed (not paused or already completed)" });
      }
    } catch (error) {
      console.error("Error resuming execution:", error);
      res2.status(500).json({ message: `Error resuming execution: ${error instanceof Error ? error.message : "Unknown error"}` });
    }
  });
  app2.post("/api/workflows/:id/execute", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const user = req2.user;
      const workflow = await storage.getWorkflow(parseInt(id));
      if (!workflow) {
        return res2.status(404).json({ message: "Workflow not found" });
      }
      if (workflow.ownerId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      const workflowId = parseInt(id);
      const userId = user.id;
      const sendWebSocketEvent = (event) => {
        const executionId2 = event.data && typeof event.data === "object" && "executionId" in event.data ? event.data.executionId : void 0;
        if (executionId2) {
          WebSocketHandler_default.sendExecutionEvent(executionId2, event);
        } else {
          console.warn("[websocket] Received event without executionId:", event);
        }
      };
      const executionId = await startWorkflowExecution(workflowId, userId, sendWebSocketEvent);
      const execution = await storage.getWorkflowExecution(executionId);
      res2.status(202).json(execution);
    } catch (error) {
      console.error("Error executing workflow:", error);
      res2.status(500).json({ message: `Error executing workflow: ${error instanceof Error ? error.message : "Unknown error"}` });
    }
  });
  app2.get("/api/integrations", isAuthenticated12, async (req2, res2) => {
    try {
      const user = req2.user;
      const integrations = await storage.getApiIntegrationsByUser(user.id);
      res2.json(integrations);
    } catch (error) {
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.post("/api/integrations", isAuthenticated12, async (req2, res2) => {
    try {
      const user = req2.user;
      const validatedData = insertApiIntegrationSchema.parse({
        ...req2.body,
        userId: user.id
      });
      const integration = await storage.createApiIntegration(validatedData);
      res2.status(201).json(integration);
    } catch (error) {
      if (error instanceof z14.ZodError) {
        return res2.status(400).json({ message: error.errors });
      }
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.get("/api/integrations/:id", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const user = req2.user;
      const integration = await storage.getApiIntegration(parseInt(id));
      if (!integration) {
        return res2.status(404).json({ message: "Integration not found" });
      }
      if (integration.userId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      res2.json(integration);
    } catch (error) {
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.delete("/api/integrations/:id", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const user = req2.user;
      const integration = await storage.getApiIntegration(parseInt(id));
      if (!integration) {
        return res2.status(404).json({ message: "Integration not found" });
      }
      if (integration.userId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      await storage.deleteApiIntegration(parseInt(id));
      res2.status(204).send();
    } catch (error) {
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.post("/api/integrations/:id/execute", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const { endpoint, method, params: params2, data, headers, contentType } = req2.body;
      const user = req2.user;
      const integration = await storage.getApiIntegration(parseInt(id));
      if (!integration) {
        return res2.status(404).json({ message: "Integration not found" });
      }
      if (integration.userId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      const config = JSON.parse(integration.config);
      const result2 = await IntegrationService.executeRequest(config, {
        endpoint,
        method: method || "GET" /* GET */,
        params: params2,
        data,
        headers,
        contentType: contentType || "application/json" /* JSON */
      });
      if (config.isAiApi) {
        await storage.createModelCostLog({
          userId: user.id,
          model: config.name,
          requestType: "integration",
          tokensUsed: Math.ceil((JSON.stringify(data || "").length + JSON.stringify(result2.data || "").length) / 4),
          cost: 1e-4 * Math.ceil((JSON.stringify(data || "").length + JSON.stringify(result2.data || "").length) / 1e3),
          metadata: JSON.stringify({
            endpoint,
            dataSize: JSON.stringify(data || "").length,
            responseSize: JSON.stringify(result2.data || "").length
          })
        });
      }
      res2.json(result2);
    } catch (error) {
      console.error("API execution error:", error);
      res2.status(500).json({ message: `Failed to execute API request: ${error}` });
    }
  });
  app2.get("/api/integrations/:id/oauth2/authorize", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const { redirectUri } = req2.query;
      const user = req2.user;
      if (!redirectUri) {
        return res2.status(400).json({ message: "Missing redirect URI" });
      }
      const integration = await storage.getApiIntegration(parseInt(id));
      if (!integration) {
        return res2.status(404).json({ message: "Integration not found" });
      }
      if (integration.userId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      const config = JSON.parse(integration.config);
      if (config.auth.type !== "oauth2" /* OAUTH2 */) {
        return res2.status(400).json({ message: "Integration is not configured for OAuth2" });
      }
      const state = uuidv49();
      const authUrl = OAuth2Service.getAuthorizationUrl(
        config,
        redirectUri,
        state,
        config.auth.oauth?.scope
      );
      if (!authUrl) {
        return res2.status(400).json({ message: "Failed to generate authorization URL" });
      }
      res2.json({ authUrl, state });
    } catch (error) {
      console.error("OAuth2 authorization error:", error);
      res2.status(500).json({ message: `OAuth2 authorization failed: ${error}` });
    }
  });
  app2.post("/api/integrations/:id/oauth2/token", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const { code, redirectUri, state } = req2.body;
      const user = req2.user;
      if (!code || !redirectUri || !state) {
        return res2.status(400).json({ message: "Missing required parameters" });
      }
      const integration = await storage.getApiIntegration(parseInt(id));
      if (!integration) {
        return res2.status(404).json({ message: "Integration not found" });
      }
      if (integration.userId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      const config = JSON.parse(integration.config);
      if (config.auth.type !== "oauth2" /* OAUTH2 */) {
        return res2.status(400).json({ message: "Integration is not configured for OAuth2" });
      }
      const tokens = await OAuth2Service.exchangeCodeForTokens(
        config,
        code,
        redirectUri
      );
      if (!tokens) {
        return res2.status(400).json({ message: "Failed to exchange code for tokens" });
      }
      const updatedConfig = {
        ...config,
        auth: {
          ...config.auth,
          oauth: {
            ...config.auth.oauth,
            accessToken: tokens.accessToken,
            refreshToken: tokens.refreshToken,
            expiresAt: tokens.expiresAt
          }
        }
      };
      await storage.updateApiIntegration(integration.id, {
        config: JSON.stringify(updatedConfig)
      });
      res2.json({ success: true });
    } catch (error) {
      console.error("OAuth2 token exchange error:", error);
      res2.status(500).json({ message: `OAuth2 token exchange failed: ${error}` });
    }
  });
  app2.get("/api/integration-types", (req2, res2) => {
    const types = Object.values(IntegrationType);
    res2.json(types);
  });
  app2.get("/api/integration-auth-types", (req2, res2) => {
    const types = Object.values(AuthType);
    res2.json(types);
  });
  app2.get("/api/templates", async (req2, res2) => {
    try {
      const templates = await storage.getAllWorkflowTemplates();
      res2.json(templates);
    } catch (error) {
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.get("/api/templates/:id", async (req2, res2) => {
    try {
      const { id } = req2.params;
      const template = await storage.getWorkflowTemplate(parseInt(id));
      if (!template) {
        return res2.status(404).json({ message: "Template not found" });
      }
      res2.json(template);
    } catch (error) {
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.post("/api/ocr/process", isAuthenticated12, upload2.single("image"), async (req2, res2) => {
    try {
      if (!req2.file) {
        return res2.status(400).json({ message: "No image file provided" });
      }
      const fileSize = req2.file.size;
      const isPdf = req2.file.mimetype === "application/pdf";
      const options2 = {
        language: req2.body.language || "eng",
        documentType: req2.body.documentType || "generic" /* GENERIC */,
        engine: req2.body.engine || void 0,
        enhanceImage: req2.body.enhanceImage === "true",
        confidence: req2.body.confidence ? parseFloat(req2.body.confidence) : 0.7,
        hasHandwriting: req2.body.hasHandwriting === "true",
        region: req2.body.region || void 0,
        isPdf,
        fileSize,
        structuredJsonRequired: req2.body.structuredJsonRequired === "true",
        latency: req2.body.latency ? parseInt(req2.body.latency) : void 0
      };
      const result2 = await OCRService.processImage(req2.file.buffer, options2);
      const userId = req2.user.id;
      await storage.createModelCostLog({
        userId,
        model: result2.engineUsed,
        requestType: "ocr",
        tokensUsed: Math.ceil(result2.text.length / 4),
        // Rough estimation
        cost: 1e-4 * Math.ceil(result2.text.length / 100),
        // Approximate cost
        metadata: JSON.stringify({
          documentType: options2.documentType,
          language: options2.language,
          characters: result2.text.length,
          engine: result2.engineUsed,
          processingTime: result2.executionTime
        })
      });
      res2.json(result2);
    } catch (error) {
      console.error("OCR processing error:", error);
      res2.status(500).json({ message: `OCR processing failed: ${error}` });
    }
  });
  app2.get("/api/ocr/document-types", (req2, res2) => {
    const documentTypes = Object.values(DocumentType);
    res2.json(documentTypes);
  });
  app2.get("/api/ocr/engines", (req2, res2) => {
    const engines = Object.values(OCREngine);
    res2.json(engines);
  });
  app2.get("/api/ocr/engines/info", (req2, res2) => {
    const engineInfo = [
      {
        name: OCREngine.TESSERACT,
        description: "General-purpose OCR engine for most text extraction needs",
        benefits: ["Open source", "Good general accuracy", "Supports many languages"],
        limitations: ["Struggles with complex layouts", "Not optimized for handwriting"],
        bestFor: ["generic" /* GENERIC */, "form" /* FORM */]
      },
      {
        name: OCREngine.PADDLE_OCR,
        description: "Specialized OCR engine with better layout analysis",
        benefits: ["Better with complex documents", "Good for structured forms", "Regional fallback"],
        limitations: ["Requires more resources", "Can be slower than Tesseract"],
        bestFor: ["invoice" /* INVOICE */, "receipt" /* RECEIPT */, "id_card" /* ID_CARD */, "business_card" /* BUSINESS_CARD */]
      },
      {
        name: OCREngine.EASY_OCR,
        description: "OCR engine optimized for handwriting recognition",
        benefits: ["Specialized for handwritten text", "Good with varied penmanship", "Multiple language support"],
        limitations: ["Not as good for printed text", "Can be slower"],
        bestFor: ["Handwritten notes", "Forms with handwriting"]
      },
      {
        name: OCREngine.GOOGLE_VISION,
        description: "Cloud-based OCR with advanced capabilities",
        benefits: ["High accuracy", "Handles complex documents", "Good for PDFs"],
        limitations: ["Cloud-based", "Rate limits may apply"],
        bestFor: ["Heavy PDFs", "Large images", "Complex multi-page documents"]
      },
      {
        name: OCREngine.OMNIPARSER,
        description: "Specialized parser for structured documents",
        benefits: ["JSON output", "Table extraction", "Data normalization"],
        limitations: ["Specialized use cases", "Not for general OCR"],
        bestFor: ["table" /* TABLE */, "Structured data extraction"]
      }
    ];
    res2.json(engineInfo);
  });
  app2.post("/api/scraper/analyze-url", isAuthenticated12, async (req2, res2) => {
    try {
      const { url } = req2.body;
      if (!url) {
        return res2.status(400).json({ message: "URL is required" });
      }
      try {
        new URL(url);
      } catch (error) {
        return res2.status(400).json({ message: "Invalid URL format" });
      }
      try {
        const response = await axios11.get(url, {
          headers: { "User-Agent": "Mozilla/5.0 (compatible; SynthralOS/1.0; +https://synthral.com/bot)" },
          timeout: 5e3
        });
        const html = response.data;
        const $ = cheerio3.load(html);
        let detectedSiteType = "generic" /* GENERIC */;
        const hasReactJS = html.includes("reactjs") || html.includes("react.js") || html.includes("react-dom");
        const hasVueJS = html.includes("vue.js") || html.includes("vuejs") || html.includes("vue@");
        const hasAngular = html.includes("angular.js") || html.includes("angularjs") || html.includes("ng-app");
        if (hasReactJS || hasVueJS || hasAngular) {
          detectedSiteType = "single_page_app" /* SPA */;
        }
        const hasAddToCart = html.toLowerCase().includes("add to cart") || html.toLowerCase().includes("buy now") || $('[itemtype="http://schema.org/Product"]').length > 0;
        if (hasAddToCart) {
          detectedSiteType = "e_commerce" /* E_COMMERCE */;
        }
        const isSocialMedia = url.includes("facebook.com") || url.includes("twitter.com") || url.includes("instagram.com") || url.includes("linkedin.com") || url.includes("tiktok.com");
        if (isSocialMedia) {
          detectedSiteType = "social_media" /* SOCIAL_MEDIA */;
        }
        const hasArticleSchema = $('[itemtype="http://schema.org/NewsArticle"]').length > 0 || $('[itemtype="http://schema.org/Article"]').length > 0;
        const hasNewsKeywords = $('meta[name="keywords"]').attr("content")?.toLowerCase().includes("news") || false;
        if (hasArticleSchema || hasNewsKeywords) {
          detectedSiteType = "news" /* NEWS */;
        }
        const recommendedEngine = ScraperService.selectEngineForSiteType(detectedSiteType, {
          javascriptRendering: hasReactJS || hasVueJS || hasAngular
        });
        const title = $("title").text().trim();
        const description = $('meta[name="description"]').attr("content") || "";
        const links = $("a").length;
        const images = $("img").length;
        const scripts = $("script").length;
        res2.json({
          url,
          title,
          description,
          detectedSiteType,
          recommendedEngine,
          metadata: {
            links,
            images,
            scripts,
            hasJavascriptFramework: hasReactJS || hasVueJS || hasAngular,
            contentType: response.headers["content-type"] || ""
          }
        });
      } catch (error) {
        res2.status(500).json({ message: `URL analysis failed: ${error}` });
      }
    } catch (error) {
      res2.status(500).json({ message: `URL analysis failed: ${error}` });
    }
  });
  app2.post("/api/scraper/scrape", isAuthenticated12, async (req2, res2) => {
    try {
      const { url, selectors, siteType, engine, javascriptRendering, pagination } = req2.body;
      if (!url) {
        return res2.status(400).json({ message: "URL is required" });
      }
      try {
        new URL(url);
      } catch (error) {
        return res2.status(400).json({ message: "Invalid URL format" });
      }
      const options2 = {
        selectors: selectors || {},
        siteType: siteType || "generic" /* GENERIC */,
        engine: engine || void 0,
        javascriptRendering: javascriptRendering === true,
        pagination: pagination || { enabled: false }
      };
      const result2 = await ScraperService.scrape(url, options2);
      const userId = req2.user.id;
      await storage.createModelCostLog({
        userId,
        model: result2.metadata.engineUsed,
        tokensInput: 0,
        tokensOutput: Math.ceil(result2.text?.length || 1e3),
        // Rough estimation
        cost: 1e-4 * Math.ceil((result2.text?.length || 1e3) / 1e3),
        // Approximate cost
        metadata: JSON.stringify({
          url,
          siteType: options2.siteType,
          dataSize: result2.text?.length || 0
        })
      });
      const response = {
        url: result2.url,
        title: result2.title,
        text: result2.text || "",
        data: result2.data,
        metadata: result2.metadata,
        html_preview: result2.text ? result2.text.substring(0, 1e3) + "... (truncated)" : "No text content extracted"
      };
      res2.json(response);
    } catch (error) {
      console.error("Web scraping error:", error);
      res2.status(500).json({ message: `Web scraping failed: ${error}` });
    }
  });
  app2.get("/api/scraper/site-types", (req2, res2) => {
    const siteTypes = Object.values(SiteType);
    res2.json(siteTypes);
  });
  app2.get("/api/scraper/engines", (req2, res2) => {
    const engines = Object.values(ScraperEngine);
    res2.json(engines);
  });
  app2.get("/api/scraper/engines/info", (req2, res2) => {
    const engineInfo = [
      {
        name: "cheerio" /* CHEERIO */,
        description: "Lightweight and fast static HTML parser",
        benefits: ["Fast parsing", "Low resource usage", "Good for static sites"],
        limitations: ["Cannot process JavaScript", "No DOM interaction"],
        bestFor: ["generic" /* GENERIC */, "news" /* NEWS */]
      },
      {
        name: "jsdom" /* JSDOM */,
        description: "Server-side DOM implementation for more accurate parsing",
        benefits: ["Full DOM API", "Better CSS selector support", "More accurate than Cheerio"],
        limitations: ["Limited JavaScript support", "Higher resource usage than Cheerio"],
        bestFor: ["news" /* NEWS */, "forum" /* FORUM */]
      },
      {
        name: "puppeteer" /* PUPPETEER */,
        description: "Headless browser for fully rendered content with JavaScript",
        benefits: ["Full JavaScript support", "Renders pages like a real browser", "Can interact with the page"],
        limitations: ["Higher resource usage", "Slower than static parsers"],
        bestFor: ["single_page_app" /* SPA */, "social_media" /* SOCIAL_MEDIA */]
      },
      {
        name: "crawl4ai" /* CRAWL4AI */,
        description: "Advanced intelligent extraction combining multiple techniques",
        benefits: ["Structured data extraction", "Combines multiple engines", "Optimized for e-commerce"],
        limitations: ["Higher resource usage", "More complex configuration"],
        bestFor: ["e_commerce" /* E_COMMERCE */, "job_board" /* JOB_BOARD */]
      }
    ];
    res2.json(engineInfo);
  });
  const agentInstances = /* @__PURE__ */ new Map();
  app2.post("/api/agents/create", isAuthenticated12, async (req2, res2) => {
    try {
      const { agentType, capabilities, systemPrompt, maxTokens, temperature, toolNames } = req2.body;
      if (!agentType || !Object.values(AgentType).includes(agentType)) {
        return res2.status(400).json({ message: "Invalid agent type" });
      }
      const tools2 = toolNames && toolNames.length > 0 ? AgentToolkit.getTools(toolNames) : [];
      const agentId = uuidv49();
      const userId = req2.user.id;
      let agent2;
      switch (agentType) {
        case "assistant" /* ASSISTANT */:
          agent2 = AgentFactory.createAssistant({ systemPrompt, maxTokens, temperature, tools: tools2 });
          break;
        case "researcher" /* RESEARCHER */:
          agent2 = AgentFactory.createResearcher({ systemPrompt, maxTokens, temperature, tools: tools2 });
          break;
        case "analyzer" /* ANALYZER */:
          agent2 = AgentFactory.createAnalyzer({ systemPrompt, maxTokens, temperature, tools: tools2 });
          break;
        case "executor" /* EXECUTOR */:
          agent2 = AgentFactory.createExecutor({ systemPrompt, maxTokens, temperature, tools: tools2 });
          break;
        case "coordinator" /* COORDINATOR */:
          agent2 = AgentFactory.createCoordinator({ systemPrompt, maxTokens, temperature, tools: tools2 });
          break;
        case "specialist" /* SPECIALIST */:
          if (!capabilities?.specialization) {
            return res2.status(400).json({ message: "Specialization is required for specialist agents" });
          }
          agent2 = AgentFactory.createSpecialist(capabilities.specialization, { systemPrompt, maxTokens, temperature, tools: tools2 });
          break;
        case "autonomous" /* AUTONOMOUS */:
          agent2 = AgentFactory.createAutonomous({ systemPrompt, maxTokens, temperature, tools: tools2 });
          break;
        default:
          return res2.status(400).json({ message: "Unsupported agent type" });
      }
      agentInstances.set(agentId, agent2);
      res2.status(201).json({
        agentId,
        agentType,
        capabilities,
        toolNames: toolNames || [],
        created: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      console.error("Agent creation error:", error);
      res2.status(500).json({ message: `Failed to create agent: ${error}` });
    }
  });
  app2.post("/api/agents/:agentId/query", isAuthenticated12, async (req2, res2) => {
    try {
      const { agentId } = req2.params;
      const { query: query2, context } = req2.body;
      if (!query2) {
        return res2.status(400).json({ message: "Query is required" });
      }
      const agent2 = agentInstances.get(agentId);
      if (!agent2) {
        return res2.status(404).json({ message: "Agent not found" });
      }
      const result2 = await agent2.process(query2, context);
      const userId = req2.user.id;
      await storage.createModelCostLog({
        userId,
        model: "claude-3-7-sonnet-20250219",
        tokensInput: Math.ceil(query2.length / 4),
        tokensOutput: Math.ceil(result2.response.length / 4),
        cost: 1e-4 * (Math.ceil(query2.length / 1e3) + Math.ceil(result2.response.length / 1e3)),
        metadata: JSON.stringify({
          agentId,
          queryLength: query2.length,
          responseLength: result2.response.length
        })
      });
      res2.json(result2);
    } catch (error) {
      console.error("Agent query error:", error);
      res2.status(500).json({ message: `Agent query failed: ${error}` });
    }
  });
  app2.delete("/api/agents/:agentId", isAuthenticated12, (req2, res2) => {
    try {
      const { agentId } = req2.params;
      if (!agentInstances.has(agentId)) {
        return res2.status(404).json({ message: "Agent not found" });
      }
      agentInstances.delete(agentId);
      res2.status(204).send();
    } catch (error) {
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.get("/api/agents/types", (req2, res2) => {
    const agentTypes = Object.values(AgentType);
    res2.json(agentTypes);
  });
  app2.get("/api/agents/tools", (req2, res2) => {
    const tools2 = AgentToolkit.getAllTools().map((tool) => ({
      name: tool.name,
      description: tool.description,
      parameters: tool.parameters
    }));
    res2.json(tools2);
  });
  if (stripe2) {
    app2.post("/api/create-payment-intent", isAuthenticated12, async (req2, res2) => {
      try {
        const { amount } = req2.body;
        const paymentIntent = await stripe2.paymentIntents.create({
          amount: Math.round(amount * 100),
          // Convert to cents
          currency: "usd"
        });
        res2.json({ clientSecret: paymentIntent.client_secret });
      } catch (error) {
        res2.status(500).json({ message: "Error creating payment intent: " + error.message });
      }
    });
    app2.post("/api/get-or-create-subscription", isAuthenticated12, async (req2, res2) => {
      try {
        const user = req2.user;
        if (user.stripeSubscriptionId) {
          const subscription2 = await stripe2.subscriptions.retrieve(user.stripeSubscriptionId);
          return res2.send({
            subscriptionId: subscription2.id,
            clientSecret: subscription2.latest_invoice?.payment_intent?.client_secret
          });
        }
        if (!user.email) {
          throw new Error("No user email on file");
        }
        let customerId = user.stripeCustomerId;
        if (!customerId) {
          const customer = await stripe2.customers.create({
            email: user.email,
            name: user.name || user.username
          });
          customerId = customer.id;
          await storage.updateStripeCustomerId(user.id, customerId);
        }
        const subscription = await stripe2.subscriptions.create({
          customer: customerId,
          items: [{
            // We're using the default price but in production you should use a specific price ID
            price: process.env.STRIPE_PRICE_ID || "price_1234"
            // This should be set by the user
          }],
          payment_behavior: "default_incomplete",
          expand: ["latest_invoice.payment_intent"]
        });
        await storage.updateUserStripeInfo(user.id, {
          stripeCustomerId: customerId,
          stripeSubscriptionId: subscription.id
        });
        res2.send({
          subscriptionId: subscription.id,
          clientSecret: subscription.latest_invoice?.payment_intent?.client_secret
        });
      } catch (error) {
        return res2.status(400).send({ error: { message: error.message } });
      }
    });
  }
  app2.get("/api/recommendations", isAuthenticated12, async (req2, res2) => {
    try {
      const user = req2.user;
      const recommendations = await storage.getWorkflowRecommendationsByUser(user.id);
      res2.json(recommendations);
    } catch (error) {
      console.error("Error fetching recommendations:", error);
      res2.status(500).json({ message: "Error fetching recommendations", error: error.message });
    }
  });
  app2.get("/api/recommendations/organization/:orgId", isAuthenticated12, async (req2, res2) => {
    try {
      const { orgId } = req2.params;
      const organizationId = parseInt(orgId);
      const recommendations = await storage.getWorkflowRecommendationsByOrg(organizationId);
      res2.json(recommendations);
    } catch (error) {
      console.error("Error fetching org recommendations:", error);
      res2.status(500).json({ message: "Error fetching organization recommendations", error: error.message });
    }
  });
  app2.post("/api/recommendations/generate", isAuthenticated12, async (req2, res2) => {
    try {
      const user = req2.user;
      const { orgId } = req2.body;
      if (!process.env.ANTHROPIC_API_KEY) {
        return res2.status(400).json({
          message: "Anthropic API key is missing. Please set the ANTHROPIC_API_KEY environment variable."
        });
      }
      const recommendations = await recommendationEngine.generateAndSaveRecommendationsForUser(
        user.id,
        orgId ? parseInt(orgId) : void 0
      );
      res2.json(recommendations);
    } catch (error) {
      console.error("Error generating recommendations:", error);
      res2.status(500).json({ message: "Error generating recommendations", error: error.message });
    }
  });
  app2.patch("/api/recommendations/:id/mark-read", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const user = req2.user;
      const recommendation = await storage.getWorkflowRecommendation(parseInt(id));
      if (!recommendation) {
        return res2.status(404).json({ message: "Recommendation not found" });
      }
      if (recommendation.userId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      const updatedRecommendation = await storage.markRecommendationAsRead(parseInt(id));
      res2.json(updatedRecommendation);
    } catch (error) {
      console.error("Error marking recommendation as read:", error);
      res2.status(500).json({ message: "Error updating recommendation", error: error.message });
    }
  });
  app2.patch("/api/recommendations/:id/mark-clicked", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const user = req2.user;
      const recommendation = await storage.getWorkflowRecommendation(parseInt(id));
      if (!recommendation) {
        return res2.status(404).json({ message: "Recommendation not found" });
      }
      if (recommendation.userId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      const updatedRecommendation = await storage.markRecommendationAsClicked(parseInt(id));
      res2.json(updatedRecommendation);
    } catch (error) {
      console.error("Error marking recommendation as clicked:", error);
      res2.status(500).json({ message: "Error updating recommendation", error: error.message });
    }
  });
  app2.post("/api/user-activity", isAuthenticated12, async (req2, res2) => {
    try {
      const user = req2.user;
      const { workflowId, templateId, activityType, metadata } = req2.body;
      const activity = await storage.logUserWorkflowActivity({
        userId: user.id,
        workflowId: workflowId ? parseInt(workflowId) : void 0,
        templateId: templateId ? parseInt(templateId) : void 0,
        activityType,
        metadata: metadata || {}
      });
      res2.status(201).json(activity);
    } catch (error) {
      console.error("Error logging user activity:", error);
      res2.status(500).json({ message: "Error logging activity", error: error.message });
    }
  });
  app2.post("/api/osint/search", isAuthenticated12, async (req2, res2) => {
    try {
      const { term, sources, timeframe, limit } = req2.body;
      if (!term) {
        return res2.status(400).json({ message: "Search term is required" });
      }
      const results = await osintService.search({
        term,
        sources,
        timeframe,
        limit
      });
      res2.json(results);
    } catch (error) {
      console.error("OSINT search error:", error);
      res2.status(500).json({ message: "Error performing OSINT search", error: error.message });
    }
  });
  app2.post("/api/osint/person", isAuthenticated12, async (req2, res2) => {
    try {
      const { name } = req2.body;
      if (!name) {
        return res2.status(400).json({ message: "Person name is required" });
      }
      const results = await osintService.personLookup(name);
      res2.json(results);
    } catch (error) {
      console.error("Person lookup error:", error);
      res2.status(500).json({ message: "Error performing person lookup", error: error.message });
    }
  });
  app2.post("/api/osint/company", isAuthenticated12, async (req2, res2) => {
    try {
      const { name } = req2.body;
      if (!name) {
        return res2.status(400).json({ message: "Company name is required" });
      }
      const results = await osintService.companyLookup(name);
      res2.json(results);
    } catch (error) {
      console.error("Company lookup error:", error);
      res2.status(500).json({ message: "Error performing company lookup", error: error.message });
    }
  });
  app2.post("/api/osint/sentiment", isAuthenticated12, async (req2, res2) => {
    try {
      const { term, platforms } = req2.body;
      if (!term) {
        return res2.status(400).json({ message: "Term is required" });
      }
      const results = await osintService.analyzeSentiment(term, platforms);
      res2.json(results);
    } catch (error) {
      console.error("Sentiment analysis error:", error);
      res2.status(500).json({ message: "Error performing sentiment analysis", error: error.message });
    }
  });
  app2.get("/api/social-monitors", isAuthenticated12, async (req2, res2) => {
    try {
      const user = req2.user;
      try {
        const dbMonitors = await storage.getSocialMonitorsByUser(user.id);
        const monitors = dbMonitors.map((dbMonitor) => {
          const query2 = dbMonitor.query || {};
          const keywords = query2.keywords || [];
          const platforms = query2.platforms || [];
          return {
            id: dbMonitor.id.toString(),
            name: dbMonitor.name,
            description: query2.description || "",
            userId: dbMonitor.userId,
            platforms,
            keywords,
            frequency: parseInt(dbMonitor.frequency) || 60,
            alertThreshold: query2.alertThreshold || 0.7,
            isActive: dbMonitor.status === "active",
            createdAt: dbMonitor.createdAt,
            lastRunAt: dbMonitor.lastRunAt
          };
        });
        res2.json(monitors);
      } catch (dbError) {
        console.error("Database fetch failed, falling back to service:", dbError);
        const monitors = socialMonitorService.getMonitorsByUser(user.id);
        res2.json(monitors);
      }
    } catch (error) {
      console.error("Error fetching social monitors:", error);
      res2.status(500).json({ message: "Error fetching social monitors", error: error.message });
    }
  });
  app2.post("/api/social-monitors", isAuthenticated12, async (req2, res2) => {
    try {
      const user = req2.user;
      const { name, description, platforms, keywords, accounts, frequency, alertThreshold, isActive } = req2.body;
      if (!name || !platforms || !keywords) {
        return res2.status(400).json({ message: "Missing required fields" });
      }
      try {
        const insertData = {
          userId: user.id,
          name,
          type: "keyword",
          connectorId: 1,
          // Default connector
          query: {
            keywords,
            platforms,
            accounts: accounts || [],
            description: description || "",
            alertThreshold: alertThreshold || 0.7
          },
          frequency: (frequency || 60).toString(),
          status: isActive !== false ? "active" : "inactive"
        };
        const dbMonitor = await storage.createSocialMonitor(insertData);
        const monitor = {
          id: dbMonitor.id.toString(),
          name: dbMonitor.name,
          description: description || "",
          userId: dbMonitor.userId,
          platforms,
          keywords,
          accounts: accounts || [],
          frequency: parseInt(dbMonitor.frequency) || 60,
          alertThreshold: alertThreshold || 0.7,
          isActive: dbMonitor.status === "active",
          createdAt: dbMonitor.createdAt,
          lastRunAt: dbMonitor.lastRunAt
        };
        res2.status(201).json(monitor);
      } catch (dbError) {
        console.error("Database storage failed, falling back to service:", dbError);
        const monitor = socialMonitorService.createMonitor({
          name,
          description,
          userId: user.id,
          platforms,
          keywords,
          accounts,
          frequency,
          alertThreshold,
          isActive: isActive !== false
        });
        res2.status(201).json(monitor);
      }
    } catch (error) {
      console.error("Error creating social monitor:", error);
      res2.status(500).json({ message: "Error creating social monitor", error: error.message });
    }
  });
  app2.get("/api/social-monitors/:id", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const user = req2.user;
      const monitor = socialMonitorService.getMonitor(id);
      if (!monitor) {
        return res2.status(404).json({ message: "Monitor not found" });
      }
      if (monitor.userId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      res2.json(monitor);
    } catch (error) {
      console.error("Error fetching social monitor:", error);
      res2.status(500).json({ message: "Error fetching social monitor", error: error.message });
    }
  });
  app2.put("/api/social-monitors/:id", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const user = req2.user;
      const monitor = socialMonitorService.getMonitor(id);
      if (!monitor) {
        return res2.status(404).json({ message: "Monitor not found" });
      }
      if (monitor.userId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      const updatedMonitor = socialMonitorService.updateMonitor(id, req2.body);
      res2.json(updatedMonitor);
    } catch (error) {
      console.error("Error updating social monitor:", error);
      res2.status(500).json({ message: "Error updating social monitor", error: error.message });
    }
  });
  app2.delete("/api/social-monitors/:id", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const user = req2.user;
      const monitor = socialMonitorService.getMonitor(id);
      if (!monitor) {
        return res2.status(404).json({ message: "Monitor not found" });
      }
      if (monitor.userId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      socialMonitorService.deleteMonitor(id);
      res2.status(204).send();
    } catch (error) {
      console.error("Error deleting social monitor:", error);
      res2.status(500).json({ message: "Error deleting social monitor", error: error.message });
    }
  });
  app2.post("/api/social-monitors/:id/run", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const user = req2.user;
      const monitor = socialMonitorService.getMonitor(id);
      if (!monitor) {
        return res2.status(404).json({ message: "Monitor not found" });
      }
      if (monitor.userId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      const result2 = await socialMonitorService.runMonitor(id);
      res2.json(result2);
    } catch (error) {
      console.error("Error running social monitor:", error);
      res2.status(500).json({ message: "Error running social monitor", error: error.message });
    }
  });
  app2.get("/api/social-monitors/:id/alerts", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const user = req2.user;
      const monitor = socialMonitorService.getMonitor(id);
      if (!monitor) {
        return res2.status(404).json({ message: "Monitor not found" });
      }
      if (monitor.userId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      const limit = req2.query.limit ? parseInt(req2.query.limit) : 10;
      const alerts = await socialMonitorService.getAlerts(id, limit);
      res2.json(alerts);
    } catch (error) {
      console.error("Error fetching social alerts:", error);
      res2.status(500).json({ message: "Error fetching social alerts", error: error.message });
    }
  });
  app2.post("/api/social-monitors/demo", isAuthenticated12, (req2, res2) => {
    try {
      const user = req2.user;
      const demoMonitors = socialMonitorService.createDemoMonitors(user.id);
      res2.json(demoMonitors);
    } catch (error) {
      console.error("Error creating demo monitors:", error);
      res2.status(500).json({ message: "Error creating demo monitors", error: error.message });
    }
  });
  app2.get("/api/oidc-providers", isAuthenticated12, async (req2, res2) => {
    try {
      const providers = await storage.getAllOidcProviders();
      res2.json(providers);
    } catch (error) {
      console.error("Error fetching OIDC providers:", error);
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.post("/api/oidc-providers", isAuthenticated12, async (req2, res2) => {
    try {
      const provider = await storage.createOidcProvider(req2.body);
      res2.status(201).json(provider);
    } catch (error) {
      console.error("Error creating OIDC provider:", error);
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.get("/api/oidc-providers/:id", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const provider = await storage.getOidcProvider(parseInt(id));
      if (!provider) {
        return res2.status(404).json({ message: "OIDC provider not found" });
      }
      res2.json(provider);
    } catch (error) {
      console.error("Error fetching OIDC provider:", error);
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.put("/api/oidc-providers/:id", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const provider = await storage.updateOidcProvider(parseInt(id), req2.body);
      if (!provider) {
        return res2.status(404).json({ message: "OIDC provider not found" });
      }
      res2.json(provider);
    } catch (error) {
      console.error("Error updating OIDC provider:", error);
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.delete("/api/oidc-providers/:id", isAuthenticated12, async (req2, res2) => {
    try {
      const { id } = req2.params;
      const result2 = await storage.deleteOidcProvider(parseInt(id));
      if (!result2) {
        return res2.status(404).json({ message: "OIDC provider not found" });
      }
      res2.status(204).send();
    } catch (error) {
      console.error("Error deleting OIDC provider:", error);
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.get("/api/organizations", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      if (!userId) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      const orgs = await storage.getOrganizationsByUser(userId);
      return res2.json(orgs);
    } catch (error) {
      console.error("Error fetching organizations:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.post("/api/organizations", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      if (!userId) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      const validatedData = insertOrganizationSchema.parse(req2.body);
      const existingOrg = await storage.getOrganizationBySlug(validatedData.slug);
      if (existingOrg) {
        return res2.status(400).json({ message: "Organization slug already exists" });
      }
      const newOrg = await storage.createOrganization({
        ...validatedData,
        createdById: userId,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      });
      await storage.createOrganizationMember({
        organizationId: newOrg.id,
        userId,
        role: "admin",
        joinedAt: /* @__PURE__ */ new Date()
      });
      await storage.createAuditLog({
        action: "organization.create",
        userId,
        organizationId: newOrg.id,
        entityType: "organization",
        entityId: newOrg.id.toString(),
        details: { name: newOrg.name, slug: newOrg.slug },
        timestamp: /* @__PURE__ */ new Date()
      });
      return res2.status(201).json(newOrg);
    } catch (error) {
      console.error("Error creating organization:", error);
      if (error instanceof z14.ZodError) {
        return res2.status(400).json({ message: error.errors });
      }
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.get("/api/organizations/:id", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { id } = req2.params;
      if (!userId || !id) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      const member = await storage.getOrganizationMemberByUserAndOrg(userId, parseInt(id));
      if (!member) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      const org = await storage.getOrganization(parseInt(id));
      if (!org) {
        return res2.status(404).json({ message: "Organization not found" });
      }
      return res2.json(org);
    } catch (error) {
      console.error("Error fetching organization:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.patch("/api/organizations/:id", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { id } = req2.params;
      if (!userId || !id) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      const member = await storage.getOrganizationMemberByUserAndOrg(userId, parseInt(id));
      if (!member || member.role !== "admin") {
        return res2.status(403).json({ message: "Forbidden - Admin access required" });
      }
      const { name, description, logoUrl, settings } = req2.body;
      const updatedOrg = await storage.updateOrganization(parseInt(id), {
        ...name && { name },
        ...description !== void 0 && { description },
        ...logoUrl !== void 0 && { logoUrl },
        ...settings && { settings },
        updatedAt: /* @__PURE__ */ new Date()
      });
      if (!updatedOrg) {
        return res2.status(404).json({ message: "Organization not found" });
      }
      await storage.createAuditLog({
        action: "organization.update",
        userId,
        organizationId: parseInt(id),
        entityType: "organization",
        entityId: id,
        details: { changes: req2.body },
        timestamp: /* @__PURE__ */ new Date()
      });
      return res2.json(updatedOrg);
    } catch (error) {
      console.error("Error updating organization:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.delete("/api/organizations/:id", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { id } = req2.params;
      if (!userId || !id) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      const member = await storage.getOrganizationMemberByUserAndOrg(userId, parseInt(id));
      if (!member || member.role !== "admin") {
        return res2.status(403).json({ message: "Forbidden - Admin access required" });
      }
      const org = await storage.getOrganization(parseInt(id));
      if (!org) {
        return res2.status(404).json({ message: "Organization not found" });
      }
      await storage.deleteOrganization(parseInt(id));
      await storage.createAuditLog({
        action: "organization.delete",
        userId,
        organizationId: null,
        entityType: "organization",
        entityId: id,
        details: { name: org.name, slug: org.slug },
        timestamp: /* @__PURE__ */ new Date()
      });
      return res2.status(204).end();
    } catch (error) {
      console.error("Error deleting organization:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.get("/api/organizations/:id/members", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { id } = req2.params;
      if (!userId || !id) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      const member = await storage.getOrganizationMemberByUserAndOrg(userId, parseInt(id));
      if (!member) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      const members = await storage.getOrganizationMembersByOrganization(parseInt(id));
      const memberDetails = await Promise.all(
        members.map(async (m) => {
          const user = await storage.getUser(m.userId);
          return {
            ...m,
            user: user ? {
              id: user.id,
              username: user.username,
              email: user.email,
              profileImageUrl: user.profileImageUrl
            } : null
          };
        })
      );
      return res2.json(memberDetails);
    } catch (error) {
      console.error("Error fetching organization members:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.post("/api/organizations/:id/members", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { id } = req2.params;
      const { memberUserId, role = "member" } = req2.body;
      if (!userId || !id) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      const member = await storage.getOrganizationMemberByUserAndOrg(userId, parseInt(id));
      if (!member || member.role !== "admin") {
        return res2.status(403).json({ message: "Forbidden - Admin access required" });
      }
      const userToAdd = await storage.getUser(memberUserId);
      if (!userToAdd) {
        return res2.status(404).json({ message: "User not found" });
      }
      const existingMember = await storage.getOrganizationMemberByUserAndOrg(memberUserId, parseInt(id));
      if (existingMember) {
        return res2.status(400).json({ message: "User is already a member of this organization" });
      }
      const newMember = await storage.createOrganizationMember({
        organizationId: parseInt(id),
        userId: memberUserId,
        role,
        joinedAt: /* @__PURE__ */ new Date()
      });
      await storage.createAuditLog({
        action: "organization.addMember",
        userId,
        organizationId: parseInt(id),
        entityType: "organizationMember",
        entityId: newMember.id.toString(),
        details: { memberId: memberUserId, role },
        timestamp: /* @__PURE__ */ new Date()
      });
      return res2.status(201).json(newMember);
    } catch (error) {
      console.error("Error adding organization member:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.patch("/api/organizations/:id/members/:memberId", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { id, memberId } = req2.params;
      const { role } = req2.body;
      if (!userId || !id || !memberId) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      const member = await storage.getOrganizationMemberByUserAndOrg(userId, parseInt(id));
      if (!member || member.role !== "admin") {
        return res2.status(403).json({ message: "Forbidden - Admin access required" });
      }
      const memberToUpdate = await storage.getOrganizationMember(parseInt(memberId));
      if (!memberToUpdate || memberToUpdate.organizationId !== parseInt(id)) {
        return res2.status(404).json({ message: "Member not found" });
      }
      const updatedMember = await storage.updateOrganizationMember(parseInt(memberId), {
        role
      });
      await storage.createAuditLog({
        action: "organization.updateMember",
        userId,
        organizationId: parseInt(id),
        entityType: "organizationMember",
        entityId: memberId,
        details: { role },
        timestamp: /* @__PURE__ */ new Date()
      });
      return res2.json(updatedMember);
    } catch (error) {
      console.error("Error updating organization member:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.delete("/api/organizations/:id/members/:memberId", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { id, memberId } = req2.params;
      if (!userId || !id || !memberId) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      const member = await storage.getOrganizationMemberByUserAndOrg(userId, parseInt(id));
      const memberToDelete = await storage.getOrganizationMember(parseInt(memberId));
      if (!member || member.role !== "admin" && memberToDelete?.userId !== userId) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      if (!memberToDelete || memberToDelete.organizationId !== parseInt(id)) {
        return res2.status(404).json({ message: "Member not found" });
      }
      if (memberToDelete.role === "admin") {
        const admins = (await storage.getOrganizationMembersByOrganization(parseInt(id))).filter((m) => m.role === "admin");
        if (admins.length <= 1) {
          return res2.status(400).json({ message: "Cannot remove the last admin of an organization" });
        }
      }
      await storage.deleteOrganizationMember(parseInt(memberId));
      await storage.createAuditLog({
        action: "organization.removeMember",
        userId,
        organizationId: parseInt(id),
        entityType: "organizationMember",
        entityId: memberId,
        details: { removedUserId: memberToDelete.userId },
        timestamp: /* @__PURE__ */ new Date()
      });
      return res2.status(204).end();
    } catch (error) {
      console.error("Error removing organization member:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.get("/api/teams", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { organizationId } = req2.query;
      if (!userId) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      let teams;
      if (organizationId) {
        const member = await storage.getOrganizationMemberByUserAndOrg(userId, parseInt(organizationId));
        if (!member) {
          return res2.status(403).json({ message: "Forbidden" });
        }
        teams = await storage.getTeamsByOrganization(parseInt(organizationId));
      } else {
        teams = await storage.getTeamsByUser(userId);
      }
      return res2.json(teams);
    } catch (error) {
      console.error("Error fetching teams:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.post("/api/teams", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { organizationId, name, description } = req2.body;
      if (!userId) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      if (!organizationId || !name) {
        return res2.status(400).json({ message: "Organization ID and team name are required" });
      }
      const orgMember = await storage.getOrganizationMemberByUserAndOrg(userId, organizationId);
      if (!orgMember) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      const team = await storage.createTeam({
        organizationId,
        name,
        description,
        createdById: userId,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      });
      await storage.createTeamMember({
        teamId: team.id,
        userId,
        role: "admin",
        joinedAt: /* @__PURE__ */ new Date()
      });
      await storage.createAuditLog({
        action: "team.create",
        userId,
        organizationId,
        entityType: "team",
        entityId: team.id.toString(),
        details: { name, organizationId },
        timestamp: /* @__PURE__ */ new Date()
      });
      return res2.status(201).json(team);
    } catch (error) {
      console.error("Error creating team:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.get("/api/teams/:id", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { id } = req2.params;
      if (!userId) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      const team = await storage.getTeam(parseInt(id));
      if (!team) {
        return res2.status(404).json({ message: "Team not found" });
      }
      const orgMember = await storage.getOrganizationMemberByUserAndOrg(userId, team.organizationId);
      if (!orgMember) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      return res2.json(team);
    } catch (error) {
      console.error("Error fetching team:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.patch("/api/teams/:id", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { id } = req2.params;
      const { name, description } = req2.body;
      if (!userId) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      const team = await storage.getTeam(parseInt(id));
      if (!team) {
        return res2.status(404).json({ message: "Team not found" });
      }
      const teamMember = await storage.getTeamMemberByUserAndTeam(userId, parseInt(id));
      if (!teamMember || teamMember.role !== "admin") {
        return res2.status(403).json({ message: "Forbidden - Admin access required" });
      }
      const updatedTeam = await storage.updateTeam(parseInt(id), {
        ...name && { name },
        ...description !== void 0 && { description },
        updatedAt: /* @__PURE__ */ new Date()
      });
      await storage.createAuditLog({
        action: "team.update",
        userId,
        organizationId: team.organizationId,
        entityType: "team",
        entityId: id,
        details: { changes: req2.body },
        timestamp: /* @__PURE__ */ new Date()
      });
      return res2.json(updatedTeam);
    } catch (error) {
      console.error("Error updating team:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.delete("/api/teams/:id", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { id } = req2.params;
      if (!userId) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      const team = await storage.getTeam(parseInt(id));
      if (!team) {
        return res2.status(404).json({ message: "Team not found" });
      }
      const orgMember = await storage.getOrganizationMemberByUserAndOrg(userId, team.organizationId);
      const teamMember = await storage.getTeamMemberByUserAndTeam(userId, parseInt(id));
      if (!(orgMember?.role === "admin" || teamMember?.role === "admin")) {
        return res2.status(403).json({ message: "Forbidden - Admin access required" });
      }
      await storage.deleteTeam(parseInt(id));
      await storage.createAuditLog({
        action: "team.delete",
        userId,
        organizationId: team.organizationId,
        entityType: "team",
        entityId: id,
        details: { name: team.name },
        timestamp: /* @__PURE__ */ new Date()
      });
      return res2.status(204).end();
    } catch (error) {
      console.error("Error deleting team:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.get("/api/teams/:id/members", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { id } = req2.params;
      if (!userId) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      const team = await storage.getTeam(parseInt(id));
      if (!team) {
        return res2.status(404).json({ message: "Team not found" });
      }
      const orgMember = await storage.getOrganizationMemberByUserAndOrg(userId, team.organizationId);
      if (!orgMember) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      const members = await storage.getTeamMembersByTeam(parseInt(id));
      const memberDetails = await Promise.all(
        members.map(async (m) => {
          const user = await storage.getUser(m.userId);
          return {
            ...m,
            user: user ? {
              id: user.id,
              username: user.username,
              email: user.email,
              profileImageUrl: user.profileImageUrl
            } : null
          };
        })
      );
      return res2.json(memberDetails);
    } catch (error) {
      console.error("Error fetching team members:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.post("/api/teams/:id/members", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { id } = req2.params;
      const { memberUserId, role = "member" } = req2.body;
      if (!userId) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      const team = await storage.getTeam(parseInt(id));
      if (!team) {
        return res2.status(404).json({ message: "Team not found" });
      }
      const teamMember = await storage.getTeamMemberByUserAndTeam(userId, parseInt(id));
      if (!teamMember || teamMember.role !== "admin") {
        return res2.status(403).json({ message: "Forbidden - Admin access required" });
      }
      const userToAdd = await storage.getUser(memberUserId);
      if (!userToAdd) {
        return res2.status(404).json({ message: "User not found" });
      }
      const orgMember = await storage.getOrganizationMemberByUserAndOrg(memberUserId, team.organizationId);
      if (!orgMember) {
        return res2.status(400).json({ message: "User must be a member of the organization first" });
      }
      const existingMember = await storage.getTeamMemberByUserAndTeam(memberUserId, parseInt(id));
      if (existingMember) {
        return res2.status(400).json({ message: "User is already a member of this team" });
      }
      const newMember = await storage.createTeamMember({
        teamId: parseInt(id),
        userId: memberUserId,
        role,
        joinedAt: /* @__PURE__ */ new Date()
      });
      await storage.createAuditLog({
        action: "team.addMember",
        userId,
        organizationId: team.organizationId,
        entityType: "teamMember",
        entityId: newMember.id.toString(),
        details: { teamId: id, memberId: memberUserId, role },
        timestamp: /* @__PURE__ */ new Date()
      });
      return res2.status(201).json(newMember);
    } catch (error) {
      console.error("Error adding team member:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.patch("/api/teams/:id/members/:memberId", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { id, memberId } = req2.params;
      const { role } = req2.body;
      if (!userId) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      const team = await storage.getTeam(parseInt(id));
      if (!team) {
        return res2.status(404).json({ message: "Team not found" });
      }
      const teamMember = await storage.getTeamMemberByUserAndTeam(userId, parseInt(id));
      if (!teamMember || teamMember.role !== "admin") {
        return res2.status(403).json({ message: "Forbidden - Admin access required" });
      }
      const memberToUpdate = await storage.getTeamMember(parseInt(memberId));
      if (!memberToUpdate || memberToUpdate.teamId !== parseInt(id)) {
        return res2.status(404).json({ message: "Member not found" });
      }
      const updatedMember = await storage.updateTeamMember(parseInt(memberId), {
        role
      });
      await storage.createAuditLog({
        action: "team.updateMember",
        userId,
        organizationId: team.organizationId,
        entityType: "teamMember",
        entityId: memberId,
        details: { role },
        timestamp: /* @__PURE__ */ new Date()
      });
      return res2.json(updatedMember);
    } catch (error) {
      console.error("Error updating team member:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.delete("/api/teams/:id/members/:memberId", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { id, memberId } = req2.params;
      if (!userId) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      const team = await storage.getTeam(parseInt(id));
      if (!team) {
        return res2.status(404).json({ message: "Team not found" });
      }
      const teamMember = await storage.getTeamMemberByUserAndTeam(userId, parseInt(id));
      const memberToDelete = await storage.getTeamMember(parseInt(memberId));
      if (!teamMember || teamMember.role !== "admin" && memberToDelete?.userId !== userId) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      if (!memberToDelete || memberToDelete.teamId !== parseInt(id)) {
        return res2.status(404).json({ message: "Member not found" });
      }
      if (memberToDelete.role === "admin") {
        const admins = (await storage.getTeamMembersByTeam(parseInt(id))).filter((m) => m.role === "admin");
        if (admins.length <= 1) {
          return res2.status(400).json({ message: "Cannot remove the last admin of a team" });
        }
      }
      await storage.deleteTeamMember(parseInt(memberId));
      await storage.createAuditLog({
        action: "team.removeMember",
        userId,
        organizationId: team.organizationId,
        entityType: "teamMember",
        entityId: memberId,
        details: { teamId: id, removedUserId: memberToDelete.userId },
        timestamp: /* @__PURE__ */ new Date()
      });
      return res2.status(204).end();
    } catch (error) {
      console.error("Error removing team member:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.get("/api/audit-logs", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { organizationId, entityType, entityId, action, limit = 50, offset = 0 } = req2.query;
      if (!userId) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      let orgId;
      if (organizationId) {
        orgId = parseInt(organizationId);
        const isMember = await storage.getOrganizationMemberByUserAndOrg(userId, orgId);
        if (!isMember) {
          return res2.status(403).json({ message: "Forbidden" });
        }
      } else {
        const userOrgs = await storage.getOrganizationsByUser(userId);
        if (userOrgs.length === 0) {
          const logs2 = await storage.getAuditLogsByUser(
            userId,
            parseInt(limit),
            parseInt(offset),
            entityType,
            entityId,
            action
          );
          return res2.json(logs2);
        }
      }
      const logs = await storage.getAuditLogs(
        orgId,
        parseInt(limit),
        parseInt(offset),
        entityType,
        entityId,
        action
      );
      return res2.json(logs);
    } catch (error) {
      console.error("Error fetching audit logs:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.get("/api/audit-logs/:id", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { id } = req2.params;
      if (!userId) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      const log2 = await storage.getAuditLog(parseInt(id));
      if (!log2) {
        return res2.status(404).json({ message: "Audit log not found" });
      }
      if (log2.organizationId) {
        const isMember = await storage.getOrganizationMemberByUserAndOrg(userId, log2.organizationId);
        if (!isMember) {
          return res2.status(403).json({ message: "Forbidden" });
        }
      } else if (log2.userId !== userId) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      return res2.json(log2);
    } catch (error) {
      console.error("Error fetching audit log:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.get("/api/workflows/:id/permissions", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { id } = req2.params;
      if (!userId) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      const workflow = await storage.getWorkflow(parseInt(id));
      if (!workflow) {
        return res2.status(404).json({ message: "Workflow not found" });
      }
      if (workflow.ownerId !== userId) {
        if (workflow.organizationId) {
          const orgMember = await storage.getOrganizationMemberByUserAndOrg(userId, workflow.organizationId);
          if (!orgMember || orgMember.role !== "admin") {
            return res2.status(403).json({ message: "Forbidden" });
          }
        } else {
          return res2.status(403).json({ message: "Forbidden" });
        }
      }
      const permissions = await storage.getWorkflowPermissionsByWorkflow(parseInt(id));
      const permissionDetails = await Promise.all(
        permissions.map(async (permission) => {
          if (permission.entityType === "user") {
            const user = await storage.getUser(parseInt(permission.entityId));
            return {
              ...permission,
              entity: user ? {
                id: user.id,
                username: user.username,
                email: user.email,
                profileImageUrl: user.profileImageUrl
              } : null
            };
          } else if (permission.entityType === "team") {
            const team = await storage.getTeam(parseInt(permission.entityId));
            return {
              ...permission,
              entity: team
            };
          } else if (permission.entityType === "organization") {
            const org = await storage.getOrganization(parseInt(permission.entityId));
            return {
              ...permission,
              entity: org
            };
          }
          return permission;
        })
      );
      return res2.json(permissionDetails);
    } catch (error) {
      console.error("Error fetching workflow permissions:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.post("/api/workflows/:id/permissions", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { id } = req2.params;
      const { entityType, entityId, accessLevel } = req2.body;
      if (!userId || !entityType || !entityId || !accessLevel) {
        return res2.status(400).json({ message: "Missing required fields" });
      }
      const workflow = await storage.getWorkflow(parseInt(id));
      if (!workflow) {
        return res2.status(404).json({ message: "Workflow not found" });
      }
      if (workflow.ownerId !== userId) {
        if (workflow.organizationId) {
          const orgMember = await storage.getOrganizationMemberByUserAndOrg(userId, workflow.organizationId);
          if (!orgMember || orgMember.role !== "admin") {
            return res2.status(403).json({ message: "Forbidden" });
          }
        } else {
          return res2.status(403).json({ message: "Forbidden" });
        }
      }
      let entityExists = false;
      if (entityType === "user") {
        const user = await storage.getUser(parseInt(entityId));
        entityExists = !!user;
      } else if (entityType === "team") {
        const team = await storage.getTeam(parseInt(entityId));
        entityExists = !!team;
        if (entityExists && workflow.organizationId && team.organizationId !== workflow.organizationId) {
          return res2.status(400).json({ message: "Team must belong to the same organization as the workflow" });
        }
      } else if (entityType === "organization") {
        const org = await storage.getOrganization(parseInt(entityId));
        entityExists = !!org;
        if (entityExists && workflow.organizationId && parseInt(entityId) !== workflow.organizationId) {
          return res2.status(400).json({ message: "Organization must match the workflow's organization" });
        }
      }
      if (!entityExists) {
        return res2.status(404).json({ message: `${entityType} not found` });
      }
      const existingPermission = await storage.getWorkflowPermissionByEntity(
        parseInt(id),
        entityType,
        entityId
      );
      if (existingPermission) {
        const updatedPermission = await storage.updateWorkflowPermission(
          existingPermission.id,
          { accessLevel }
        );
        await storage.createAuditLog({
          action: "workflow.updatePermission",
          userId,
          organizationId: workflow.organizationId,
          entityType: "workflowPermission",
          entityId: existingPermission.id.toString(),
          details: { workflowId: id, entityType, entityId, accessLevel },
          timestamp: /* @__PURE__ */ new Date()
        });
        return res2.json(updatedPermission);
      }
      const newPermission = await storage.createWorkflowPermission({
        workflowId: parseInt(id),
        entityType,
        entityId,
        accessLevel,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      });
      await storage.createAuditLog({
        action: "workflow.addPermission",
        userId,
        organizationId: workflow.organizationId,
        entityType: "workflowPermission",
        entityId: newPermission.id.toString(),
        details: { workflowId: id, entityType, entityId, accessLevel },
        timestamp: /* @__PURE__ */ new Date()
      });
      return res2.status(201).json(newPermission);
    } catch (error) {
      console.error("Error adding workflow permission:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.delete("/api/workflows/:id/permissions/:permissionId", isAuthenticated12, async (req2, res2) => {
    try {
      const { userId } = req2.user;
      const { id, permissionId } = req2.params;
      if (!userId) {
        return res2.status(401).json({ message: "Unauthorized" });
      }
      const workflow = await storage.getWorkflow(parseInt(id));
      if (!workflow) {
        return res2.status(404).json({ message: "Workflow not found" });
      }
      if (workflow.ownerId !== userId) {
        if (workflow.organizationId) {
          const orgMember = await storage.getOrganizationMemberByUserAndOrg(userId, workflow.organizationId);
          if (!orgMember || orgMember.role !== "admin") {
            return res2.status(403).json({ message: "Forbidden" });
          }
        } else {
          return res2.status(403).json({ message: "Forbidden" });
        }
      }
      const permission = await storage.getWorkflowPermission(parseInt(permissionId));
      if (!permission || permission.workflowId !== parseInt(id)) {
        return res2.status(404).json({ message: "Permission not found" });
      }
      await storage.deleteWorkflowPermission(parseInt(permissionId));
      await storage.createAuditLog({
        action: "workflow.removePermission",
        userId,
        organizationId: workflow.organizationId,
        entityType: "workflowPermission",
        entityId: permissionId,
        details: {
          workflowId: id,
          entityType: permission.entityType,
          entityId: permission.entityId
        },
        timestamp: /* @__PURE__ */ new Date()
      });
      return res2.status(204).end();
    } catch (error) {
      console.error("Error removing workflow permission:", error);
      return res2.status(500).json({ message: "Internal server error" });
    }
  });
  app2.get("/api/oidc/login/:providerId", isAuthenticated12, async (req2, res2) => {
    try {
      const { providerId } = req2.params;
      const provider = await storage.getOidcProvider(parseInt(providerId));
      if (!provider) {
        return res2.status(404).json({ message: "OIDC provider not found" });
      }
      const scopes = typeof provider.scopes === "string" ? JSON.parse(provider.scopes) : Array.isArray(provider.scopes) ? provider.scopes : ["openid", "profile", "email"];
      const providerConfig = {
        ...provider,
        scopes
      };
      const { state, nonce, codeVerifier, codeChallenge } = OpenIDConnectService.generateAuthParams();
      req2.session.oidcState = state;
      req2.session.oidcNonce = nonce;
      req2.session.oidcProviderId = provider.id;
      req2.session.oidcCodeVerifier = codeVerifier;
      const authUrl = await OpenIDConnectService.getAuthorizationUrl(
        providerConfig,
        state,
        nonce,
        codeChallenge
      );
      res2.json({ authUrl });
    } catch (error) {
      console.error("Error initiating OIDC login:", error);
      if (error.name === "OidcProviderError" || error.name === "OidcDiscoveryError") {
        return res2.status(error.statusCode || 400).json({
          error: error.message,
          details: error.details
        });
      }
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.get("/api/oidc/callback", async (req2, res2) => {
    try {
      const callbackParams = {
        state: req2.query.state,
        code: req2.query.code,
        error: req2.query.error,
        error_description: req2.query.error_description
      };
      const sessionState = req2.session.oidcState;
      const sessionNonce = req2.session.oidcNonce;
      const providerId = req2.session.oidcProviderId;
      const codeVerifier = req2.session.oidcCodeVerifier;
      if (!sessionState || !sessionNonce || !providerId) {
        return res2.status(400).json({
          error: "Invalid session",
          message: "Missing required session parameters for OIDC flow"
        });
      }
      if (callbackParams.error) {
        return res2.status(400).json({
          error: "Authentication error",
          message: callbackParams.error_description || callbackParams.error
        });
      }
      const provider = await storage.getOidcProvider(providerId);
      if (!provider) {
        return res2.status(404).json({ message: "OIDC provider not found" });
      }
      const scopes = typeof provider.scopes === "string" ? JSON.parse(provider.scopes) : Array.isArray(provider.scopes) ? provider.scopes : ["openid", "profile", "email"];
      const providerConfig = {
        ...provider,
        scopes
      };
      const tokenSet = await OpenIDConnectService.handleCallback(
        providerConfig,
        callbackParams,
        sessionState,
        sessionNonce,
        codeVerifier
      );
      const userInfo = await OpenIDConnectService.getUserInfo(
        providerConfig,
        tokenSet.access_token
      );
      const integrationConfig = OpenIDConnectService.toIntegrationConfig(
        providerConfig,
        tokenSet
      );
      const user = req2.user;
      if (user) {
        const existingIntegrations = await storage.getApiIntegrationsByUser(user.id);
        const existingIntegration = existingIntegrations.find((i) => i.name === provider.name);
        const configWithUserInfo = {
          ...integrationConfig,
          userInfo: JSON.stringify(userInfo)
        };
        if (existingIntegration) {
          await storage.updateApiIntegration(existingIntegration.id, {
            ...configWithUserInfo,
            config: JSON.stringify(configWithUserInfo)
          });
        } else {
          await storage.createApiIntegration({
            ...configWithUserInfo,
            userId: user.id,
            config: JSON.stringify(configWithUserInfo)
          });
        }
        delete req2.session.oidcState;
        delete req2.session.oidcNonce;
        delete req2.session.oidcProviderId;
        delete req2.session.oidcCodeVerifier;
        res2.redirect("/integrations");
      } else {
        res2.redirect("/login?message=Please%20log%20in%20to%20complete%20the%20integration");
      }
    } catch (error) {
      console.error("Error handling OIDC callback:", error);
      if (error.name && error.name.startsWith("Oidc")) {
        return res2.status(error.statusCode || 400).json({
          error: error.message,
          details: error.details
        });
      }
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.post("/api/oidc/refresh-token/:integrationId", isAuthenticated12, async (req2, res2) => {
    try {
      const { integrationId } = req2.params;
      const user = req2.user;
      const integration = await storage.getApiIntegration(parseInt(integrationId));
      if (!integration) {
        return res2.status(404).json({ message: "Integration not found" });
      }
      if (integration.userId !== user.id) {
        return res2.status(403).json({ message: "Forbidden" });
      }
      const config = JSON.parse(integration.config || "{}");
      if (config.providerType !== "oidc" || !config.refreshToken) {
        return res2.status(400).json({ message: "Not a valid OIDC integration or missing refresh token" });
      }
      const providers = await storage.getAllOidcProviders();
      const provider = providers.find((p) => p.name === integration.name);
      if (!provider) {
        return res2.status(404).json({ message: "OIDC provider not found" });
      }
      const scopes = typeof provider.scopes === "string" ? JSON.parse(provider.scopes) : Array.isArray(provider.scopes) ? provider.scopes : ["openid", "profile", "email"];
      const providerConfig = {
        ...provider,
        scopes
      };
      const refreshedTokens = await OpenIDConnectService.refreshAccessToken(
        providerConfig,
        config.refreshToken
      );
      const updatedConfig = {
        ...config,
        accessToken: refreshedTokens.access_token,
        refreshToken: refreshedTokens.refresh_token || config.refreshToken,
        expiresAt: refreshedTokens.expires_in ? Math.floor(Date.now() / 1e3) + refreshedTokens.expires_in : void 0
      };
      await storage.updateApiIntegration(integration.id, {
        ...integration,
        accessToken: refreshedTokens.access_token,
        refreshToken: refreshedTokens.refresh_token || integration.refreshToken,
        config: JSON.stringify(updatedConfig)
      });
      res2.json({ message: "Token refreshed successfully" });
    } catch (error) {
      console.error("Error refreshing OIDC token:", error);
      if (error.name && error.name.startsWith("Oidc")) {
        return res2.status(error.statusCode || 400).json({
          error: error.message,
          details: error.details
        });
      }
      res2.status(500).json({ message: "Server error" });
    }
  });
  app2.use(usage_routes_default);
  app2.use(subscription_routes_default);
  app2.use("/api/social", social_routes_default);
  app2.use("/api/scraping", scraping_routes_default);
  app2.use(agent_routes_default);
  app2.use(guardrails_routes_default);
  app2.use(search_routes_default);
  app2.use(activity_log_routes_default);
  app2.use(user_preferences_routes_default);
  app2.use("/api/runtime", setupRuntimeRoutes());
  app2.use(execution_routes_default);
  app2.use("/api/integrations/airbyte", airbyte_routes_default);
  app2.use("/api/integrations/composio", composio_routes_default);
  app2.use("/api/integrations/slack", slack_routes_default);
  app2.use("/api/oauth", oauth_routes_default);
  app2.use("/api/langflow", langflow_routes_default);
  app2.use("/api/langchain", langchain_routes_default);
  app2.use("/api/vector-db", vector_db_routes_default);
  registerMemoryRoutes(app2);
  app2.use("/api/rag", rag_routes_default);
  app2.use("/api/rag", rag_import_routes_default);
  app2.use("/api/telemetry", telemetryRouter);
  app2.use("/api/workflows", workflow_default);
  const httpServer = createServer(app2);
  WebSocketHandler_default.initialize(httpServer);
  onEvent("execution_update", (data) => {
    if (data && data.executionId) {
      WebSocketHandler_default.sendExecutionEvent(data.executionId, data.event);
    }
  });
  console.log("[websocket] WebSocket server initialized for workflow executions");
  return httpServer;
}

// server/index.ts
import cors from "cors";
var app = express7();
app.use(cors({
  origin: true,
  // Allow requests from any origin
  methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization", "X-Requested-With", "Accept", "Origin", "Upgrade", "Connection"],
  credentials: true,
  exposedHeaders: ["Set-Cookie", "Date", "ETag"],
  // Special handling for WebSocket
  preflightContinue: true
}));
app.options("/ws", (req2, res2) => {
  res2.header("Access-Control-Allow-Origin", req2.headers.origin || "*");
  res2.header("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
  res2.header("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With, Accept, Origin, Upgrade, Connection");
  res2.header("Access-Control-Allow-Credentials", "true");
  res2.status(200).end();
});
app.use(express7.json());
app.use(express7.urlencoded({ extended: false }));
app.use((req2, res2, next) => {
  const start = Date.now();
  const path6 = req2.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res2.json;
  res2.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res2, [bodyJson, ...args]);
  };
  res2.on("finish", () => {
    const duration = Date.now() - start;
    if (path6.startsWith("/api")) {
      let logLine = `${req2.method} ${path6} ${res2.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  const server = await registerRoutes(app);
  app.use((err, _req, res2, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res2.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  const port = 5e3;
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true
  }, () => {
    log(`serving on port ${port}`);
  });
})();